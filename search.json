[{"title":"数据库第一天---了解数据库","url":"/2026/01/09/计算机语言相关/SQL语言/数据库第一天/","content":"\n# 快考试了,还是勉强学一下这个数据库吧(虽然我讨厌这玩意)\n\n## 数据库相关概念\n\n|      名称      |                             全称                             |               简称               |\n| :------------: | :----------------------------------------------------------: | :------------------------------: |\n|     数据库     |            存储数据的仓库,数据是有组织的进行存储             |           DataBase(DB)           |\n| 数据库管理系统 |                  操纵和管理数据库的大型软件                  | DataBase Management System(DBMS) |\n|      SQL       | 操作关系型数据库的编程语言,定义了一套操作关系型数据库统一标准 | Structured Query Languague(SQL)  |\n\n主流的关系型数据库管理系统:\n\n- Oracle\n- MySQL\n- Microsoft SQL Server\n- PostgreSQL\n- IBM Db2\n- Microsoft Acess\n- SQLite\n- MariaDB\n- Microsoft Azure SQL Database\n- Hive\n\nMySQL怎么下载不说了,我们直接学SQL\n\n因为现在基本上没有人使用命令行了,基本上就是用  navicat  或者 其他可视化工具,不过还是学习一下吧(毕竟要考  悲)\n\n## MsSQL的启动和停止方式\n\n### 方式一\n\n首先我们输入 <font color='Turquoise'>Win +R </font> 并在窗口输入 services.msc\n\n```\nservices.msc\n```\n\n​\t<img src=\"数据库第一天/image-20260109134356762.png\" alt=\"image-20260109134356762\" style=\"zoom:50%;\" />\n\n​\t<img src=\"数据库第一天/image-20260109134449166.png\" alt=\"image-20260109134449166\" style=\"zoom:33%;\" />\n\n此时可以看到MySQL默认是启动了,也可以手动关掉\n\n### 方式二\n\n​\t<img src=\"数据库第一天/image-20260109134644478.png\" alt=\"image-20260109134644478\" style=\"zoom: 50%;\" />\n\n直接在命令行(以管理员身份运行)输入指令\n\n```\nnet start mysql80    //启动\n```\n\n```\nnet stop mysql80      //停止\n```\n\n​\t<img src=\"数据库第一天/image-20260109134940182.png\" alt=\"image-20260109134940182\" style=\"zoom:50%;\" />\n\n## 客户端连接\n\n同样的也是有两种方式\n\n### 方式一\n\n用这个东西,也就是一个控制台\n\n​\t<img src=\"数据库第一天/image-20260109135216876.png\" alt=\"image-20260109135216876\" style=\"zoom:50%;\" />\n\n进入后输入密码(就是你下载MySQL自己设置的那个密码)\n\n​\t<img src=\"数据库第一天/image-20260109135328086.png\" alt=\"image-20260109135328086\" style=\"zoom:50%;\" />\n\n### 方式二\n\n​\t<img src=\"数据库第一天/image-20260109135552291.png\" alt=\"image-20260109135552291\" style=\"zoom:50%;\" />\n\n但是这个有要求-----需要配置  Path路径\n\n​\t<img src=\"数据库第一天/image-20260109135653067.png\" alt=\"image-20260109135653067\" style=\"zoom:50%;\" />\n\n首先我们输入 <font color='Turquoise'>Win +R</font>  输入 sysdm.cpl\n\n```\nsysdm.cpl\n```\n\n​\t<img src=\"数据库第一天/image-20260109135924219.png\" alt=\"image-20260109135924219\" style=\"zoom: 50%;\" />\n\n在    <font color='Turquoise'>高级</font>  里打开  <font color='Turquoise'>环境变量 </font>\n\n​\t<img src=\"数据库第一天/image-20260109140050531.png\" alt=\"image-20260109140050531\" style=\"zoom:50%;\" />\n\n然后找到path\n\n​\t<img src=\"数据库第一天/image-20260109140231482.png\" alt=\"image-20260109140231482\" style=\"zoom:50%;\" />\n\n然后就是点击 <font color='Turquoise'>新建</font>  把  MySQL server的路径放进去(吐槽一下,不知道为什么这个默认在C盘,直接让我C盘红了)\n\n​\t<img src=\"数据库第一天/image-20260109140322713.png\" alt=\"image-20260109140322713\" style=\"zoom:50%;\" />\n\n​\t<img src=\"数据库第一天/image-20260109140455495.png\" alt=\"image-20260109140455495\" style=\"zoom:50%;\" />\n\n完成后需要一路点击<font color='Turquoise'>确定</font>来保存\n\n然后我们 进入  CMD 窗口\n\n<font color='Turquoise'>Win + R</font>输入<font color='Turquoise'> cmd</font>\n\n```\ncmd\n```\n\n​\t<img src=\"数据库第一天/image-20260109140958492.png\" alt=\"image-20260109140958492\" style=\"zoom: 50%;\" />\n\n```\nmysql -u root -p\n```\n\n​\t<img src=\"数据库第一天/image-20260109141118911.png\" alt=\"image-20260109141118911\" style=\"zoom:33%;\" />\n\n可以看到打开了\n\n## MySQL数据模型\n\n​\t<img src=\"数据库第一天/image-20260109141401064.png\" alt=\"image-20260109141401064\" style=\"zoom:50%;\" />\n\n​\t<img src=\"数据库第一天/image-20260109141726045.png\" alt=\"image-20260109141726045\" style=\"zoom:50%;\" />\n\n在一个数据库中可以创建多个服务器,在一个服务器中又可以创建多张表\n\n## SQL语句\n\n### Sql的分类\n\n​\t<img src=\"数据库第一天/image-20260109142250339.png\" alt=\"image-20260109142250339\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"数据库第一天/image-20260109142356738.png\" alt=\"image-20260109142356738\" style=\"zoom:50%;\" />\n\n### DDL\n\n​\t<img src=\"数据库第一天/image-20260109142759904.png\" alt=\"image-20260109142759904\" style=\"zoom:50%;\" />\n\n#### 数据库操作\n\n##### ① 显示所有数据库：\n\n```sql\nSHOW DATABASES;\n```\n\n我们先使用第一个命令看看\n\n​\t<img src=\"数据库第一天/image-20260109144646350.png\" alt=\"image-20260109144646350\" style=\"zoom: 33%;\" />\n\n\n\n##### ② 查询当前数据库：\n\n```sql\nSELECT DATABASE();\n```\n\n记住在使用查询功能先要使用数据库\n\n<img src=\"数据库第一天/image-20260109153145749.png\" alt=\"image-20260109153145749\" style=\"zoom:67%;\" />\n\n##### ③ 创建数据库：\n\n```sql\nCREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];\n```\n\n我们也可以新建一个\n\n```sql\n CREATE DATABASE itcast;\n```\n\n​\t<img src=\"数据库第一天/image-20260109145017489.png\" alt=\"image-20260109145017489\" style=\"zoom:50%;\" />\n\n但是假如我们再次创建相同名字的数据库会不会覆盖原来的呢--------答案是,不会,MySQL会直接报错\n\n​\t<img src=\"数据库第一天/image-20260109145227525.png\" alt=\"image-20260109145227525\" style=\"zoom:67%;\" />\n\n我们可以这么干,判断当前是否存在,不存在就创建,存在就不创建\n\n```sql\n CREATE DATABASE if not exists itcast;\n```\n\n​\t<img src=\"数据库第一天/image-20260109145450344.png\" alt=\"image-20260109145450344\" style=\"zoom:50%;\" />\n\n或者也可以指定数据库字符的编码格式\n\n```sql\ncreate database huyang default charset utf8mb4;\n```\n\n​\t<img src=\"数据库第一天/image-20260109151701582.png\" alt=\"image-20260109151701582\" style=\"zoom:50%;\" />\n\n注意:\n\n> UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集\n\n\n\n##### ④ 删除数据库：\n\n```sql\nDROP DATABASE [ IF EXISTS ] 数据库名;\n```\n\n​\t<img src=\"数据库第一天/image-20260109152049014.png\" alt=\"image-20260109152049014\" style=\"zoom: 50%;\" />\n\n和创建是一样的,可以增加判断条件\n\n```sql\ndrop database if exists itcast;\n```\n\n​\t<img src=\"数据库第一天/image-20260109152423489.png\" alt=\"image-20260109152423489\" style=\"zoom: 67%;\" />\n\n\n\n##### ⑤ 使用数据库：\n\n```sql\nUSE 数据库名;\n```\n\n​\t<img src=\"数据库第一天/image-20260109152859939.png\" alt=\"image-20260109152859939\"  />\n\n#### 表操作\n\n##### 查询\n\n​\t<img src=\"数据库第一天/image-20260109153529843.png\" alt=\"image-20260109153529843\" style=\"zoom: 67%;\" />\n\n###### ① 查询当前数据库所有表：\n\n```sql\nSHOW TABLES;\n```\n\n​\t<img src=\"数据库第一天/image-20260109154105342.png\" alt=\"image-20260109154105342\" style=\"zoom:80%;\" />\n\n因为是才创建的所以是空表\n\n###### ② 查询表结构：\n\n```sql\nDESC 表名;\n```\n\n###### ③ 查询指定表的建表语句：\n\n```sql\nSHOW CREATE TABLE 表名;\n```\n\n这两个指令暂时不讲等会说\n\n\n\n##### 创建\n\n​\t<img src=\"数据库第一天/image-20260109154515286.png\" alt=\"image-20260109154515286\" style=\"zoom: 50%;\" />\n\n```sql\nCREATE TABLE 表名(\n\t字段1 字段1类型 [COMMENT 字段1注释],\n\t字段2 字段2类型 [COMMENT 字段2注释],\n\t字段3 字段3类型 [COMMENT 字段3注释],\n\t...\n\t字段n 字段n类型 [COMMENT 字段n注释]\n)[ COMMENT 表注释 ];\n```\n\n注意这个最后一个字段没有逗号(别问我怎么知道的)\n\n​\t<img src=\"数据库第一天/image-20260109160000403.png\" alt=\"image-20260109160000403\" style=\"zoom: 50%;\" />\n\nok创建完了,我们使用刚才的两个命令了(即 <font color='Turquoise'>  DESC 表名;  </font>  和  <font color='Turquoise'>SHOW CREATE TABLE 表名; </font>)\n\n​\t<img src=\"数据库第一天/image-20260109160402528.png\" alt=\"image-20260109160402528\" style=\"zoom:50%;\" />\n\n​\t<img src=\"数据库第一天/image-20260109160556619.png\" alt=\"image-20260109160556619\" style=\"zoom:67%;\" />\n\n ENGINE=InnoDB  表示存储引擎   \n\nDEFAULT CHARSET=utf8mb4  表示存储编码格式\n\nCOLLATE=utf8mb4_0900_ai_ci表示排序规则\n\n 这几个都是默认的\n\n#### 数据类型\n\n​\t<img src=\"数据库第一天/image-20260109163843708.png\" alt=\"image-20260109163843708\" style=\"zoom:80%;\" />\n\n​\t\n\n##### 数值类型\n\n<img src=\"数据库第一天/image-20260109161850172.png\" alt=\"image-20260109161850172\" style=\"zoom:80%;\" />\n\n##### 字符串类型\n\n​\t<img src=\"数据库第一天/image-20260109162406026.png\" alt=\"image-20260109162406026\" style=\"zoom: 80%;\" />\n\nchar和varchar的区别:\n\n- char:  例如char[10]  即使存储一个字符,也会占用10个字符的空间,因为其他空间会使用空格占用,\n- varchar:  例如 varchar[10] 存储几个字符就占用几个空间\n- 相比varchar来说char的性能更好,因为varchar需要根据内容来计算所需的内存空间,消耗物理计算资源\n- 对于用户名来说用varchar更好一些,对于性别这种char更好一些\n\n##### 日期时间类型\n\n <img src=\"数据库第一天/image-20260109164102830.png\" alt=\"image-20260109164102830\" style=\"zoom:80%;\" />\n\n","tags":["SQL","MySQL"],"categories":["计算机语言","数据库"]},{"title":"数据结构第四天----单链表的学习","url":"/2026/01/08/数据结构相关/02-表/单链表/","content":"\n# 好了,学完了顺序表,我们再来看一下链表\n\n线性表链式存储结构的特点是:\n\n> 用一组任意的存储单元存储线性表的数据元素   (这组存储单元可以是连续的，也可以是不连续的)\n\n说人话就是  链表是一种**不要求内存连续**、通过“**指针/引用**”把元素串起来的数据结构。\n\n为了表示每个数据元素a(i)与其直接后续数据元素a(i+1)之间的逻辑关系,  对数据元素a(i)来说除了其本身的信息之外，还需要存储一个指示，其直接后继的信息  (直接后继的存储位置),这两部分信息组成数据元素a(i)的存储映像，称为<font color='Turquoise'>节点(node)</font>\n\n节点包括两个域:\n\n- 其中存储数据元素的信息称为<font color='Turquoise'>数据域</font> 即  data\n- 存储直接后继存储位置有域称为<font color='Turquoise'>指针域</font>  即  next\n\n指针域中存储的信息称为   <font color='Turquoise'>指针或链</font>\n\nn个节点[a(i) i范围为(1<=i<=n)的存储映像]链接成一个链表即为线性表(a1,a2...an)\n\n相信你可能没有看懂我说的这些东西是啥玩意\n\n这里是一个C语言的代码示例\n\n```c\n//链表存储结构\ntypedef int ElemType;\ntypedef struct node{\n\t\tElemType data;\n\t\tstruct node *next;\n}Node;\n```\n\n我们可以把这个用一个图抽象出来\n\n​\t<img src=\"单链表/image-20260106192044936.png\" alt=\"image-20260106192044936\" style=\"zoom:67%;\" />\n\n其实我个人觉得用铁链这样的结构来描述并不是很准确,我反而觉得像火车这样的模型更加生动形象,火车头是头结点,每节车厢都是一个节点,车厢有自己的编号而且里面的乘客就是数据\n\n​\t<img src=\"单链表/Fn8lTzER8g.jpg\" alt=\"卡通手绘火车\" style=\"zoom:80%;\" />\n\n我们先来看看单链表吧\n\n## 单链表\n\n​\t<img src=\"单链表/image-20260106192446584.png\" alt=\"image-20260106192446584\" style=\"zoom:67%;\" />\n\n这里你也可以看出,单链表的结构非常简单,就像小火车一样,这里从图中你可以发现单链表的几个性质\n\n**单链表是最基础、最常见的一种链表**\n\n### 定义\n\n> 单链表每个节点**只有一个指针**，只指向「下一个节点」\n\n```\nhead → [A|•] → [B|•] → [C|null]\n```\n\n- `head`：头节点（链表的入口）\n- 最后一个节点指向 `null`\n\n如果你没看懂的话这里我详细解释一下\n\n​\t<img src=\"单链表/image-20260106195217062.png\" alt=\"image-20260106195217062\" style=\"zoom: 25%;\" />\n\n链由节点构成,data存储数据 next用于连接下一个节点,next为node类型的指针,存储下一个节点的地址\n\n类似于一个半班有40个同学,每个同学的手上都有一张纸,上面写着另一个同学的学号,而同学本身就是一个地址数据,这样这个同学可以用自己的手上的学号找到另一个同学,形成一个链\n\n​\t<img src=\"单链表/image-20260107103534965.png\" alt=\"image-20260107103534965\" style=\"zoom: 50%;\" />\n\n​\t同样的是单链表也是这样的\n\n\n\n## 单链表的初始化\n\n大家是否还记得在上一篇的顺序表当中我们使用动态分配内存来进行顺序表的初始化,这里我们也可以使用malloc动态分配内存\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\ntypedef int ElemType;\n\ntypedef struct node{\n\t\tElemType data;\n\t\tstruct node *next;\n}Node;\n\nNode*initList(){\n\tNode*head=(Node*)malloc(sizeof(Node));\n\thead->data=0;\n\thead->next=NULL;\n\treturn head;\n}\n\nint main(){\n\t//将list初始化为一个头节点\n\tNode*list=initList();\n\treturn 1;\n}\n```\n\n​\t<img src=\"单链表/image-20260106194539055.png\" alt=\"image-20260106194539055\" style=\"zoom:67%;\" />\n\n其实本质上就是把第一个点设置为头节点,然后将节点里的data数据归零,并且将节点的下一个节点设置为  null\n\n首先用malloc在堆内存中构建了一个节点大小的空间,作为链表头结点 head  即  initlist 函数返回Node类型的指针head\n\n默认给data数据域为0 令next地址为空\n\n​\t<img src=\"单链表/image-20260107111435772.png\" alt=\"image-20260107111435772\" style=\"zoom: 80%;\" />\n\n## 单链表的头插法\n\n\n 注意:头插法的顺序和排列的顺序是相反的 \n\n刚开始只有一个头节点,如果要插入一个数据就往头节点后面去插 ,把头节点next指向第二个节点的那个地址,如果再要插入一个数据,则仍在头节点之后插入\n\n注意,顺序不能错,错了链表就断了\n\n```c\n//头插法\nint insertHead(Node*L,ElemType e){\n\tNode*p=(Node*)malloc(sizeof(Node));\n\tp->data=e;\n\tp->next=L->next;\n\tL->next=p;\n  return 1;\n}\nint main(){\n\tNode *list=initList();\n\tinsertHead(list,10);\n\tinsertHead(list,20);\n}\n```\n\n​\t<img src=\"单链表/单链表-头插法-01.jpg\" alt=\"单链表-头插法-01\" style=\"zoom:67%;\" />\n\n​\t<img src=\"单链表/单链表-头插法-02.jpg\" alt=\"单链表-头插法-02\" style=\"zoom:67%;\" />\n\n​\t<img src=\"单链表/单链表-头插法-03.jpg\" alt=\"单链表-头插法-03\" style=\"zoom:67%;\" />\n\n这里我们画一个图直观表述一下\n\n​\t<img src=\"单链表/image-20260107111909640.png\" alt=\"image-20260107111909640\" style=\"zoom:50%;\" />\n\n第一步:先在内存空间中创建一个节点,然后把传入的e参数赋值给节点中data的数据,即p->data=e;\n\n让头结点参数L指向的下一个节点的地址赋值给新创建的节点指向的下一个节点的地址 即 p->next=L->next;\n\n​\t<img src=\"单链表/image-20260107112001392.png\" alt=\"image-20260107112001392\" style=\"zoom: 50%;\" />\n\n第二步: 然后将p的地址赋值为当前头结点指向的下一个地址  即 L->next=p;\n\n​\t<img src=\"单链表/image-20260107112758717.png\" alt=\"image-20260107112758717\" style=\"zoom: 33%;\" />\n\n​\t<img src=\"单链表/image-20260107112831150.png\" alt=\"image-20260107112831150\" style=\"zoom: 50%;\" />\n\n\n\n这个我们可以用更加直观的可视化图看一下\n\n​\t<img src=\"单链表/image-20260107113505921.png\" alt=\"image-20260107113505921\" style=\"zoom:50%;\" />\n\n说人话就是先创建一个空节点,塞进去一个数据,再把这个节点和之前和头结点相连的那个节点连起来,再让头结点连接这个节点,这样可以确保链不会断掉\n\n## 单链表的遍历\n\n```c\n//遍历\nvoid listNode(Node*L){\n\tNode*p=L->next;\n\twhile(p!=NULL){\n\t\tprintf(\"%d\\n\",p->data);\n\t\tp=p->next;\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tNode *list=initList();\n\tinsertHead(list,10);\n\tinsertHead(list,20);\n\tinsertHead(list,30);\n\t\n\tlistNode(list);\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/image-20260107114631726.png\" alt=\"image-20260107114631726\" style=\"zoom: 50%;\" />\n\n遍历的原理也十分浅显易懂:\n\n打印头结点的下一个节点的数据,打印完了再换下一个,一直到遇到尾节点全部打印完成为止\n\n## 单链表的尾插法\n\n其实相比于头插法这种倒序插入,我更喜欢尾插法这种正序插入的方式\n\n尾插法就是先获取尾节点的地址,然后再去进行尾插法  \n\n即先传进来L链表,链表进来之后赋值给一个p指针  , 如果p的next不为空我们就持续循环p等于p的next  , 相当于一个链一个链的去找,找到最后一个链的时候跳出循环 , 跳出循环的时候 p就是链表的尾节点\n\n```c\n//尾插法\n//先获取尾节点\nNode*get_tail(Node*L){\n\tNode *p=L;\n\twhile(p->next!=NULL){\n\t\tp=p->next;\n\t}\n\treturn p;\n}\n//再实现尾插\nNode*insertTail(Node *tail,ElemType e){\n\tNode *p=(Node*)malloc(sizeof(Node));\n\tp->data=e;\n\ttail->next=p;\n\t//让p的下一个节点变成NULL,并返回尾节点的地址\n\tp->next=NULL;\n\treturn p;\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\t\n\tlistNode(list);\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/单链表-尾插法-01.jpg\" alt=\"单链表-尾插法-01\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"单链表/单链表-尾插法-02.jpg\" alt=\"单链表-尾插法-02\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"单链表/单链表-尾插法-03.jpg\" alt=\"单链表-尾插法-03\" style=\"zoom:50%;\" />\n\n\n\n这里我们可以详细描述一下\n\n第一步:先获取尾节点的地址,思路和遍历差不多\n\n​\t<img src=\"单链表/image-20260107115906521.png\" alt=\"image-20260107115906521\" style=\"zoom:50%;\" />\n\n第二步:这个和头插法基本上差不过,只是多一个步骤那就是将插入的节点变成尾节点\n\n​\t<img src=\"单链表/image-20260107122507227.png\" alt=\"image-20260107122507227\" style=\"zoom: 50%;\" />\n\n这里可以用一个图来直观描述\n\n​\t<img src=\"单链表/image-20260107122745285.png\" alt=\"image-20260107122745285\" style=\"zoom: 50%;\" />\n\n## 单链表在指定位置插入数据\n\n前面说的头插法和尾插法只是在表头或者表尾插入节点,而这里是在任意位置插入\n\n原理:\n\n将原来的链拆除,生成一个新的节点,让新的节点指向插入之前的位置 , 即先获取要插入的节点的位置, 然后让新节点指向要插入的节点所指向的位置,再让被插入的节点指向新节点\n\n```c\n//在指定位置插入数据\nint insertNode(Node*L,int pos,ElemType e){\n\t//用来保存插入位置的前驱节点\n\tNode *p=L;\n\tint i=0;\n\t//遍历链表找到插入位置的前驱节点\n\twhile(i<pos-1){\n\t\tp=p->next;\n\t\ti++;\n\t\tif(p==NULL){\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//要插入的新节点\n\tNode *q=(Node *)malloc(sizeof(Node));\n\tq->data=e;\n\tq->next=p->next;\n\tp->next=q;\n\treturn 1;\n\t\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\t//插入前\n\tlistNode(list);\n\t//插入节点\n\tinsertNode(list,2,15);\n\t//插入后\n\tlistNode(list);\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/image-20260107140622958.png\" alt=\"image-20260107140622958\" style=\"zoom:50%;\" />\n\n​\t<img src=\"单链表/单链表-在指定位置插入数据.jpg\" alt=\"单链表-在指定位置插入数据\" style=\"zoom:50%;\" />\n\n## 单链表的删除\n\n原理: 先找到要删除节点的前置节点,用指针记录要删除的节点,通过修改前置节点的后继结点实现删除,释放删除节点的内存空间\n\n\n\n```c\n//删除节点\nint deleteNode(Node *L,int pos){\n\t//要删除节点的前驱\n\tNode*p=L;\n\tint i=0;\n\t//遍历链表找到要删除节点的前驱\n\twhile(i<pos-1){\n\t\tp=p->next;\n\t\ti++;\n\t\tif(p==NULL){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(p->next==NULL){\n\t\tprintf(\"要删除的位置错误\\n\");\n\t\treturn 0;\n\t}\n\t//q指向要删除的节点\n\tNode *q=p->next;\n\t//让要删除节点的前驱指向要删除节点的后继\n\tp->next=q->next;\n\t//释放要删除节点的内存空间\n\tfree(q);\n\treturn 1;\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\t//插入前\n\tlistNode(list);\n\t//插入节点\n\tinsertNode(list,2,15);\n\t//插入后\n\tlistNode(list);\n\t//删除\n\tdeleteNode(list,2);\n\t//删除后\n\tlistNode(list);\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/image-20260108101907256.png\" alt=\"image-20260108101907256\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"单链表/单链表-删除节点.jpg\" alt=\"单链表-删除节点\" style=\"zoom:50%;\" />\n\n## 单链表获取链表长度\n\n声明一个变量用来累加每循环一次累加一次到尾节点为止,返回尾节点的长度\n\n这个代码假如前面的代码大家看懂了应该可以轻轻松松看懂吧,本质和遍历一样\n\n```c\n//获取链表长度\nint listLength(Node *L){\n\tNode*p=L;\n\tint len=0;\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\t//插入前\n\tlistNode(list);\n\t//插入节点\n\tinsertNode(list,2,15);\n\t//插入后\n\tlistNode(list);\n\t//删除\n\tdeleteNode(list,2);\n\t//删除后\n\tprintf(\"%d\",listLength(list));\n\t//链表长度\n\tlistLength(list);\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/image-20260108103644323.png\" alt=\"image-20260108103644323\" style=\"zoom:50%;\" />\n\n\n\n## 单链表释放链表\n\n指针p指向头节点后的第一个节点,判断指针p是否指向空节点,如果指针P不为空,用指针q记录指针p的后继节点,释放指针P指向的节点,指针p和指针q指向同一个节点循环\n\n```c\n//释放列表\nvoid freeList(Node*L){\n\t//L头节点\n\tNode *p=L->next;\n\tNode *q;\n\twhile(p!=NULL){\n\t\tq=p->next;\n\t\tfree(p);\n\t\tp=q;\n\t}\n\tL->next=NULL;\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\t//插入前\n\tlistNode(list);\n\t//插入节点\n\tinsertNode(list,2,15);\n\t//插入后\n\tlistNode(list);\n\t//删除\n\tdeleteNode(list,2);\n\t//删除后\n\tlistNode(list);\n\t\n\t//链表长度\n\tprintf(\"%d\\n\",listLength(list));\n\tfreeList(list);\n\tprintf(\"%d\\n\",listLength(list));\n\treturn 0;\n}\n```\n\n​\t<img src=\"单链表/image-20260108103406542.png\" alt=\"image-20260108103406542\" style=\"zoom:50%;\" />\n\n​\t<img src=\"单链表/image-20260108103544150.png\" alt=\"image-20260108103544150\" style=\"zoom:50%;\" />\n\n​\t<img src=\"单链表/image-20260108103603614.png\" alt=\"image-20260108103603614\" style=\"zoom:50%;\" />\n\n## 好了,最基本的我们说完了-------等一下,你不能走,把这碗鸡汤喝了  狗头狗头狗头\n\n\n\n## 单链表的双指针\n\n这个其实用实际的例子来解释更直观一点,不然太抽象了\n\n### 例一\n\n​\t<img src=\"单链表/单链表应用01-01.jpg\" alt=\"单链表应用01-01\" style=\"zoom:50%;\" />\n\n​\t<img src=\"单链表/单链表应用01-02.jpg\" alt=\"单链表应用01-02\" style=\"zoom:50%;\" />\n\n```c\n//找到节点数据\nint findNodeFS(Node *L,int k){\n\tNode *fast=L->next;\n\tNode *slow=L->next;\n\t//循环K次每次先走1步,即先走K步\n\tfor(int i=0;i<k;i++){\n\t\tfast=fast->next;\n\t}\n\t\n\twhile(fast!=NULL){\n\t\tfast=fast->next;\n\t\tslow=slow->next;\n\t}\n\tprintf(\"倒数第%d个节点值为:%d\\n\",k,slow->data);\n\treturn 1;\n}\n\nint main(){\n\tNode *list=initList();\n\t//得到当前尾节点\n\tNode *tail=get_tail(list);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttail=insertTail(tail,10);\n\ttail=insertTail(tail,20);\n\ttail=insertTail(tail,30);\n\ttail=insertTail(tail,40);\n\ttail=insertTail(tail,50);\n\ttail=insertTail(tail,60);\n\ttail=insertTail(tail,70);\n\t\n\tlistNode(list);\n\t//找到节点值\n\tfindNodeFS(list,3);\n\treturn 0;\n}\n```\n\n​\t\n\n第一步:我们先假设找到这个4节点(倒数第三个节点),让快慢指针都指向第一个节点即头节点的下一个节点\n\n <img src=\"单链表/image-20260108105305089.png\" alt=\"image-20260108105305089\" style=\"zoom: 50%;\" />\n\n第二步:先让快指针走3步,这里本质上是用慢指针来找到数据的\n\n​\t<img src=\"单链表/image-20260108105414949.png\" alt=\"image-20260108105414949\" style=\"zoom:50%;\" />\n\n第三步:快指针走完后两个指针再同步走\n\n​\t<img src=\"单链表/image-20260108105624598.png\" alt=\"image-20260108105624598\" style=\"zoom:50%;\" />\n\n第四步:一直到快指针遇到尾节点时慢指针就找到了\n\n​\t<img src=\"单链表/image-20260108105701910.png\" alt=\"image-20260108105701910\" style=\"zoom:50%;\" />\n\n <img src=\"单链表/image-20260108105730652.png\" alt=\"image-20260108105730652\" style=\"zoom:33%;\" />\n\n### 例二\n\n这个例子也是第一眼抽象至极\n\n​\t<img src=\"单链表/单链表应用02-01.jpg\" alt=\"单链表应用02-01\" style=\"zoom: 50%;\" />\n\n第一步:我们要先求出两个链表的长度,用于判断两个链表的长度的差距\n\n​\t<img src=\"单链表/单链表应用02-02.jpg\" alt=\"单链表应用02-02\" style=\"zoom:50%;\" />\n\n第二步:让快指针指向更长的那个链表并先走两表的差距长度\n\n​\t<img src=\"单链表/单链表应用02-03.jpg\" alt=\"单链表应用02-03\" style=\"zoom:50%;\" />\n\n第三步:然后两个指针一起动\n\n​\t<img src=\"单链表/单链表应用02-04.jpg\" alt=\"单链表应用02-04\" style=\"zoom:50%;\" />\n\n第四步:然后就会发现两个指针指向同一个地方\n\n​\t<img src=\"单链表/单链表应用02-05.jpg\" alt=\"单链表应用02-05\" style=\"zoom:50%;\" />\n\n```c\n//初始化节点(带节点数据域参数)  不同于之前的单链表的初始化,因为我们要传参,而不是空参\nNode*initListWithElem(ElemType e){\n\tNode *node=(Node*)malloc(sizeof(Node));\n\tnode->data=e;\n\tnode->next=NULL;\n\treturn node;\n}\n\n//查找两个节点共同后缀的起始位置\nNode*findIntersectionNode(Node *headA,Node*headB){\n\tif(headA==NULL||headB==NULL){\n\t\treturn NULL;\n\t}\n\t\n\tNode*p=headA;\n\tint lenA=0;\n\tint lenB=0;\n\t\n\t//遍历链表A,获取链表A的长度\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tlenA++;\n\t}\n\t\n\t//遍历链表B,获取链表B的长度\n\tp=headB;\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tlenB++;\n\t}\n\t\n\tNode *m;//快指针\n\tNode *n;//慢指针\n\tint step;//两个单词之间手差值,可以用于快指针先走的步数\n\t\n\tif(lenA>lenB){\n\t\tstep=lenA-lenB;\n\t\tm=headA;\n\t\tn=headB;\n\t}else{\n\t\tstep=lenB-lenA;\n\t\tm=headB;\n\t\tn=headA;\n\t}\n\t\n\t//让快指针先走step步\n\tfor(int i=0;i<step;i++){\n\t\tm=m->next;\n\t}\n\t//快慢指针同步走,直到指向同一个节点退出循环\n\twhile(m!=n){\n\t\tm=m->next;\n\t\tn=n->next;\n\t}\n\treturn m;\n}\n\n\n\nint main(){\n\tNode *listA=initList();\n\tNode *listB=initList();\n\t\n\t//得到当前尾节点\n\tNode *tailA=get_tail(listA);\n\tNode *tailB=get_tail(listB);\n\t//每次在尾节点位置插入数据后更新尾节点的位置\n\ttailA=insertTail(tailA,'l');\n\ttailA=insertTail(tailA,'o');\n\ttailA=insertTail(tailA,'a');\n\ttailA=insertTail(tailA,'d');\n\t\n\t\n\ttailB=insertTail(tailB,'b');\n\ttailB=insertTail(tailB,'e');\n\t\n//\t这段代码的问题是：\n//\t每次 insertTail 都会新建一个节点，即使你插入的是相同的字符 'i'，它们也是两个不同的节点。\n//\t所以 tailA 和 tailB 的尾部节点地址不同，没有共享，自然找不到共同后缀。\n\t\n//\ttailA=insertTail(tailA,'i');\n//\ttailA=insertTail(tailA,'n');\n//\ttailA=insertTail(tailA,'g');\n//\t\n//\ttailB=insertTail(tailB,'i');\n//\ttailB=insertTail(tailB,'n');\n//\ttailB=insertTail(tailB,'g');\n\t\n\t\n\t\n//\t这段代码的核心是：\n//  nodeI、nodeN、nodeG 是同一份节点对象，被两个链表共享。\n//\t因此两个链表在尾部确实指向了同一个物理地址，满足了“共享后缀”的要求。\n\t\n\tNode *nodeI=initListWithElem('i');\n\ttailA=insertTailWithNode(tailA,nodeI);\n\ttailB=insertTailWithNode(tailB,nodeI);\n\t\n\tNode *nodeN=initListWithElem('n');\n\ttailA=insertTailWithNode(tailA,nodeN);\n\ttailB=insertTailWithNode(tailB,nodeN);\n\t\n\tNode *nodeG=initListWithElem('g');\n\ttailA=insertTailWithNode(tailA,nodeG);\n\ttailB=insertTailWithNode(tailB,nodeG);\n\t\n\tlistNode(listA);\n\tlistNode(listB);\n\tprintf(\"%c\\n\",findIntersectionNode(listA,listB)->data);\n\t\n\treturn 0;\n}\n```\n\n","tags":["Data Structure"],"categories":["数据结构"]},{"title":"之前用C语言设计的学生管理系统","url":"/2026/01/08/计算机语言相关/C语言/学生管理系统/","content":"\n很久以前我们软件工程老师用这个项目设计当做我们的期末作业\n\n当时也是设计了很长时间,最后得了很高的分数,当时记得很激动\n\n```c\n#include <stdio.h>\n#include <stdlib.h>     // system()函数需要引用stdlib.h头文件\n#include <string.h>     // 字符串函数需要引用string.h头文件\n#include <ctype.h>\n\n#define MAX_STUDENTS 30 // 最大学生人数\n\n//定义学生数据存储位置,比如我就放到D盘的\"数据库.txt\"文件里 \n#define FILE_PATH \"D:\\\\数据库.txt\"\n//TXT用UTF-8格式,编译器也设置为UTF-8打开,不然中文全是乱七八糟的字符 \n\nstruct Student {\n    char name[30];     // 姓名\n    long long id;               // 学号\n    float score;      // 成绩\n};\n\n//原本的程序输出的时候输出语句都靠的太近了所以代码中加了很多printf(\"\\n\");语句\n \n// 为了方便检测学生的学号重叠问题,新定义一个checkIdExists函数检查学号是否已存在\nint checkIdExists(struct Student students[], int count, int id) {\n    for (int i = 0; i < count; i++) {\n        if (students[i].id == id) {\n            return 1; // 学号已存在\n        }\n    }\n    return 0; // 学号不存在\n}\n\n\n//输入学生信息函数\nvoid inputStudent(struct Student students[], int *count) {\n\n\tint newCount;\n\tprintf(\"请问要录入几个学生呢?\\n\");\n\tprintf(\"人数:\");\n\tscanf(\"%d\", &newCount); \n\t    \n\t// 计算总共会有多少学生\n\tint total = *count + newCount;\n\t    \n\t//判断输入人数是否合理 ,下面的插入学生函数也做了相同的判断 \n\tif (total > MAX_STUDENTS) {\n\t    int canAdd = MAX_STUDENTS - *count;\n\t    printf(\"对不起哦，您最多只能再录入 %d 个人（总共不能超过 %d 人）\\n\", canAdd, MAX_STUDENTS);\n\t    // 询问用户是否要继续录入可添加的数量\n\t    printf(\"是否录入 %d 个学生？(1. 是 / 0. 否): \", canAdd);\n\t    int choice;\n\t    scanf(\"%d\", &choice);\n\t    if (choice != 1) {\n\t        return;\n\t    }\n\t    newCount = canAdd;\n\t}\n\t    \n\t// 从当前学生数开始录入新学生\n\tfor (int i = *count; i < *count + newCount; i++) {\n\t    printf(\"\\n\");\n\t    printf(\"第%d个学生\\n\", i + 1 - *count);\n\t    //这里因为地球上有一堆人同名同姓,所以允许学生名字相同但学号必须唯一\n\t    printf(\"姓名:\");\n\t    scanf(\"%s\", students[i].name);\n\t        \n\t    //确保学号为10位及以下 \n\t    while (1) {\n\t        printf(\"学号:\");\n\t        //先判断学号是否10位及以下 \n\t        if (scanf(\"%lld\", &students[i].id) != 1 || students[i].id < 0 || students[i].id > 9999999999) {\n\t            printf(\"学号无效（学号必须是最多10位的数字），请重新输入。\\n\");\n\t            while (getchar() != '\\n');\n\t        } else if (checkIdExists(students, i, students[i].id)) {\n\t        \t//再调用checkIdExists判断学号是否重复 \n\t            printf(\"学号 %lld 已存在，请重新输入哦\\n\", students[i].id);\n\t        } else {\n\t        \t//两种情况都不存在的话就跳出while循环\n\t            break;\n\t        }\n\t    }\n\t        \n\t    //确保成绩0~750 \n\t    while (1) {\n\t        printf(\"成绩:\");\n\t        //逻辑和 确保学号为10位及以下 一模一样\n\t        if (scanf(\"%f\", &students[i].score) != 1 || students[i].score < 0 || students[i].score > 750) {\n\t            printf(\"成绩无效（成绩必须在0到750之间），请重新输入哦。\\n\");\n\t            while (getchar() != '\\n');\n\t        } else {\n\t            break;\n\t        }\n\t    }\n\t}\n\t    \n\t// 更新学生总数\n\t*count += newCount;\n\tprintf(\"\\n成功录入 %d 名新学生！当前总共 %d 名学生。\\n\", newCount, *count);\n\n}\n\n//显示所有学生信息\nvoid printAllStudents(struct Student students[], int count) {\n\t//如果没有一个学生 \n\tif (count == 0) {\n\t    printf(\"当前系统没有学生哦。\\n\");\n\t    return;\n\t}\n\t//for循环遍历 \n\tfor (int i = 0; i < count; i++) {\n\tprintf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[i].name, students[i].id, students[i].score);\n  }\n}\n\n// 查找学生信息函数\nvoid searchStudent(struct Student students[], int count) {\n\t\n\t//如果没有一个学生 \n\tif (count == 0) {\n\t\tprintf(\"当前系统没有学生哦。\\n\");\n\t\treturn;\n\t}\n\t\n    int choice;\n\tprintf(\"请选择查找方式：\\n\");\n\tprintf(\"1. 按姓名查找\\n\");\n\tprintf(\"2. 按学号查找\\n\");\n\tprintf(\"请输入选项：\");\n\tscanf(\"%d\", &choice);\n\t\n\tswitch (choice) {\n\t    case 1: { \n\t\t\t// 按姓名查找\n\t        char name[30];\n\t        printf(\"请输入学生姓名：\");\n\t        scanf(\"%s\", name);\n\t\t\t//使用found来定义学生的存在状态 0不存在,1存在 \n\t        int found = 0;\n\t        for (int i = 0; i < count; i++) {\n\t        \t//用strcmp将学生姓名一一对比,如果找到就跳出循环 \n\t            if (strcmp(students[i].name, name) == 0) {\n\t                printf(\"\\n找到啦!\\n\");\n\t                printf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[i].name, students[i].id, students[i].score);\n\t                found = 1;\n\t                break;\n\t            }\n\t        }\n\t        //找不到就输出找不到 \n\t        if (!found) {\n\t            printf(\"没有找到该同学诶。\\n\");\n\t            break;\n\t        }\n\t        break;\n\t    }\n\t    \n\t    case 2: { \n\t\t\t// 按学号查找\n\t        int id;\n\t        printf(\"请输入学生学号：\");\n\t        scanf(\"%d\", &id);\n\t\n\t        int found = 0;\n\t        \n\t        for (int i = 0; i < count; i++) {\n\t        \t//和刚才的姓名查找逻辑一模一样,只是把结构体成员由name改为id \n\t            if (students[i].id == id) {\n\t                printf(\"\\n找到啦!\\n\");\n\t                printf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[i].name, students[i].id, students[i].score);\n\t                found = 1;\n\t                break;\n\t            }\n\t        }\n\t        //没找到就是没找到 \n\t        if (!found) {\n\t            printf(\"没有找到该同学诶。\\n\");\n\t            break;\n\t        }\n\t        break;\n\t    }\n\t    //如果不满足前两个case条件,就输出default \n\t    default:\n\t        printf(\"无效的选项，您只能输入1或者2哦。\\n\");\n\t}\n}\n\n\n// 删除学生信息函数\nvoid deleteStudent(struct Student students[], int *count) {\n\t//如果没有一个学生 \n\tif (*count == 0) {\n\t\tprintf(\"当前系统没有学生哦。\\n\");\n\t\treturn;\n\t}\n\t\n  \tint choice;\n\tprintf(\"请选择删除方式：\\n\");\n\tprintf(\"1. 按姓名删除\\n\");\n\tprintf(\"2. 按学号删除\\n\");\n\tprintf(\"请输入选项：\");\n\tscanf(\"%d\", &choice);\n\t//这里之所以让index=-1而不是0是因为还有一种情况,就是删除前先要通过姓名和学号来查找学生\n\t//如果输入了一个不存在的名字或学号,就要给出\"找不到\"的提示 \n\t//也就是说,前面的查找函数在这里又用了一下 \n\tint index = -1;\n\tswitch (choice) {\n\t    case 1: { \n\t\t// 按姓名删除\n\t        char name[30];\n\t        printf(\"请输入学生姓名：\");\n\t        scanf(\"%s\", name);\n\t  \t\t//删除的逻辑和 上面查找函数一模一样,就是找到这个同学,然后删了他,只是定义了一个index=-1的区别 \n\t  \t\t//因为如果定义index为0或者正数,就会影响下面for循环的使用 ,所以随便定义一个负数比如-1就可以了 \n\t        for (int i = 0; i < *count; i++) {\n\t            if (strcmp(students[i].name, name) == 0) {\n\t            \t//找到了就将index改为当前的学生数组的索引 \n\t                index = i;\n\t                break;\n\t            }\n\t        }\n\t        //找不到就跳出 \n\t        break;\n\t    }\n\t    \n\t    \n\t    case 2: { \n\t\t// 按学号删除\n\t        int id;\n\t        printf(\"请输入学生学号：\");\n\t        scanf(\"%d\", &id);\n\t  \t\t//和姓名删除一模一样 \n\t        for (int i = 0; i < *count; i++) {\n\t            if (students[i].id == id) {\n\t                index = i;\n\t                break;\n\t            }\n\t        }\n\t        break;\n\t    }\n\t    //如果输入其他数字就提醒一下 \n\t    default:\n\t        printf(\"无效的选项，您只能输入1或者2哦。\\n\");\n\t        return;\n\t}\n\t//只要姓名和学号找不到,而代码在函数内从上往下执行 ,就一定会对index的值进行判断\n\t//然后提醒没有这个同学信息 \n\tif (index == -1) {\n\t    printf(\"没有找到该同学诶。\\n\");\n\t    return;\n\t}\n\t  \n\t// 确认删除\n\tint confirm;\n\tfor (int i = 0; i < 3; i++) {\n\t\t//为防止不小心删错了,所以用for循环搞一个确认三遍 \n\t\t// validInput用于检测输入是否有效,因为我发现输入0和1以外的数字会退出删除操作,所以强制规范一下 \n\t    int validInput = 0; \n\t    \n\t\twhile (!validInput) {\n\t\t    printf(\"确定要删除该学生信息吗？需要您确认三遍才行哦(1. 确定 / 0. 取消)：\");\n\t\t    if (scanf(\"%d\", &confirm) == 1 && (confirm == 0 || confirm == 1)) {\n\t\t        validInput = 1; // 如果输入有效，就是要么是0,要么是1,就退出循环\n\t\t    } else {\n\t\t        printf(\"无效的输入，您只能输入0或者1哦\\n\");\n\t\t        while (getchar() != '\\n');  // 清空输入缓冲区\n\t\t    }\n\t\t}\n\t    if (confirm != 1) {\n\t        printf(\"删除操作已取消。\\n\");\n\t        return;\n\t    }\n\t}\n\t  \n\t// 删除学生信息\n\t//这里删除之后调整一下学生索引的位置 \n\t//就是继承原先数组学生的顺序,因为删了一个,新数组又少一个位子,所以被删的学生的索引位子会被下一个学生顶替 \n\tfor (int i = index; i < *count - 1; i++) {\n\t    students[i] = students[i + 1];\n\t}\n\t//删除后将学生总数减一 \n\t(*count)--;\n\tprintf(\"该同学信息已删除!\\n\");\n}\n\n// 修改学生信息函数\nvoid modifyStudent(struct Student students[], int count) {\n\t//如果没有一个学生 \n\tif (count == 0) {\n\t\tprintf(\"当前系统没有学生哦。\\n\");\n\t\treturn;\n\t}\n\t\n\tint choice;\n    printf(\"选择修改方式：\\n\");\n    printf(\"1. 按姓名修改\\n\");\n    printf(\"2. 按学号修改\\n\");\n    printf(\"请输入选项：\");\n    scanf(\"%d\", &choice);\n   //修改的话和删除差不多(指的是前期都是通过按姓名或学号先找到学生,然后修改) \n   \n   //以下部分就是直接套用上面删除函数的逻辑 \n    int index = -1;\n    switch (choice) {\n        case 1: { \n\t\t\t// 按姓名修改\n            char name[30];\n            printf(\"请输入要修改的学生的姓名：\");\n            scanf(\"%s\", name);\n   \n            for (int i = 0; i < count; i++) {\n                if (strcmp(students[i].name, name) == 0) {\n                    index = i;\n                    break;\n                }\n            }\n            break;\n        }\n        \n        case 2: { \n\t\t\t// 按学号修改\n            int id;\n            printf(\"请输入要修改的学生的学号：\");\n            scanf(\"%d\", &id);\n   \n            for (int i = 0; i < count; i++) {\n                if (students[i].id == id) {\n                    index = i;\n                    break;\n                }\n            }\n            break;\n        }\n        \n        default:\n            printf(\"无效的选项，您只能输入1或者2哦。\\n\");\n            return;\n    }\n   \n    if (index == -1) {\n        printf(\"没有找到该同学诶。\\n\");\n        return;\n    }\n   \n    printf(\"\\n找到啦!这是该同学的信息!：\\n\");\n    printf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[index].name, students[index].id, students[index].score);\n    //找到后就是修改这个同学的信息 \n    int modifyChoice;\n    printf(\"\\n请问您要修改他/她的什么信息呢：\\n\");\n    printf(\"1. 修改姓名\\n\");\n    printf(\"2. 修改学号\\n\");\n    printf(\"3. 修改成绩\\n\");\n    printf(\"请输入选项：\");\n    scanf(\"%d\", &modifyChoice);\n    \n    // 存储原始值，以便在取消修改时恢复\n\tstruct Student original = students[index];\n    \n   \t//因为不知道到底改什么信息,所以用switch case语句问一下 要改哪个 \n    switch (modifyChoice) {\n        case 1: { \n\t\t\t// 修改姓名\n            printf(\"请输入新的姓名：\");\n            scanf(\"%s\", students[index].name); \n            break;\n        }\n        \n        case 2: { \n\t\t\t// 修改学号\n\t\t\t//和case1逻辑一模一样 \n            printf(\"请输入新的学号：\");\n            scanf(\"%lld\", &students[index].id);\n            break;\n        }\n        \n        case 3: { \n\t\t\t// 修改成绩\n\t\t\t//和case1逻辑一模一样\n            printf(\"请输入新的成绩：\");\n            scanf(\"%f\", &students[index].score);\n            break;\n        }\n        //就三个选项,要是输入了其他的只能default提醒一下输错了 \n        default:\n            printf(\"无效的选项，您只能输入1或者2或者3哦。\\n\");\n            return;\n    }\n    \n    //同样为防止不小心误改,改之后确认一下 \n\t//这里的逻辑和删除函数里确认删不删逻辑一样\n   \t// 统一确认操作（只需一次确认）\n\tint confirm;\n\tint validInput = 0;// 用于检测输入是否有效\n\twhile (!validInput) {\n\t\tprintf(\"确定要修改学生信息吗？(1. 确定 / 0. 取消)：\");\n\t\t\n\t    if (scanf(\"%d\", &confirm) == 1 && (confirm == 0 || confirm == 1)) {\n\t    \tvalidInput = 1;// 如果输入有效，退出循环\n\t\t} else {\n\t    \tprintf(\"无效的输入，您只能输入0或者1哦\\n\");\n\t    \twhile (getchar() != '\\n');// 清空输入缓冲区\n\t\t}\n\t}\n\t       \n\tif (confirm != 1) {\n\t    // 取消修改，恢复原始值\n\t    students[index] = original;\n\t    printf(\"修改操作已取消。\\n\");\n\t    return;\n\t}\n   \t\n    printf(\"学生信息已修改。\\n\");\n    printf(\"这是他/她修改后的学生信息哦：\\n\");\n    //这里打印一下学生信息看看有没有改错 \n    printf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[index].name, students[index].id, students[index].score);\n}\n\n// 插入学生信息函数\nvoid insertStudent(struct Student students[], int *count) {\n\t//和输入学生信息函数的逻辑一样,要保证学生的数量再合理范围内 \n   \tif (*count >= MAX_STUDENTS) {\n\t    printf(\"学生信息已满(限定 %d 个)，无法插入新学生。\\n\",MAX_STUDENTS);\n\t    return;\n\t}\n\t//提醒一下现在要插入第几个学生以及总共可以有多少个学生 \n\tprintf(\"总共可以插入 %d 个学生,当前已有 %d 个学生，您将插入第 %d 个学生的信息哦!\\n\",MAX_STUDENTS, *count, *count + 1);\n\t\n\t//以下内容逻辑和录入学生信息函数逻辑一模一样 ,就不重复解释了 \n\tprintf(\"请输入新学生的姓名：\");\n\tscanf(\"%s\", students[*count].name);\n\t\n\twhile (1) {\n\t    printf(\"请输入新学生的学号:\");\n\t    if (scanf(\"%lld\", &students[*count].id) != 1 || students[*count].id < 0 || students[*count].id > 9999999999) {\n\t        printf(\"学号无效（学号必须是最多10位的数字），请重新输入。\\n\");\n\t        while (getchar() != '\\n');  // 清空输入缓冲区\n\t    } else if (checkIdExists(students, *count, students[*count].id)) {\n\t        printf(\"学号 %lld 已存在,您看看是不是输错了?请重新输入哦\\n\", students[*count].id);\n\t    } else {\n\t        break;\n\t    }\n\t}\n\t\n\twhile (1) {\n\t    printf(\"请输入新学生的成绩：\");\n\t    if (scanf(\"%f\", &students[*count].score) != 1 || students[*count].score < 0 || students[*count].score > 750) {\n\t        printf(\"成绩无效（成绩必须在0到750之间），请重新输入哦。\\n\");\n\t        while (getchar() != '\\n');  // 清空输入缓冲区\n\t    } else {\n\t        break;\n\t    }\n\t}\n\t\n\t   \n\t(*count)++;\n\tprintf(\"\\n新学生信息已插入!这是他/她的信息哦\\n\");\n\tprintf(\"姓名：%s  学号：%lld  成绩：%.2f\\n\", students[*count - 1].name, students[*count - 1].id, students[*count - 1].score);\n}\n\n//下面如果用冒泡排序,选择排序或插入排序比较浪费时间,如果有几十个学生还好\n//要是成千上百个这种方法效率低下,所以我用快速排序 \n\n// 快速排序的辅助函数，用于交换两个学生的信息\nvoid swap(struct Student *a, struct Student *b) {\n    struct Student temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// 快速排序的辅助函数，用于分区\nint partition(struct Student students[], int low, int high) {\n\t//因为是按学生成绩score进行排名,所以用 students[].score\n    float pivot = students[high].score;\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        if (students[j].score > pivot) {\n            i++;\n            //调用swap函数快速将学生交换 \n            swap(&students[i], &students[j]);\n        }\n    }\n    swap(&students[i + 1], &students[high]);\n    return (i + 1);\n}\n\n// 快速排序函数\nvoid quickSort(struct Student students[], int low, int high) {\n    if (low < high) {\n        int pi = partition(students, low, high);\n\n        quickSort(students, low, pi - 1);\n        quickSort(students, pi + 1, high);\n    }\n}\n\n// 根据成绩排序并显示排名\nvoid rankStudents(struct Student students[], int count) {\n\t\n\t//如果当前系统没有学生的话 \n\tif (count == 0) {\n\t    printf(\"当前系统没有学生哦。\\n\");\n\t    return;\n\t}\n   \t//调用quickSort函数对学生成绩进行降序排序\n    quickSort(students, 0, count - 1);\n   \n    //打印排序后的学生信息\n    printf(\"这是同学们的考试成绩排名哦：\\n\");\n    //遍历打印学生按成绩排名的信息 \n    for (int i = 0; i < count; i++) {\n        printf(\" 第%d名:  姓名：%s  学号：%lld   成绩：%.2f\\n\", i + 1, students[i].name, students[i].id, students[i].score);\n    }\n}\n\n// 统计学生总数\nvoid countStudents(int count) { \n  \tprintf(\"当前一共有：%d个学生哦\\n\", count);\n}\n\n// 清屏函数\nvoid clearScreen() {\n    // 判断操作系统并执行相应的命令\n    #ifdef _WIN32  // Windows 系统\n        system(\"cls\");\n    #else  // Linux / macOS 系统\n        system(\"clear\");\n    #endif\n}\n\n\n//清空缓冲区函数 \nvoid clearInputBuffer() {\n\t// 清空缓冲区直到换行符或文件结束符\n    int c;\n    while ((c = getchar()) != '\\n' && c != EOF) {} \n}\n\n// 退出系统确认函数\n//因为我发现把这个功能写进主函数时程序比较卡,只能单独弄一个函数 ,然后再定义一个clearInputBuffer函数清除一下缓存 \nint confirmExit() {\n\t\n\t//确认的方法和前面使用的差不多 \n    int confirm;\n    \n    for (int i = 0; i < 3; i++) {\n        int validInput = 0;\n        while (!validInput) {\n        \t//这里用了两个三元运算符 \n        \t//三元运算符的执行顺序是从左到右的\n\t\t\t//先判断第一个条件，如果条件为真，则返回第一个结果；如果条件为假，则继续评估下一个条件\n            printf(\"%s\", (i == 0) ? \"真的要退出系统吗亲 (1. 确定退出 / 0. 取消操作)：\"\n                     : (i == 1) ? \"要不要再检查一下亲 (1. 确定退出 / 0. 取消操作)：\"\n                     : \"确认信息无误就可以退出咯 (1. 确定退出 / 0. 取消操作)：\");\n            if (scanf(\"%d\", &confirm) == 1 && (confirm == 0 || confirm == 1)) {\n                validInput = 1;\n            } else {\n                printf(\"无效的输入，您只能输入0或者1哦\\n\");\n                clearInputBuffer(); // 清空输入缓冲区\n            }\n        }\n        if (confirm == 0) {\n            printf(\"取消操作。\\n\");\n            return 0; // 返回0表示取消退出\n        }\n    }\n    return 1; // 返回1表示确认退出\n}\n\n// 保存学生信息到文件\nvoid saveStudentsToFile(struct Student students[], int count) {\n\t//写入文件信息 \n    FILE *file = fopen(FILE_PATH, \"w\");\n    //出现异常时 \n    if (file == NULL) {\n        perror(\"无法打开文件\");\n        return;\n    }\n    //循环遍历输入信息到文件中 \n    for (int i = 0; i < count; i++) {\n       fprintf(file, \"姓名：%s  学号：%lld   成绩：%.2f\\n\", students[i].name, students[i].id, students[i].score);\n    }\n    //停止写入 \n    fclose(file);\n    printf(\"学生信息已保存到文件 %s\\n\", FILE_PATH);\n}\n\n// 从文件加载学生信息\nvoid loadStudentsFromFile(struct Student students[], int *count) {\n\t//读取文件信息 \n\tFILE *file = fopen(FILE_PATH, \"r\");\n\t//判断一下这玩意在不在 \n\tif (!file) {\n\t    printf(\"文件 %s 不存在，将创建新文件\\n\", FILE_PATH);\n\t    return;\n\t}\n\t     \n\t// 初始化学生计数为0\n\t*count = 0;\n\t// 创建缓冲区line用于存储文件中的一行内容\n\tchar line[256];\n\t     \n\t     \n\t// 逐行读取文件内容，直到文件结束或达到最大学生数\n\twhile (fgets(line, sizeof(line), file) && *count < MAX_STUDENTS) {\n\t    // 定位关键字段\n\t    // 在行中定位\"姓名：\",\"学号：\",\"成绩：\"这三个关键字段的位置\n\t    char *name_start = strstr(line, \"姓名：\");\n\t    char *id_start = strstr(line, \"学号：\");\n\t    char *score_start = strstr(line, \"成绩：\");\n\t         \n\t    // 检查这一行是否所有关键字段都存在\n\t    if (!name_start || !id_start || !score_start){\n\t    \t// 只要缺一个就跳过这个的学生信息 \n\t\t\tcontinue;\n\t\t} \n\t\t\t\n\t         \n\t    // 提取姓名,姓名为字符串类型所以需要特殊处理 \n\t    name_start += strlen(\"姓名：\");\n\t    // 计算姓名长度：从\"姓名：\"开始到\"学号：\"结束之间\n\t    int name_len = id_start - name_start - 2;  // 减去两个空格\n\t    \n\t    // 检查姓名长度是否有效（大于0且小于结构体中姓名字段的最大长度）\n\t    if (name_len > 0 && (size_t)name_len < sizeof(students[*count].name)) {\n\t    \t // 复制姓名到学生结构体\n\t    \tstrncpy(students[*count].name, name_start, name_len);\n\t    \t// 确保姓名字符串正确终止\n\t        students[*count].name[name_len] = '\\0';\n\t    }\n\t         \n\t    // 提取学号和成绩\n\t    sscanf(id_start + strlen(\"学号：\"), \"%lld\", &students[*count].id);\n\t    sscanf(score_start + strlen(\"成绩：\"), \"%f\", &students[*count].score);\n\t    \n\t    // 成功加载一个学生，计数器加1\n\t    (*count)++;\n\t}\n\t     \n\tfclose(file);\n\tprintf(\"已从文件 %s 加载 %d 条学生信息\\n\", FILE_PATH, *count);\n}\n\n\nint main() {\n    struct Student students[500];\n    int count = 0;\n    int choice;\n    int init = 0;\n    int clearscreen = 1;\n    \n    // 加载已有的学生信息\n\tloadStudentsFromFile(students, &count);\n\tprintf(\"成功加载 %d 名学生\\n\", count);\n\tfor (int i = 0; i < count; i++) {\n\t    printf(\"加载的学生:姓名:%s  学号:%lld  成绩:%.2f\\n\", students[i].name, students[i].id, students[i].score); \n\t}\n    \n    while(1){\n        // 调用清屏函数\n\t\tif (init > 0) {\n\t\t    int validInput = 0;\n\t\t    while (!validInput) {\n\t\t        printf(\"输入 0 或 1 选择是否清屏:\\n\");\n\t\t        printf(\"1. 清屏\\n\");\n\t\t        printf(\"0. 不清屏\\n\");\n\t\t        printf(\"输入值为:\");\n\t\t        \n\t\t        \n\t\t\t\t//为了防止输入出0和1以外的其他数字影响程序 \n\t\t\t\t//所以要判断输入的是0还是1(在开始写这个代码时就遇到这个问题了)\n\t\t\t\t// 即在输入的数字scanf(\"%d\", &clearscreen) == 1 为整数合法的情况下\n\t\t\t\t//的同时满足 clearscreen为0或者1的条件 \n\t\t        if (scanf(\"%d\", &clearscreen) == 1 && (clearscreen == 0 || clearscreen == 1)) {\n\t\t        \t//满足条件后将validInput的值改为1 ,!validInput就为0,退出while循环 \n\t\t            validInput = 1;\n\t\t            if (clearscreen == 1) {\n\t\t                clearScreen();  // 调用清屏函数\n\t\t            }\n\t\t        } else {\n\t\t        \t//如果输入的不是0或1 \n\t\t            printf(\"无效的输入，您只能输入0或者1哦\\n\");\n\t\t            while (getchar() != '\\n');  // 清空输入缓冲区\n\t\t        }\n\t\t    }\n\t\t}\n        init = 1;\n\t\tprintf(\"\\n\"); \n    \t// 根据用户输入选择是否清屏\n        printf(\"  学生信息管理系统\\n\");\n        printf(\"   1. 输入学生信息\\n\");\n        printf(\"   2. 查找学生信息\\n\");\n        printf(\"   3. 删除学生信息\\n\");\n        printf(\"   4. 修改学生信息\\n\");\n        printf(\"   5. 插入学生信息\\n\");\n        printf(\"   6. 学生成绩排名\\n\");\n        printf(\"   7. 统计学生总数\\n\");\n        printf(\"   8. 显示所有信息\\n\");\n        printf(\"   0. 退出系统\\n\");\n        printf(\"  请选择操作：只能输入0-8中的一个\\n\");\n        printf(\"\\n输入值为:\"); \n        scanf(\"%d\", &choice); // 输入操作选项\n        printf(\"\\n\"); \n        switch (choice) {\n            case 1:\n                printf(\"输入学生信息\\n\");\n                inputStudent(students, &count);\n                printf(\"\\n\");\n                saveStudentsToFile(students, count);\n                break;\n            case 2:\n                printf(\"查找学生信息\\n\");\n                searchStudent(students, count);\n                printf(\"\\n\");\n                break;\n              case 3:\n                printf(\"删除学生信息\\n\");\n                deleteStudent(students, &count);\n                printf(\"\\n\");\n                saveStudentsToFile(students, count);\n                break;\n            case 4:\n                printf(\"修改学生信息\\n\");\n                modifyStudent(students, count);\n                printf(\"\\n\");\n                saveStudentsToFile(students, count);\n                break;\n            case 5:\n                printf(\"插入学生信息\\n\");\n                insertStudent(students, &count);\n                printf(\"\\n\");\n                saveStudentsToFile(students, count);\n                break;\n           case 6:\n                printf(\"根据成绩排名\\n\");\n                rankStudents(students, count);\n                printf(\"\\n\");\n                break;\n            case 7:\n                printf(\"统计学生总数\\n\");\n                countStudents(count);\n                printf(\"\\n\");\n                break;\n            case 8:\n                printf(\"显示所有信息\\n\");\n                printAllStudents(students, count);  // 调用函数显示所有学生信息\n                printf(\"\\n\");\n                break;\n            case 0: \n\t\t\t{\n\t\t\t    if (confirmExit()) { \n\t\t\t\t\t// 调用确认函数\n\t\t\t        printf(\"\\n\");\n\t\t\t        printf(\"退出系统!!! 感谢您的使用 Ciallo～(∠.ω< )⌒★\\n\");\n\t\t\t        // 如果确认退出，则退出程序\n\t\t\t        exit(0); \n\t\t\t    }\n\t\t\t    saveStudentsToFile(students, count);\n\t\t\t    break;\n\t\t\t}\n\t\t\t\n            default:\n                printf(\"无效的选项，您只能输入0~8中的一个哦。\\n\");\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["C"],"categories":["计算机语言"]},{"title":"最近刷Reddit和Youtube评论区发现的缩写单词","url":"/2026/01/07/外语相关/英语/英语里的缩写/","content":"\n最近总是在Steam评论区,Youtube评论区还有reddit评论区看到老外喜欢说一些单词例如ngl  lmao   lel   fr  mb还有其他的一些单词,开始以为是他们单词打错了,后来一堆人重复这些单词就像咱们B站里弹幕上的“合影”“不是哥们”“没这么快”“何意味” “火钳刘明”一样(果然人类的本质就是复读机) ,我就觉得这可能是一些网络流行词,于是我统计了一下\n\n\n\n|      缩写       |                 原单词短语                 |              中文意思              |\n| :-------------: | :----------------------------------------: | :--------------------------------: |\n|       thx       |                   thanks                   |                谢了                |\n|       plz       |                   please                   |               求求了               |\n|  y’all / yall   |                  you all                   |           兄弟们,大家伙            |\n|       imo       |               in my opinion                |              我觉得吧              |\n|       tbh       |                to be honest                |         说真的,说句心里话          |\n|   idk / iono    |                I don’t know                |              我不道啊              |\n|       ngl       |               not gonna lie                |      不骗你的,说真的,不黑不吹      |\n|       fr        |                  for real                  |           真的假的,真的?           |\n|       rn        |                 right now                  |                现在                |\n|       bc        |                  because                   |                因为                |\n|     u / ya      |                    you                     |                 你                 |\n|       ur        |               your / you’re                |             你的,你是              |\n|       ppl       |                   people                   |            人们,一般人             |\n|       gg        |                 good game                  |       神操作 牛逼(游戏用语)        |\n|       smh       |              shaking my head               |             无语,摇头              |\n|  lmfao / lmao   |   laughing my (fucking/freaking) ass of    |         笑死我了 ,笑不活了         |\n|   bruh / bro    |                  brother                   |             兄弟,哥们              |\n|       oof       |                     /                      |         嗷,我嘞个豆,好家伙         |\n|     sheesh      |                     /                      |            嘶,我去,哇塞            |\n| lol / lel / kek |               laugh out loud               |       哈哈哈 ,好好玩,好好笑        |\n|       sry       |                   sorry                    |        不好意思,抱歉,对不起        |\n|       btw       |                 by the way                 | 提一嘴,提醒一下,那个(口口相传的人) |\n|       tho       |                   though                   |             通过,经历              |\n|      thru       |                  through                   |                虽然                |\n| im / ive / ill  |             I’m / I’ve / I'll              |           我是,我有,我会           |\n|    dis / ts     |                    this                    |                这个                |\n|       we        |                  whatever                  |        无所谓了,没事啊没事         |\n|       tyt       |               take your time               |           慢慢来,别急啊            |\n|      probs      |                  probably                  |                可能                |\n|      gonna      |                  going to                  |                将要                |\n|      wanna      |                  want to                   |                想要                |\n|       mb        |                   my bad                   |           我的错,我错了            |\n|       nt        |                  nice try                  |    挺好的呀(鼓励),省省吧(嘲讽)     |\n|       np        |                 no problem                 |               没问题               |\n|    yis / ye     |                    yes                     |             对的,好耶              |\n|        y        |                    why                     |               为啥啊               |\n|       nah       |                 nope / no                  |         不,不咋地,我才不干         |\n|       fam       |                   family                   |            家人,家里人             |\n|      smth       |                 something                  |          什么东西,什么事           |\n|       tmi       |            too much information            |     太详细了,太细了,说的太多了     |\n|      fomo       |            fear of missing out             |         害怕错过,害怕落伍          |\n|       ftw       |                for the win                 |                万岁                |\n|      asap       |            as soon as possible             |                尽快                |\n|       eom       |               end of message               |              我说完了              |\n|      ttyl       |             talk to you later              |      一会见,等会再说,回头再聊      |\n| ily/ imy/ imysm | I love you/ I miss you/ I miss you so much |        爱你呦,想你,想死你了        |\n|       asl       |           Age, sex and location            |       年龄，性别和地址(国籍)       |\n|       brb       |               be right back                |             我马上回来             |\n|       bbl       |               be back later                |             过会就回来             |\n|      ruok       |                 are you ok                 |              你还好吗              |\n|    iowan2bwu    |         I only want to be with you         |           只想和你待一起           |\n|      4ever      |                  forever                   |                永远                |\n|  2b or not 2b   |             To be or not to be             |     对但又不完全对 / 是又不是      |\n|      imho       |            in my humnle opinion            |              鄙人所见              |\n|   m$ulkecraz    |            Miss you like crazy             |             想你想疯了             |\n|   cul8r / cyl   |               see you later                |               稍后见               |\n|      afaic      |          as far as I’m concerned           |             我关心的是             |\n|      afaik      |              as far as I know              |              据我所知              |\n|       afk       |             away from keyboard             |             离开了电脑             |\n|      aisi       |                as I see it                 |            只见,一看到             |\n|      ambw       |             all my best wishes             |             祝愿,祝福              |\n|      aots       |             all of the sudden              |          都是因为一场意外          |\n|      atst       |              at the same time              |                同时                |\n|      aysos      |        are you stupid or something         |             你是傻逼吗             |\n|       gl        |                 good luck                  |              祝你好运              |\n|       gr8       |                   great                    |               太好了               |\n|       🙅‍♀️        |                   before                   |                之前                |\n|     bbfbbm      |      body by fisher,brains by mattel       |          四肢发达头脑简单          |\n|       bbs       |                be back soon                |              马上回来              |\n|       bif       |               basis in fact                |               基本上               |\n|       wtf       |               what the fuck                |         我靠,妈的什么东西          |\n|       wth       |               what the hell                |           什么几把玩意儿           |\n|       br        |                  bathroom                  |            洗澡间,浴室             |\n|       bs        |                 big smile                  |              灿烂的笑              |\n|      ciao       |                  goodbye                   |                再见                |\n|       csl       |            can’t stop laughing             |             笑断气了我             |\n|      cwyl       |            chat with you later             |             一会儿再聊             |\n|       eg        |                 evil grin                  |                坏笑                |\n|       fym       |               fuck you mean                |           你妈的什么意思           |\n|      iggp       |               I gotta go pee               |              我尿个尿              |\n|      inmp       |            it’s not my problem             |            错的又不是我            |\n|       iow       |               In other words               |          换言之,换句话说           |\n|       irl       |                In real life                |              在现实中              |\n|       ru        |                  are you                   |               你是?                |\n|       ty        |                 thank you                  |                谢谢                |\n|       wyp       |            what’s your problem             |              你有病吧              |\n|       wyt       |            whatever you  think             |             管你怎么想             |\n|       yw        |               you’re welcome               |               不客气               |\n|      wdym       |              what do you mean              |              什么意思              |\n|       ikr       |               I know ,right                |         我懂我懂,就是说啊          |\n|       ama       |              ask me anything               |               随便问               |\n|       omw       |                 on my way                  |              我在路上              |\n|       nvm       |                 nevermind                  |         没事,算了,当我没说         |\n|       fyi       |            for your information            |              你参考下              |\n|        /        |                   no cap                   |            真的,不骗你             |\n|      istg       |               I swear to god               |             我对天发誓             |\n|       L/W       |                  loss/win                  |              输 / 赢               |\n|        /        |                    slay                    |               帅,酷                |\n|       sus       |                 suspicious                 |            可疑,不对劲             |\n|       op        |              original poster               |                楼主                |\n|      grwm       |             get ready with me              |            和我一起准备            |\n|       pov       |               point of view                |           主观视角,旁观            |\n|       tia       |             thanks in advance              |        先谢谢啦(求人之前用)        |\n|       dw        |                don’t worry                 |              别担心了              |\n|      aiui       |             as I understand it             |            根据我的理解            |\n|      goat       |            greatest of all time            |              史上最佳              |\n|      ijbol      |         I just brust out laughing          |             哈哈哈哈哈             |\n|       hmu       |                 hit me up                  |               联系我               |\n|       ofc       |                 of course                  |           当然,可以可以            |\n|      fwiw       |            for what it’s worth             |       不管有没有用,恕我直言        |\n|       tbf       |                 to be fair                 |       说句公道话,公正的来说        |\n|      wdyt       |             what do you think              |              你怎么看              |\n|       jw        |               just wondering               |         问问 ,我就好奇一下         |\n|       ah        |                 ahh /ahhh                  |                 啊                 |\n|      fk it      |                  fuck it                   |                我草                |\n|        /        |                  fuck off                  |              滚一边去              |\n|       dae       |            does anyone else...             |            还有人...吗             |\n|       nbd       |                no big deal                 |          没多大事,小意思           |\n|    omg/omfg     |  oh my god /oh my fucking god/oh my gosh   |             我去,天啊              |\n|       lwk       |                  low-key                   |                低调                |\n\n起码老外的评论可以看懂了\n\n因为打字不是很方便所以他们会选择省略单词大小写 或者写谐音词以及省略 引号\n\n比如don’t 写成dont  i’m 写成im \n\n还有很多很多,这里只列出了一些常见的\n","tags":["diary","English"],"categories":["日记","英语"]},{"title":"郁郁了","url":"/2026/01/06/日记相关/日常中二病日记/郁郁了/","content":"\n# 最近郁郁了\n\n感觉健康的心理正在离我远去，对现实中的人和事越来越讨厌和回避，虽然三观目前还算基本正常，但是长时间不与真正的人交流只碰手机电脑，估计损害的不仅仅是健康\n\n但是，我就是，有点太高傲了，总是不想和人交流觉得没有意义，结果就是和Gemini  Chatgpt  Grok AI沟通的更多，虽然这玩意只是及其聪明的工具，但是ai设计之初就对用户有点迎合讨好，感觉逐渐活成了一个性格扭曲至极难以令人理解的人，甚至我的说话方式以及对待一件事的看法还有自我认知每天都在改变，不知道这是不是现代极小一小部分人的通病，还是说我快乐满足感的阀域太高了导致对电子设备之外的一切都提不起兴趣\n\n吃好吃的东西？好像我没什么爱吃的，玩好玩的游戏？别提了，钻研制作游戏的代价就是丧失对95%的游戏的兴趣，而且因为我的关注点全都是游戏背后的技术导致玩起来也没什么意思，再加上电脑拉胯射击游戏罐头游戏和3A什么的甚至是免费领的一些游戏也玩不了或者卡成PPT一直在库里吃灰，手游早就在大一玩腻了彻底祛魅了，刷视频看番？说实话，我都快看吐了，就好像把吃过的吐出来再嚼几遍，学校教的感觉也没有一丁点实际用途，那些专业课一个二个都他喵的为考研而不是就业而生的,虽然已经天天没事找事干自娱自乐了，但好像就是，知道的越多，这种矛盾越明显，我就越难受\n\n所以我经常写点什么发泄一下比如写一些开发日志或者技术文章或者编故事剧情还有中二个人反思（然后这些东西键盘一敲就是几千字），这下知道为什么那些大佬们总是喜欢分享自己的知识给别人了\n\n有的时候在QQ玩玩抽象或者水水群，但绝大多数时候写东西都在我自己部署搭建的静态网站（github.io和vercel.app  国人不挂梯子极难找到或打开）上而不是像某些人无脑发到小黑盒小红书知乎贴吧B站抖音Twitter Facebook Instagram公之于众，但第二天早上我八成又会改变想法觉得昨天晚上怎么这么蠢这么中二病这么沙雕然后删掉\n\n不知道是不是脑细胞过于活跃还是手机蓝光刺激眼球，导致总是睡不着或胡思乱想，还是说自己内心太幼稚了，经历的还是太少了承受能力差了点，连独处独自生活这点破事都搞不明白，虽然从来没有依赖过任何人，只是家里给点生活费，人际关系只能说，跟外星人刚来地球一样,自卑倒是没有，自负倒是有点，感觉做什么事情都只是在遵循自己的爱好和一意孤行，绩点保研啥的早就看透了，找工作这种想都不敢想，外面的一切都是只看马内这俩字,而且我也不知道我能干什么,社会太复杂残酷了,选择有的时候大于努力多的多得多\n\n我去，天快亮了，玛德，睡觉睡觉，今天还有早八 想那么多干嘛 还不照样该怎么样还怎么样  而且我不应该专心于期末突击吗真是的\n\n但是我也不想再温水煮青蛙坐以待毙了,很多人喜欢给别人贩卖焦虑来增添自身的满足感,不知道这么做有什么意义,我身边的某些人就是一天到晚焦虑的不行,眼睛里只有功名利禄四个字,挺可惜的,钱和身份这种东西,说实话,我普通人一个月700都可以活的非常自在\n\n## 回顾很久以前我战胜过什么-----------\n\n### ①意淫\n\n以前喜欢看瑟瑟,对女生充满了意淫,后来花了两年时间克服了(说是克服,其实不过是把注意力从真人身上全部转移到二次元,导致对现实中的女生完全没什么兴趣),但还是有戒断反应,有的时候真的恨透了人类的繁殖方式,明明只是一个重复性的动作,大脑却可以给予多巴胺正反馈激励,就他喵的和 drug 一样,但是我从来没有喜欢过任何女生,现在也是\n\n### ②自暴自弃 \n\n这个你可能觉得,我这个样子怎么可能自暴自弃,这我可得说了,以前我很讨厌数学,包括所有和数学相关的东西比如物理计算,化学计算,生物的孟德尔遗传计算,尤其是到了高考前两个月,我都绝望了,数学当时最高才66,物理就十几分,根本就不想学了,没什么意思,每天都在考虑休学和复读这件事(习得性无助了属于是),但是当时的我们班数学老师觉得我英语,生物,化学能做到年级前40,数学物理却是年级倒数第几,然后她就每天第一节课给我发一张数学小题页,然后晚自习找她对答案,相当于是开小灶\n\n虽然没什么用,但是班主任当时教物理的,想让我学我们全班第一的学习方式就把我和他安排坐一块,这个货脑子极为灵活而且很调皮捣蛋,但是成绩总是600以上,当时我就看到他搞错题本,就是把卷子和书裁成一片一片的贴到错题本上而且从来不刷题,第一次看到的时候觉的不可思议,但是后来我也这么做发现,这是最有效的方式-----就是以题目来来联想知识点而不是先学知识再盲目做题,然后我把数学和物理每一次考完试的卷子不会写的题都一题一题的粘到本子上,也没有像人家那种题海战术刷题一刷厚厚一本,不过我确实在本子上整理了300多个一直考的核心题目,成绩确实提上来了,但是还是忘不了那个时候什么都不会的无力感,搞笑的是高考出考场我都估出来了我的数学成绩,很有感触的一件事就是考完最后一门理综后 就是一个小妹妹跑过来送我一朵向日葵,这种心情不知道怎么描述,那天还非常热,考英语听力的时候关掉了空调衣服都湿了一半,但是出考场的时候感觉一身轻松\n\n### ③自杀倾向\n\n高中的时候尤其是高三晚期竞争最为激烈的时候没有一天不想死的,那时候还干过比较蠢的事,就是用小刀在手臂上滑来滑去甚至刺出血,或者在三更半夜的时候莫名其妙哽咽掉眼泪,现在看来确实就是个大沙币,活着已经很不容易了,那时候每天睡眠不足5小时,当时总是自言自语唉声叹气每天内耗至极(对了,我自言自语这个习惯就来自这个时期),表现的就像双重人格一样,而且当时没有什么朋友可以共勉,现在也没有(悲),那个时候大家都不理解我,只是觉得我是一个非常卷并且严肃认真的人,但是不是这样的,学校压制了我的天性罢了,我在家里就像小孩子一样,所以当时住校时只能看小说来分散自己的注意力,比如西游记和三体三部曲我差不多书都快翻烂了,不过现在我再也不用看别人的眼光了,已经习惯成自然了,乐观开朗这种事还是学会了很多,而且我也在致力于表现的幽默抽象搞笑一些而不是像活死人一样,虽然高中隐藏了自己隐藏了三年,但是现在我只想如何给像我这一样面临困惑和迷茫的人制造一些乐趣\n\n今年2026年了,我还是努力的找找自己有什么闪光点吧,虽然我只看到了自己的缺点和不足,现实中还是有很多美好和希望的,忘掉过去才能以崭新的姿态迎接未来属于是,反正觉得现在的自己和1年半前刚上大学时候的自己完全是两个人,甚至外貌声音和心理也发生巨大的变化,能坦白说出这些东西很不容易,不过这是我自己的网站,所有的一切都是写给我自己看的,我想怎么样就怎么样  就是这么任性 <font color='Gold'>狗头 狗头 狗头</font>\n\n\n\n","tags":["diary"],"categories":["日记"]},{"title":"Resource Hacker软件推荐","url":"/2026/01/05/软件推荐/Resource Hacker软件/","content":"\n# 最近在国外评论区看到一个老哥分享了一个这个软件,可以修改文件默认图标,感觉可以用来修改love 2d导出的exe的默认图标,这里就用浏览器机翻插件翻译一下老哥给的说明书吧\n\nResource HackerTM is a resource editor for 32bit and 64bit Windows® applications. It's both a **resource compiler** (for *.rc files), and a **decompiler** - enabling viewing and editing of resources in executables (*.exe; *.dll; *.scr; etc) and compiled resource libraries (*.res, *.mui). While Resource Hacker is primarily a GUI application, it also provides many options for compiling and decompiling resources from the command-line.\nResource HackerTM 是一款适用于 32 位和 64 位 Windows® 应用程序的资源编辑器。它既是**资源编译器** （针对 *.rc 文件），也是一个**反编译器** ——支持查看和编辑可执行文件（*.exe; *.dll; *.scr; 等）以及编译后的资源库（*.res、*.mui）。虽然 Resource Hacker 主要是一个图形界面应用，但它也提供了多种从命令行编译和反编译资源的选项。\n\n<img src=\"Resource Hacker软件/rh_dlg_edit.png\" alt=\"Resource Hacker\"  />\n\n<img src=\"Resource Hacker软件/rh_menu2.png\" alt=\"img\"  />\n\n\n\n### Compiling: 编译：\n\nCompiling can be initiated either by opening an existing resource script file, or by creating one from scratch using Resource Hacker's editor.\n编译可以通过打开现有的资源脚本文件，或使用 Resource Hacker 的编辑器从头创建脚本文件来启动。\n\nA complete list of Resource-Definition Statements can be found [here](https://msdn.microsoft.com/en-us/library/windows/desktop/aa381043(v=vs.85).aspx).\n资源定义语句的完整列表[可在此查](https://msdn.microsoft.com/en-us/library/windows/desktop/aa381043(v=vs.85).aspx)阅。\n\nAdditional features of Resource Hacker's compiler include: The #INCLUDE directive (to access definition statements in header files etc) can be nested to multiple levels, as can the #IF, and #IFDEF directives. #DEFINE, #UNDEF, #IF, #ELIF, #ELSE, #IFDEF, #IFNDEF, #INCLUDE, and #PRAGMA directives are all supported. Strings, between double-quote (\") characters, may contain typical 'C' style backslashed 'escaped' characters — \\t , \\n , \\\\ , \\\" , \\x, \\u and \\377 (octal). A double-quote within a string must be 'escaped' using either a preceding backslash or with another double-quote. Script comments are preceded either by double forward-slashes (//) or by a semi-colon (;). Filenames with relative paths are allowed. Filenames that contain spaces must be enclosed within double-quote characters.\n资源黑客编译器的附加功能包括：#INCLUDE 指令（用于访问头文件中的定义语句等）可以嵌套到多个层级，#IF 和 #IFDEF 指令也可以嵌套。#DEFINE、#UNDEF、#IF、#ELIF、#ELSE、#IFDEF、#IFNDEF、#INCLUDE 和 #PRAGMA 指令均被支持。字符串在双引号（“）字符之间，可能包含典型的”C“风格反斜线”转义“字符——\\t、\\n、\\\\、\\”、\\x、\\you 和\\377（八进制）。字符串中的双引号必须通过前置反斜杠或另一个双引号“转义”。脚本注释前通常以双斜杠（//）或分号（;)。允许使用带有相对路径的文件名。包含空格的文件名必须用双引号字符包围。\n\nCompiler error messages are reported, even errors nested within INCLUDE statements ...\n编译器错误消息会被报告，甚至嵌套在 INCLUDE 语句中的错误......\n<img src=\"Resource Hacker软件/rh_scrpt_err.png\" alt=\"img\"  />\n\n\n\n### Viewing and Editing Resources: 观看与编辑资源：\n\nOnce a resource file has been opened, its resources will generally be displayed as either an image (or group of images) or as decompiled text. Binary resources, usually images, can't be edited directly with Resource Hacker, but they can still be very easily exported and imported once they've been modified by an external image editor. (I see no benefit in duplicating what third-party image editors do so well.)\n资源文件打开后，其资源通常会以图像（或一组图像）或反编译文本的形式显示。二进制资源，通常是图片，不能直接用 Resource Hacker 编辑，但经过外部图片编辑修改后，仍然可以非常轻松地导出和导入。（我看不出复制第三方图片编辑器做得很好的做法有什么好处。）\n\n<img src=\"Resource Hacker软件/rh_icon.png\" alt=\"img\"  />\n\n<img src=\"Resource Hacker软件/rh_scrpt.png\" alt=\"img\"  />\n\nMenu and Dialog resource types have their own WYSIWYG designers:\n菜单和对话资源类型各自拥有所见即所得设计器：\n\n<img src=\"Resource Hacker软件/rh_mnu_ctrl.png\" alt=\"img\"  />\n\n<img src=\"Resource Hacker软件/rh_dlg_ctrl.png\" alt=\"img\"  />\n\nBinary resources that have unknown formats will be displayed as read-only binary text. (Any resource can also be viewed in this fashion if desired.)\n格式未知的二进制资源将以只读二进制文本显示。（任何资源也可以以这种方式查看。）\n<img src=\"Resource Hacker软件/rh_binary.png\" alt=\"img\"  />\n\n\n\n### Other Actions: 其他行动：\n\n<img src=\"Resource Hacker软件/rh_main_menu.png\" alt=\"img\"  />\n\n\n\n### Command Line Syntax: 命令行语法：\n\nJust about all the functionality of Resource Hacker can be accessed from the command line without having to open the Resource Hacker GUI.\n资源黑客几乎所有功能都可以通过命令行访问，无需打开资源黑客的图形界面。\n\nCommand line instructions and Resource Hacker scripts can remove the drudgery entailed with repeating Resource Hacker tasks.\n命令行指令和资源黑客脚本可以消除重复资源黑客任务带来的繁琐负担。\n\nCommand-line instructions are a combination of switch statements followed by switch parameters as explained in the following table: **Command line statements:**\n命令行指令是 switch 语句加上 switch 参数的组合，详见下表： **命令行语句：**\n\n\n\n| Switch     切换 |      | Parameter 参数                                               |\n| :-------------: | :--- | :----------------------------------------------------------- |\n|      open       |      | filename - the name of the file that is to be modified. It should be a Windows PE file (*.exe, *.dll etc) or a compiled or uncompiled resouce file (*.res or *.rc)                                                                                                                             文件名——要修改的文件名称。它应该是 Windows PE 文件（*.exe、*.dll 等）或已编译或未编译的资源文件（*.res 或*.rc） |\n|      save       |      | usually a filename for the new or modified file, but can also be a folder when extracting multiple resources                通常为新文件或修改文件命名，但解压多个资源时也可以是文件夹 |\n|    resource     |      | filename - contains a resource being added to the opened file.                                                                                      filename - 包含正在添加到打开文件中的资源 |\n|     action      |      | action to be performed on the opened file                                                                                                                                        对已打开的文件执行的操作                                                                                                                                                          ①**add** - add a resource, but fails if it already exists                                                                                                                                **添加** - 添加资源，但如果资源已经存在则失败                                                                                                                                                            ②**addoverwrite** - add a resource, and overwriting if it already exists                                                                                **增添覆盖** - 添加资源，如果已有资源则覆盖                                                                                                             ③**addskip** - add a resource, but skipping if it already exists                                                                                                **增添忽略** - 添加资源，但如果已经存在就跳过                                                                                                           ④**compile** - compiles a resource script file (*.rc) to a binary resource file (*.res)                                                                             **编译** - 将资源脚本文件（*.rc）编译为二进制资源文件（*.res）                                                                                                ⑤**delete** - delete a resource                                                                                                                                                                             **删除** - 删除资源                                                                                                                                                                            ⑥**extract** - extract a resource                                                                                                                                                            **提取** - 提取资源                                                                                                                                                               ⑦**modify** - modify a resource                                                                                                                                                         **修改** - 修改资源                                                                                                                                                      ⑧**changelanguage(langID)** - changes the language of ALL resources                                                                                **更改语言（langID）** - 更改所有资源的语言 |\n|      mask       |      | resource mask - Type,Name,Language                                                                                                                                                    资源掩码 - 类型、名称、语言                                                                                                                                                 commas are mandatory but each of Type, Name & Language are optional                                                                                  逗号是必加的，但类型、名称和语言中每个内容都是可选的 |\n|       log       |      | Filename or **CONSOLE** or **NUL**                                                                                                                                                                 文件名、**CONSOLE** 或 **NUL**                                                                                                                                                     CONSOLE can be abbreviated to **CON**                                                                                                                                       CONSOLE 可以缩写为 **CON**                                                                                                                                                         Logs the details of the operation performed   记录作细节                                                                                                                        If this switch is omitted, the log will be written to *resourcehacker.log*                                                                                                如果省略了该开关，日志将被写入 *resourcehacker.log* |\n|     script      |      | filename - contains a multi-command script, NOT a resource script for more info: -help script                                                 filename - 包含一个多命令脚本，而非资源脚本。更多信息是：-help script |\n|      help       |      | options - command-line or script (always logged to CONSOLE) other switches are ignored. 选项——命令行或脚本（始终记录在控制台），其他交换机则被忽略 |\n\n\nNotes:  注释：\n\n1. Switch identifiers (except -script) may be abbreviated down to a single char (eg -res or -r).\n   交换标识符（除 -script 外）可以缩写为单个字符（例如 -res 或 -r）。\n2. Switch instructions do not have to be in any particular order.\n   开关指令不必按特定顺序排列。\n3. File names that contain spaces must be enclosed within double quotes.\n   包含空格的文件名必须用双引号包围。\n\n\n**Batch file Examples** (using rh.exe instead of ResourceHacker.exe in places for brevity)\n**批处理文件示例** （部分使用 rh.exe 代替 ResourceHacker.exe 以简洁起见）\n\nreshack_help.bat:  reshack_help.bat：\n\n```\nResourceHacker.exe -help\n@pause  :: to see the console output before the CMD window closes.\n```\n\n\nreshack_compile_res_script.bat:\n\n```\nrh.exe -open .\\in\\resources.rc -save .\\out\\resources.res -action compile -log NUL\n```\n\n\nreshack_add_icon_to_old.bat:\n\n```\nrh.exe -open old.exe -save new.exe -action addskip -res my.ico -mask ICONGROUP,MAINICON,\n```\n\n\nreshack_extract_all_source_icons_to_icons_folder.bat:\n\n```\nrh.exe -open source.exe -save .\\icons -action extract -mask ICONGROUP,, -log CON\n@pause\n```\n\n\nreshack_extract_all_dialogs.bat:\n\n```\nrh.exe -open source.exe -save .\\dialogs.rc -action extract -mask DIALOG,, -log rh.log\n```\n\n\nreshack_execute_my_script.bat:\n\n```\nResourceHacker.exe -script myscript.txt\n```\n\n\n**Resource Hacker Scripts: 资源黑客脚本：**\n\nResource Hacker Scripts are executed from the command-line using the following syntax:\n资源黑客脚本通过命令行使用以下语法执行：\n\n\n\n```\n  ResourceHacker.exe -script ScriptFile\n```\n\n\nResource Hacker Scripts are text files with the following format:\n资源黑客脚本是具有以下格式的文本文件：\n\n\n\n```\n  //comments are preceded by double slashes\n  [FILENAMES]\n  Open=\n  Save=\n  Log=\n  [COMMANDS]\n  //one or more of the following commands ...\n  -add          SourceFile, ResourceMask\n  -addskip      SourceFile, ResourceMask\n  -addoverwrite SourceFile, ResourceMask\n  -addoverwrite SourceFile, ResourceMask\n  -modify       SourceFile, ResourceMask\n  -extract      TargetFile or TargetFolder, ResourceMask\n  -delete       ResourceMask\n  -changelanguage(langID)\n```\n\n\nNote: Filenames that include spaces must be enclosed within double quotes.\n注意：包含空格的文件名必须用双引号包围。\n\n**Resource Hacker Script examples:\n资源黑客脚本示例：**\n\nrh_script_myprog_rus.txt -\n\n```\n  //This script deletes all Language Neutral (0)\n  //string-table, menu and dialog resource items\n  //in MyProg.exe before replacing them\n  //with Russian (1049) items...\t\n  [FILENAMES]\n  Exe=    MyProg.exe\n  SaveAs= MyProg_Rus.exe\n  Log=    MyProg_Rus.log\t\n  [COMMANDS]\n  -delete  MENU,,0\n  -delete  DIALOG,,0\n  -delete  STRINGTABLE,,0\n  -add     MyProg_Rus.res, MENU,,1049\n  -add     MyProg_Rus.res, DIALOG,,1049\n  -add     MyProg_Rus.res, STRINGTABLE,,1049\n```\n\n\nrh_script_myprog_upd_images.txt -\n\n```\n  //This script updates 2 bitmaps and an\n  //icon in MyProg.exe ...\t\n  [FILENAMES]\n  Exe=    MyProg.exe\n  SaveAs= MyProg_Updated.exe\t\n  [COMMANDS]\n  -addoverwrite Bitmap128.bmp, BITMAP,128,\n  -addoverwrite Bitmap129.bmp, BITMAP,129,0\n  -addoverwrite MainIcon.ico, ICONGROUP,MAINICON,0\n```\n\n\nrh_script_myprog_upd_all.txt -\n\n```\n  //This script replaces all resources\n  //in MyProg.exe with all the resources\n  //in MyProgNew.res\t\n  [FILENAMES]\n  Exe=    MyProg.exe\n  SaveAs= MyProg_Updated.exe\n  [COMMANDS]\n  -delete  ,,,            //delete all resources before...\n  -add MyProgNew.res ,,,  //adding all the new resources\n```\n\n\n\n\n\n### \"Packed\" or \"Compressed\" Executables: “打包”或“压缩”可执行文件：\n\nSome executable files are \"packed\" or \"compressed\" using compression algorithms. Not only does this reduces file size, it also makes viewing and modifying resources marginally more difficult. I suspect that this resource 'hiding' is (or was) a common objective in this process. Anyhow, in deference to these authors, I've chosen not to unpack files with Resource Hacker. As a side note, it seems that \"packed\" executables have become quite uncommon over the last 5-10 years, and software authors are exposing more rather than less information in executable resources. I suspect that earlier concerns about the loss of intellectual property with reverse engineering have been allayed.\n一些可执行文件通过压缩算法进行“打包”或“压缩”。这不仅减少了文件大小，也使查看和修改资源变得稍微困难一些。我怀疑这种资源“隐藏”是（或者曾经）是这个过程中的一个常见目标。无论如何，为了尊重这些作者，我选择不用 Resource Hacker 解压文件。顺便说一句，过去 5 到 10 年里，“打包”可执行文件变得相当罕见，软件作者在可执行资源中暴露的信息更多而非减少。我怀疑早期关于逆向工程导致知识产权损失的担忧已经得到缓解。\n\n### Download version 5.2.8: 下载版本5.2.8：\n\n[<font color='Turquoise'>EXE install</font>](https://www.angusj.com/resourcehacker/reshacker_setup.exe) (4.1MB)\n[<font color='Turquoise'>EXE 安装</font> ](https://www.angusj.com/resourcehacker/reshacker_setup.exe)（4.1MB）\n\n[<font color='Turquoise'>ZIP install</font>](https://www.angusj.com/resourcehacker/resource_hacker.zip) (3.3MB)\n[<font color='Turquoise'>ZIP 安装</font> ](https://www.angusj.com/resourcehacker/resource_hacker.zip)（3.3MB）\n\n**Changes in 5.2.8: 5.2.8 版本的变化：**\n\n- fixed bug compiling controls with -1 id in DialogEx\n  修复了 DialogEx 中 -1 id 的编译控件错误\n\n**Changes in 5.2.7: 5.2.7 版本的变化：**\n\n- fixed minor bugs in commandline scripts\n  修复了命令行脚本中的小错误\n\n**Changes in 5.2.6: 5.2.6 版本的变化：**\n\n- fixed a bug incorrectly detecting text encoding\n  修复了一个错误检测文本编码的错误\n- fixed several other minor bugs\n  修复了其他几个小错误\n\n# 不过其实我也没看懂个软件到底是干嘛的,感觉像是那种反编译搞破解的玩意,老哥就说了怎么换图标  教程如下\n\n1. Create an .ico file using [GIMP](http://gimp.org/), you can use the `game.ico` or `love.ico` included in the 32bit redistributable of LÖVE as a template.\n   用 [GIMP](http://gimp.org/) 创建.ico 文件，你可以用 LÖVE32 位再分发包里附带的 `game.ico` 或 `love.ico` 作为模板。\n\n2. Rename your `.exe` file to `nonsense.exe` (explanation below).\n   将你的 `.exe` 文件重命名为 `nonsense.exe`（下面有说明）。\n\n3. Drag the `.exe` file into [Resource Hacker](http://www.angusj.com/resourcehacker/), unfold `Icon Group` and right-click the only item in it. Select \"Replace icon ...\" and select the `.ico` file you created.\n   把 `.exe` 文件拖到 [Resource Hacker，](http://www.angusj.com/resourcehacker/) 展开`图标组 `，右键点击里面唯一的项目。选择“替换图标......”然后选择你创建的 `.ico` 文件。\n\n   ​\t<img src=\"Resource Hacker软件/image-20260106183423234.png\" alt=\"image-20260106183423234\"  />\n\n4. Press Save (floppy disk icon).\n   点击保存（软盘图标）。\n\n5. You might not see the change yet. Rename `nonsense.exe` to `yourgamename.exe` and it should become visible.\n   你可能还没看到变化。把 `nonsense.exe` 改名为 `yourgamename.exe`，应该会显示出来\n","tags":["software"],"categories":["软件推荐"]},{"title":"一些我感觉很有意思的心理学效应","url":"/2026/01/04/日记相关/日常中二病日记/一些我感觉很有意思的心理学理论/","content":"\n# 最近B站总是刷到一些营销号讲心理学,原本我是统统屏蔽了,但是后来又开始好奇他们讲的的心理学效应是真是假,于是我就去查了几个记忆深刻的几个\n\n\n\n## 一  : 韦斯特马克效应    (Westermarck effect)\n\n由芬兰人类学家[<font color='Red'>爱德华·韦斯特马克</font>](https://baike.baidu.com/item/爱德华·韦斯特马克/15630741?fromModule=lemma_inlink)在他的著作《The History of Human Marriage》（人类婚姻史）中提出，两个早年共同长大的儿童在成年后通常不会对彼此产生性吸引力；有血缘关系者也会存在亲缘监测机制（亲缘监测机制异常除外，血缘关系越近越明显。）来保护；无血缘关系者由于生活在一起后可不会成年后产生性吸引,出生后六年的成长环境是一个关键时间点，其间生活在一起二者性吸引几率全会大大降低。\n\n这种现象产生也是刻在人类DNA里面的,毕竟哺乳动物近亲繁殖多半后代因隐形基因发力导致先天患病或者夭折\n\n感觉没有任何毛病,所以各位哥布林们,少看点有关青梅竹马和兄妹姐弟的动漫,电视剧,漫画或者小片片吧  <font color='Gold'>狗头  狗头  狗头</font>\n\n**前提条件非常明确：**\n\n> **在幼年关键期（约 0–6 岁）长期共同生活 → 自动去性化**\n\n重点不是“血缘”，而是\n\n- 是否 **幼年长期共处**\n- 是否形成 **亲属模板**\n\n像《缘之空》里的这种德国骨科剧情不满足这种心理学效应, 而是另一个反转的对立效应----- **遗传性性吸引**\n\n## 二: 遗传性性吸引 (Genetic sexual attraction，GSA)\n\n指因遗传基因相似、长期分离的近亲成年后首次相遇时产生的本能性吸引力，常见于平辈、亲子或隔代亲属间。该现象与亲缘检测机制相悖，血缘越近吸引力越强，但共同成长的亲属因韦斯特马克效应通常不会产生性吸引 。\n\n其机制与早期亲密关系缺失相关，成年后重聚可能试图弥补情感缺失进而发展为性吸引 。1995年《英国医学心理学期刊》超50%寄养儿童与家人重聚时出现强烈性冲动。血缘相近者基因相似度高，外貌、性格等相似性易引发异性间性吸引力\n\n所以再回头看看  **春日野悠**  和  **春日野穹** 是不是满足该效应的所有条件呢-----俩苦命鸳鸯长得一模一样,小的时候俩人分居过很长时间\n\n## 三: 破窗效应 (Broken windows theory)\n\n是犯罪学的一个理论，该理论由詹姆士·威尔逊（James Q. Wilson）及乔治·凯林（George L. Kelling）提出，并刊于《The Atlantic Monthly》1982年3月版的一篇题为《Broken Windows》的文章。\n\n该理论认为如果一扇窗被打破却无人修理，人们会推断：\n这里没人管、规则不重要、越界成本很低\n\n此理论认为任何可见的混乱、忽视与犯罪的迹象，例如破窗（这也是一这一理论的名称来源）、破坏公物、乞丐、酒鬼等，可能会鼓励一个地区进一步的犯罪和反社会行为。因为以上的迹象表明，该地区的秩序已被破坏，且缺少执法\n\n这里可以用一个直观的例子----- 比如旷课只有0次和无数次  或者 一个人开始发龙图和奶龙图,整个QQ群都逐渐开始抽象起来<font color='Gold'>滑稽  滑稽  滑稽</font>\n\n## 四:  责任分担效应 (responsibility sharing)\n\n最早解释冒险转移的理论。认为群体比个体更富于冒险精神的原因是群体决策冒险的结果将由群体承担，责任将由于分散到各个成员身上而减小，因而个体减少了对失败的恐惧\n\n这种现象不能仅仅说是众人的冷酷无情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担，造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的局面。\n\n我举个例子(狗头狗头狗头):假如你的全班平均分年级倒数第一或者公司里小组业绩倒数第一  ,班主任或者你的老板把所有人都骂一遍,但是你八成觉得无所谓,反正骂的是所有人又不是你一个,但是假如就骂你一个,你八成觉得非常不爽\n\n## 五: 孤独（loneliness）\n\n这也是我正在经历的比较痛苦的一件事吧,不过手机和电脑暂时冲散了我这种感觉,感谢现代科技    <font color='Gold'>狗头 狗头 狗头</font>\n\n孤独（loneliness）在现实生活中经常被人所提及，孤独乃是一种主观上的社交孤立状态，伴有个人知觉到自己与他人隔离或缺乏接触而产生的不被接纳的痛苦体验  ,是一种不愉快的，令人痛苦的主观体验或心理感，大多数人都体验过孤独的痛苦。有关统计资料表明、孤独感已成为现代人的通病。估计随着社会变得越来越富有，这种对孤独感和人与人之间关系的关注将继续增长\n\n在青少年时期，自我意识开始觉醒并逐渐建立，产生了了解别人内心世界并被其他同龄人接受的需要。他们很关心自己在他人心目中的地位和形象，重视他人的评价。正因为这样，他们会将自己隐藏起来。一方面他们觉得自己心中有很多秘密，不愿告诉别人，有一种封闭心理；另一方面他们又特渴望别人能真正了解自己。这种需要得不到满足时，便会陷入惆怅和苦恼，产生孤独感\n\n希望我快点战胜这种感觉吧,唉,我也是越来越不会与人社交了,一天到晚只会和AI沟通游戏开发相关的知识(吐槽一下,ChatCPT就像奴才一样恭维,Gemini一用中文就降智,Deepseek服务器像土豆一样回答速度慢的离谱,Kimi就像聪明一点的浏览器的SB,豆包?我只是单纯不喜欢字节跳动的产品)\n\n毕竟是写到我们的DNA里面的,但是在现代社会,现实中的社交有的时候也不是这么重要,所以抖音 快手 小红书 B站 QQ Youtube Facebook Discord这些虚拟社交平台才会迅速火爆来打消人们的空虚寂寞感,但我觉得这些反而会加剧人与人之间的隔阂\n\n这个起源于远古时期古人类的生存法则 \n\n| 状态       | 实际含义             |\n| ---------- | -------------------- |\n| 被群体接纳 | 食物、防御、繁殖机会 |\n| 被群体忽视 | 受伤无人救           |\n| 被群体排斥 | **高概率直接死亡**   |\n\n## 六: 操作性条件反射（Operant Conditioning）\n\n亦称“工具性条件反射”。是由美国行为主义心理学家斯金纳20世纪30年代在经典条件反射的基础上创立的实验方法。他为研究动物的学习行为，采用精确的测量习得反应技术，设计了一种由动物进行操作活动的实验箱（通常称斯金纳箱），用来测定动物完成压杆或按键活动的特定反应。除了可训练大鼠，还可训练猫、家兔和猕猴等实验动物进行该项操作。可分为食物性和防御性两种形式\n\n其中 ,他还做了一个实验------在这个实验中，斯金纳用了8只鸽子作为实验对象，把它们单独放进实验箱里。当鸽子按下箱子内的遥控杆时，15秒后会掉落食物。他观察到，在这15秒钟内，鸽子会出现一些随机行为，比如逆时针转圈、摇头晃脑等等。有趣的是，有6只鸽子会在每一次食物掉落时重复这些迷信行为。\n\n接下来，斯金纳把食物掉落的时间间隔延长至1分钟，结果这些鸽子对这些行为的重复变得更加频繁。为什么会出现这种情况呢？鸽子不知道食物会延迟掉落，而是以为自己的随机行为带来了食物。每一次食物掉落，都强化了它们的这些行为。斯金纳把这种情况称为“非关联性强化”\n\n像不像玩 原神 鸣潮 崩坏 崩铁 绝区零 方舟 战双帕弥什  重返未来还有蔚蓝档案 抽卡前双手合十默默祈祷十连三金的各位兄弟们  <font color='Gold'>狗头狗头狗头</font>\n\n# 这些定理太多了,不过这是我觉得比较有意思的几个,还有其他的你们可以选择自己查或看视频了解   不过我说白了,无非这些人类情感是咱们的DNA发力了,激素调节出来的罢了 比如我放几个瑟图,刚看完看这些干巴巴的理论的你八成瞬间来精神了,你说对吧(如果你只对现实中的真人感兴趣当我没说)\n\n<img src=\"一些我感觉很有意思的心理学理论/17674089961868672.jpeg\" alt=\"3k碧蓝档案少女壁纸｜制服背景图片 - 坐姿「哲风壁纸」\"  />\n\n<img src=\"一些我感觉很有意思的心理学理论/17674090138488192.jpeg\" alt=\"8k碧蓝档案壁纸｜少女背景图片 - 学生制服「哲风壁纸」\"  />\n\n<img src=\"一些我感觉很有意思的心理学理论/16275633157426560.jpeg\" alt=\"3k碧蓝档案美少女壁纸｜可爱少女背景图片 - 碧蓝档案「哲风壁纸」\"  />\n\n<img src=\"一些我感觉很有意思的心理学理论/17327741277818240.jpeg\" alt=\"3k卡提希娅壁纸｜动漫背景图片 - 金发「哲风壁纸」\"  />\n\n<img src=\"一些我感觉很有意思的心理学理论/17674099686493568.jpeg\" alt=\"4k碧蓝档案壁纸｜银发少女背景图片 - 粉色沙发「哲风壁纸」\"  />\n\n<img src=\"一些我感觉很有意思的心理学理论/15946454747565440.jpeg\" alt=\"4k白丝壁纸-碧蓝背景图片 - 精选壁纸「哲风壁纸」\"  />","tags":["diary"],"categories":["心理学","日记"]},{"title":"04-一些思考","url":"/2026/01/02/日记相关/KoyouAsh开发日记/04-一些思考/","content":"\n# 一些个人对游戏的思考\n\n最近一直没有做游戏,开发进度几乎为零,因为我在犹豫到底该做什么类型的游戏,虽然我还是个菜鸡啥也不会\n\n一般我比较关注一些其他的开发者的进度和分享的知识,像B站和Youtube还有小黑盒以及QQ群,但是我觉得他们和我一样犯了一个根本性的错误-----比如Epic和Steam 还有 itch 偶尔会送一些游戏,然后我就像屯屯鼠一样全部领取,但是我从来没有打开过这些游戏!!! 只会挑选一些知名的或者封面和宣传片好看的玩  也就是说,免费的我都不玩,更别说付费的   太真实了 ,玩家的时间非常宝贵,所以他们更倾向于花时间玩已购买的或知名的游戏才不觉得亏  这就对游戏的标准非常高  ,而且买了也不一定玩,就拿我为例,说不定符合大多数人,我买了刺客信条全系列,看门狗全系列,战地全系列,古墓丽影全系列,四海兄弟全系列,荒野大镖客2,空洞骑士,巫师三,只狼,霍格沃兹之遗,底特律还有很多大大小小的游戏,但是很多都是玩不下去,真正玩下去的只有米塔,师父,星露谷,小丑牌,九日还有看门狗1以及最经典的我的世界,同样的我也会玩一些网游比如原神,崩铁,重返未来1999,鸣潮,燕云十六州,使命召唤,蔚蓝档案等等,大多数基本上都玩过,但是吧,这些游戏就像套壳子一样,玩多了不想玩了,游戏公司自然也知道这一点,所以经常出新角色搞活动和签到试图留住玩家,但是该来的还会来该走的还是会走,我身边玩二游的基本上全退坑玩三角洲行动还有瓦罗兰特  这就比较有意思,相当于从一个相对孤立的玩法转向一大群人的集合玩法来抵抗无聊感\n\n\n\n站在开发者的角度来看的话,这些游戏以及成百上千的独立游戏是非常非常优秀的,无论是画风,建模,动画,音乐,剧情,代码设计,战斗逻辑还是关卡设计,但是站在玩家玩家角度只有两个形容词-----无聊和有趣 ,这种感觉和你的游戏是否拥有极高的美术或者丰富的剧情和奇特的玩法无关,比如,我玩原神或者刺客信条奥德赛都会感觉一点,哇,地图好好看,人物好精美,玩法好奇特,但是玩多了就想吐,看都不会看两眼,这就是我们常常说的审美疲劳        \n\n\n\n为什么审美疲劳会产生呢,我举个例子,站在玩家的角度来看,其实原神的玩法和鸣潮一模一样,绝区零和战双帕弥什以及尘白禁区玩法大差不差,重返未来和蔚蓝档案还有碧蓝档案本质上没有区别,明日方舟还有保卫萝卜以及植物大战僵尸其实差不多,所有射击类网游玩法一模一样,国外的大游戏一般会偏写实风因为写实风就是3A的标准,但是黑神话悟空,巫师三,只狼,以及荒野大镖客等等就不一一列举了,其实都在努力摆脱像育碧游戏类似的罐头味  说白了就是平时顿顿饱,就不会期待过年了,当所有的游戏都一样优秀的时候,就相当于没什么区别,提一嘴之前去好几个博物馆,看到了很多古董,但是大概转了一大圈看了几百个这种古董后,感慨这不就是古代人的垃圾吗,镇馆之宝和普通瓦片当都放到橱窗里贡着在观赏者看来就没有任何区别,但对于考古学家来说就是各有千秋\n\n\n\n也就是说对于独游开发者如果是想要赚钱的话要么就是需要避免与市面上所有同类型游戏高度生态位重合,要么就是像很多游戏人家是用成千上万的投资砸出来的作品和知名度   而且好玩的游戏千篇一律,有趣的灵魂万里挑一,个别游戏根本无法比拟比如我的世界和星露谷,我看很多作者喜欢模仿制作一些2D横版游戏或者那种类似于微信小游戏的竖屏游戏,因为这类游戏制作起来相对简单低成本,横版游戏这种比如类似最经典的空洞骑士类银河恶魔城还有星露谷这样的2.5D俯视角甚至是八方旅人这种直接3D塞2D类型,在steam Epic itch 还有4399甚至是应用市场上基本上30%~50%左右是这种类型吧,说真的,没有人会花时间去区分高度相似的花朵,大家只会第一眼找出颜色最奇特的一朵,于是很多花就去模仿复制这一朵,结果就是又会回到刚开始高度相似的状态,然后又会诞生出新的异色花朵,一直循环下去\n\n\n\n想了很多额我决定推翻之前90%的游戏初步设计,因为我反复站在玩家的角度都觉得我设计的玩法和美术无聊透顶而且和别人的高度相似,属于看一眼就划过去的类型,独立游戏应该激发玩家的好奇心而不是那种开场音乐一响界面一出现就知道怎么玩的类型,但是比如空洞骑士还有小丑牌这些,几乎不会明确的教你怎么玩,全靠玩家自己探索,用自己的行为改变世界或机制,剧情类游戏比如galgame视觉小说或者底特律 荒野大镖客这种差不多相当于在看书看电影,大家都知道本质上不是纯粹的游戏,而是前几种艺术比如文学或者电影的可视化可交互化的表现形式,所以需要慎重考虑,或者说需要巧妙的结合\n\n\n\n还有人类是看脸的生物,看游戏更是如此,相比那些粗糙至极的游戏,咱们会更倾向于第一眼插画精美,特效丰富,UI美观,有大量过场动画或者甚至可以联机的游戏你说对吧,这样才会甘愿花费时间或者金钱来游玩这个游戏\n\n\n\n好吧,不想那么多了,总之我认为开发者不应该一直执拗于某一个想法,而是要反过来多多站在玩家的视角来看问题,模仿不能带来创新,只是玩法的排列组合  而多看看一些独立游戏和买断制小游戏感觉反而比学习大型游戏更有性价比,因为独游开发者的游戏一般只专注于游戏内容本身而不是那些其他乱七八糟的东西,而且他们为了能让游戏能卖出去一般会花很多精力和心血\n\n\n\n不过很多时候看到,steam上那些新上架游戏几乎没有人玩挺可惜的,他们确实付出了很多但是没有回报,换谁谁都难受,尤其是一些怀揣着游戏制作梦的开发者,上架需要100美元基本上都打水漂了,现在是明白为什么大多数开发者只会上架一次他们的游戏了,因为这是一个很亏本的事情,有这钱还不如吃点好的玩点好的\n\n# 好了,废话说完了,忘记我只是个菜鸡而不是游戏策划了\n\n对了,之前听说很多开发者会加密自己的游戏,我觉得这个对于独游开发者完全没有必要,大型游戏人家是怕投资打水漂才搞什么D加密什么的,今天用AssetRipper  提取一个很好玩的Unity小游戏里的资源时发现不想往常一样立刻破解出来,这个游戏只有单个exe文件,当时我误以为加密了,用一大堆反编译工具解包都失败了,结果准备删除时不小心点到“解压文件”结果就解压出了这个游戏的所有资源,当时觉得不可思议,最后发现作者压根没加密,只是把所有文件二次打包成exe文件,就和 用love2d引擎做的游戏一样,比如小丑牌就是点击exe右键解压就可以得到所有游戏资源\n\n这也给我了一个很好的启发,只要不透漏这个游戏是什么引擎制作的,然后用这种类似的打包方式,既可以方便玩家下载和游玩,又可以误导那些试图破解游戏的人让他们花费更多的时间来寻找打开这个游戏的源码的方式  这大概就是游戏最简单的加密方式吧\n\n# 站在前人的肩膀才是进步最快的方式也是最短的捷径\n\n开始的时候我只想自己摸索,自己用AI自己解决问题自己设计,结果发现只不过是在用最低效的方法重复造轮子\n\n刚开始自己觉得自己很厉害,比身边的人都强,在见到很多独游大佬的实力后觉得,我就是个菜鸡,我什么都不会,只会用最蠢的方法干最蠢的事,他们反而提供了更系统化的设计和更先进的想法,我只会把简单问题复杂化\n\n再也不会去独自钻研了,没有任何意义,很多人已经绞尽脑汁为我们做了这些事,而我却只知道一条路走到黑,唉\n\n反正我才19  有的是时间去试错   就算错了也不会产生太大的影响  \n\n我去,搞得我有点像魔丸了   笑死我了 但是也是认识到自己的不足了 傲慢不会带来进步  只会带来无知和愚昧  \n\n不喜欢文言文 但是古人的智慧 还是很有道理的-------独学而无友终孤陋而寡闻\n\n","tags":["KoyouAsh","Unity"],"categories":["游戏开发"]},{"title":"数据结构第三天----线性表和顺序表的学习","url":"/2025/12/25/数据结构相关/02-表/顺序表/","content":"\n\n\n# 我们终于可以学习第一个数据结构的知识了！首先先了解线性表的概念\n\n定义：\n\n> **线性表**是由**零个或多个相同类型的元素**组成的**有限序列**。每个元素在表中都有一个前驱元素（除第一个元素外）和后继元素（除最后一个元素外）\n\n## **线性表的两种常见实现方式：**\n\n- **顺序表（数组）**\n- **链表（链式结构）**\n\n由定义可知由n(n>=0)个数据特性相同的元素构成的有限序列,称为<font color='Red'>线性表</font>，即线性表是n个数据元素的有限序列,其中n个数据是相同数据类型的\n\n线性表中元素个数  n(n>=0) 定义为线性表的<font color='Red'>长度</font>，当n等于零时称之为<font color='Red'>空表</font>\n\n对于非空的线性表或线性结构,其特点是:\n\n\n\n- > 存在唯一的一个被称作\"第一个\"的数据元素  并且  存在唯一的一个被称作\"最后一个\"的数据元素除第一个元素外,\n  >\n  > \n  >\n  > 结构中的每个数据元素均只有一个前驱(即前一个元素)   以及  除最后一个元素外,结构中的每个数据元素均只有一个后驱(即后一个元素)\n\n\n\n这个我们先讲顺序表\n\n## 顺序表\n\n> **顺序表**（即**数组**）是一种**线性表**的数据结构，它包含一组相同类型的数据元素，这些元素按顺序存储在连续的内存空间中。每个元素在顺序表中的位置是固定的，可以通过索引（下标）直接访问\n\n由定义可以知道 , 我们前几篇中回顾的struct结构体不是顺序表,而是一个容器,因为结构体中的元素是无序的,而像数组这样每个索引元素的位置是固定的\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct book{\n\tint isbn;\n\tchar bookName[20];\n\tdouble price;\n};\n\nint main(){\n\tstruct book b;\n\tb.isbn=767645;\n\tstrcpy(b.bookName,\"Dune\");\n\tb.price=70;\n\treturn 0;\n}\n```\n\n可以看出访问结构体成员没有顺序\n\n\n\n### 顺序表的特点\n\n- **元素类型必须相同**。所有元素都必须是同一种数据类型（例如，都为 `int`，`float` 等）\n- **元素按顺序存储**，每个元素都有一个确定的位置，可以通过下标访问\n- **可以是静态的（如固定大小数组）**或动态的（如通过动态内存分配的数组）\n\n\n\n以下所有功能我都会封装在函数里,3个语言都是,你们在main函数里修改一下即可\n\n什么 你问我为啥另外两种语言 用lua 和 C# 而不是  Java 和 C++ ?  emmm ,  当然是我现在正在学习Unity  和 Love2d做游戏,而这两个游戏引擎分别使用C# 和 Lua写脚本 (毕竟我想把学到的东西快速投入到实践中,只是目前还不知道数据结构有什么用  <font color='Gold'>狗头狗头狗头</font>)\n\n### 顺序表的初始化\n\n#### C版本\n\n```C\n#include <stdio.h>\n#define MAXSIZE 100\t//设置最大值防止数组越界\n\n//定义表元素类型位整型\ntypedef int ElemType;\n\n//构造结构体(或者说对象)\ntypedef struct{\n\tElemType data[MAXSIZE];\n\tint length;\n}SeqList;\n\n//初始化表的长度为0的函数\nvoid initList(SeqList*L){\n    //-> 是 C/C++ 的“通过指针访问结构体/类成员”的运算符\n    //L 是指向 SeqList 的指针,L->length = 0; 等价于 (*L).length = 0;  如果是普通对象而非指针,用点号：list.length = 0;\n\tL->length=0;\n}\n\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n\tprintf(\"初始化成功,目前长度占用%d\\n\",list.length);\n\tprintf(\"目前占用内存%zu字节\\n\",sizeof(list.data));\n\treturn 0;\n\t\n}\n```\n\n\n\n#### Lua版本\n\n用lua表示就是如下\n\nlua因为比较自由没有太多的限制\n\n```lua\nlocal SeqList = {}\nSeqList.__index = SeqList\n\n--构造函数\nfunction SeqList:new()\n    local instance = setmetatable({}, SeqList)\n    instance:initList()\n    return instance\nend\n\n--初始化\nfunction SeqList:initList()\n    self.data = {}\nend\n\n--获取顺序表长度\nfunction SeqList:getLength()\n    return #self.data\nend\n\nlocal function main()\n    local list = SeqList:new()\n    -- 也直接用 #list.data 获取长度\n    print(string.format(\"初始化成功, 目前长度占用:\" .. list:getLength()))\nend\n\nmain()\n```\n\n\n\n#### C#版本\n\n在C#里我们可以用面向对象的思想来实现顺序表的初始化,在C#里 List  类似于C里面的数组\n\n```c#\n// 定义 ElemType 为 int 类型\nusing ElemType = System.Int32;\n\n//定义顺序表类\npublic class SeqList\n{\n    public List<ElemType> data = new List<ElemType>();// 存储顺序表元素的动态数组\n    public int length// 顺序表当前长度\n    {\n        get { return data.Count; }\n    }\n\n    //之所以构造函数,是因为实例化时会自动调用构造函数\n    public SeqList()\n    {\n        initList();\n    }\n\n    // 初始化函数\n    public void initList()\n    {\n        data = new List<ElemType>();\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n\n        SeqList list = new SeqList();// 创建顺序表实例\n\n        Console.WriteLine($\"初始化成功,目前长度占用{list.length}\");\n\n        // C# 是托管内存，无法像 C 一样用 sizeof(list.data) 这种方式看预分配的字节大小\n        // Capacity 属性可以看到底层数组当前分配的容量（个数，不是字节）\n        Console.WriteLine($\"目前内部数组容量(Capacity): {list.data.Capacity}\");\n    }\n}\n```\n\n​\t\n\n### 顺序表的尾插法\n\n#### C版本\n\n```c\n//尾部添加元素\nint appendElem(SeqList*L,ElemType e){\n    //先判断表长度是否超过规定值\n\tif(L->length>=MAXSIZE){\n\t\tprintf(\"顺序表已满\\n\");\n\t\treturn 0;\n\t}\n \n\tL->data[L->length]=e;//C语言数组索引从0开始,data[length]处刚好是尾部可添加的位置,而data[length-1]才是末尾的位置\n\tL->length++;//添加后把长度自动增加一下\n\treturn 1;\n}\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n\tprintf(\"初始化成功,目前长度占用%d\\n\",list.length);\n\tprintf(\"目前占用内存%zu字节\\n\",sizeof(list.data));\n\tappendElem(&list,88);\n\treturn 0;\n\t\n}\n```\n\n#### Lua版本\n\n```lua\n--插入元素\nfunction SeqList:appendElem(e)\n    table.insert(self.data, e)\n    return 1\nend\n\nlocal function main()\n    local list = SeqList:new()\n\n    -- 直接用 #list.data 获取长度\n    print(string.format(\"初始化成功, 目前长度占用:\" .. list:getLength()))\n\n    -- 添加元素\n    list:appendElem(88)\n    list:appendElem(100)\n\n    -- 再次查看长度\n    print(string.format(\"目前长度占用:\" .. list:getLength()))\n\n    -- 验证一下数据\n    print(string.format(\"第一个元素: %d, 第二个元素: %d\", list.data[1], list.data[2]))\nend\n\nmain()\n```\n\n#### C#版本\n\n```c#\n//定义顺序表类\npublic class SeqList\n{\n   //添加元素\n    public int appendElem(int e)\n    {\n        //使用Add\n        data.Add(e);\n        return 1;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n\n        SeqList list = new SeqList();// 创建顺序表实例\n\n        Console.WriteLine($\"初始化成功,目前长度占用{list.length}\");\n\n        list.appendElem(88);\n        Console.WriteLine($\"目前长度占用: {list.length}\");\n    }\n}\n```\n\n### 顺序表的遍历\n\n#### C版本\n\n```c\n//遍历\nvoid listElem(SeqList *L){\n\tfor(int i=0;i<L->length;i++){\n\t\tprintf(\"%d \",L->data[i]);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n\tprintf(\"初始化成功,目前长度占用%d\\n\",list.length);\n\tprintf(\"目前占用内存%zu字节\\n\",sizeof(list.data));\n\tappendElem(&list,88);\n\tappendElem(&list,45);\n\tappendElem(&list,43);\n\tappendElem(&list,17);\n\tlistElem(&list);\n\t\n\treturn 0;\n}\n```\n\n#### Lua版本\n\n```lua\n--遍历 \nfunction SeqList:listElem()\n    -- ipairs 自动遍历数组部分的 index 和 value(不推荐,这种方法和C#里的foreach差不多)\n    for v in ipairs(self.data) do\n        io.write(v .. \"\\n\")\n    end\n    --或者(推荐,lua自带的遍历表函数)\n    print(table.concat(self.data, \"\\n\"))\nend\n\nlocal function main()\n    local list = SeqList:new()\n\n    -- 添加元素\n    list:appendElem(88)\n    list:appendElem(100)\n\n    -- 遍历顺序表\n    print(\"顺序表元素如下:\")\n    list:listElem()\nend\n\nmain()\n```\n\n#### C#版本\n\n```c#\n//定义顺序表类\npublic class SeqList\n{\n    //遍历 \n    public void listElem()\n    {\n        //第一种 foreach遍历\n        foreach (var item in data)\n        {\n            Console.WriteLine(item);\n        }\n        \n        //或者使用 string.Join\n    \tConsole.WriteLine(string.Join(\"\\n\", data));\n    }\n    \n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n\n        SeqList list = new SeqList();// 创建顺序表实例\n\n        list.appendElem(23);\n        list.appendElem(45);\n        list.appendElem(88);\n        Console.WriteLine(\"顺序表的元素有:\");\n        list.listElem();// 遍历顺序表\n    }\n}\n```\n\n### 顺序表的删除\n\n#### C版本\n\n```c\n//删除\n//pos=position  即删除位置\nint deleteElem(SeqList*L,int pos,ElemType*e){\n\tif(L->length==0){\n\t\tprintf(\"空表\\n\");\n\t\treturn 0;\n\t}\n\tif(pos<1||pos>L->length){\n\t\tprintf(\"删除数据位置有误\\n\");\n\t\treturn 0;\n\t}\n\t\n\t*e=L->data[pos-1];\n\tif(pos<L->length){\n\t\tfor(int i=pos;i<L->length;i++){\n\t\t\tL->data[i-1]=L->data[i];\n\t\t}\n\t}\n\tL->length--;\n\treturn 1;\n}\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n\tappendElem(&list,88);\n\tappendElem(&list,45);\n\tappendElem(&list,43);\n\tappendElem(&list,17);\n\tlistElem(&list);\n\t\n\tElemType delData;\n\tdeleteElem(&list,2,&delData);\n\tprintf(\"被删除的数据为:%d\\n\",delData);\n\tlistElem(&list);\n\t\n\treturn 0;\n}\n```\n\n#### Lua版本\n\n```lua\n--删除元素\nfunction SeqList:deleteElem(pos)\n    if #self.data == 0 then\n        print(\"空表\")\n        return nil\n    end\n    if pos < 1 or pos > #self.data then\n        print(\"删除数据位置有误\")\n        return nil\n    end\n\n    -- table.remove 会移除指定位置元素,并自动前移后续元素\n    -- 它直接返回被移除的值\n    local e = table.remove(self.data, pos)\n    return e\nend\n\nlocal function main()\n    local list = SeqList:new()\n\n    -- 添加元素\n    list:appendElem(88)\n    list:appendElem(100)\n\n    -- 遍历顺序表\n    print(\"顺序表元素如下:\")\n    list:listElem()\n\n    -- 删除(第一种,查看被删除的是谁)\n    local delData = list:deleteElem(2)\n    print(\"删除第2个位置的数据后,被删除的数据为:\" .. delData)\n    list:listElem()\n\n    --删除(第二种,不需要看)\n    list:deleteElem(2)\n    print(\"删除第2个位置的数据后,顺序表元素如下:\")\n    list:listElem()\nend\n\nmain()\n```\n\n#### C#版本\n\n```c#\n//定义顺序表类\npublic class SeqList\n{\n     //删除\n    public int deleteElem(int pos, out ElemType e)\n    {\n        e = 0; // out 参数必须赋值\n\n        if (length == 0)\n        {\n            Console.WriteLine(\"空表\");\n            return 0;\n        }\n        if (pos < 1 || pos > length)\n        {\n            Console.WriteLine(\"删除数据位置有误\");\n            return 0;\n        }\n\n        // 取出要删除的元素\n        e = data[pos - 1];\n\n        //直接调用 List.RemoveAt,底层自动处理移位\n        data.RemoveAt(pos - 1);\n\n        return 1;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n\n        SeqList list = new SeqList();// 创建顺序表实例\n\n        list.appendElem(23);\n        list.appendElem(45);\n        list.appendElem(88);\n        Console.WriteLine(\"顺序表的元素有:\");\n        list.listElem();// 遍历顺序表\n\n        ElemType deletedElem;//模拟C版本的可以查看删除的是什么\n        list.deleteElem(2, out deletedElem);\n        list.listElem();// 遍历顺序表\n        Console.WriteLine(\"被删除的元素是:\" + deletedElem);\n    }\n}\n```\n\n### 顺序表的指定位置插入\n\n#### C版本\n\n```c\n//指定位置插入\nint insertElem(SeqList*L,int pos,ElemType e){\n\tif(L->length>=MAXSIZE){\n\t\tprintf(\"表已经满了\\n\");\n\t\treturn 0;\n\t}\n\tif(pos<1||pos>L->length){\n\t\tprintf(\"插入位置错误\\n\");\n\t\treturn 0;\n\t}\n\tif(pos<=L->length){\n\t\tfor(int i=L->length-1;i>=pos-1;i--){\n\t\t\tL->data[i+1]=L->data[i];\n\t\t}\n\t\tL->data[pos-1]=e;\n\t\tL->length++;\n\t}\n\treturn 1;\n}\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n\tprintf(\"初始化成功,目前长度占用%d\\n\",list.length);\n\tprintf(\"目前占用内存%zu字节\\n\",sizeof(list.data));\n\tappendElem(&list,88);\n\tappendElem(&list,45);\n\tappendElem(&list,43);\n\tappendElem(&list,17);\n\tlistElem(&list);\n\tinsertElem(&list,2,18);\n\tlistElem(&list);\n\t\n\treturn 0;\n}\n```\n\n### 顺序表的查找\n\n#### C版本\n\n```c\n//查找\nint findElem(SeqList*L,ElemType e){\n\tif(L->length==0){\n\t\tprintf(\"空列表\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<L->length;i++){\n\t\tif(L->data[i]==e){\n\t\t\treturn i+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\t//声明一个顺序表并初始化\n\tSeqList list;\n\tinitList(&list);\n    \n\tappendElem(&list,88);\n\tappendElem(&list,45);\n\tappendElem(&list,43);\n\tappendElem(&list,17);\n\tlistElem(&list);\n\t\n\tinsertElem(&list,2,18);\n\tlistElem(&list);\n    \n    int number=1;\n\tprintf(\"找到%d位置的数据值为%d\",number,findElem(&list,number));\n\t\n\treturn 0;\n}\n```\n\n\n\n### 顺序表的动态分配内存并初始化\n\n#### C版本\n\n```c\n//动态分配内存地址初始化\nSeqList* initList(){\n\tSeqList*L=(SeqList*)malloc(sizeof(SeqList));\n\tL->data =(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);\n\tL->length=0;\n\treturn L;\n}\n\nint main(){\n\t//声明一个线性表并初始化\n\tSeqList *list=initList();\n\n\tappendElem(list,88);\n\tappendElem(list,45);\n\tappendElem(list,43);\n\tappendElem(list,17);\n\tlistElem(list);\n\t\n\tinsertElem(list,2,18);\n\tlistElem(list);\n\t\n\tprintf(\"%d\\n\",findElem(list,40));\t\n\treturn 0;\n}\n```\n\n暂时没有精力去兼顾lua和C#版本的吧,毕竟快考试了,以后我再慢慢补票吧\n","tags":["Data Structure"],"categories":["数据结构"]},{"title":"数据结构第二天----时间复杂度和空间复杂度还有抽象数据类型","url":"/2025/12/25/数据结构相关/01-数据表结构前置知识/复杂度/","content":"\n# OK,在我们学习数据结构之前我们来先了解一个概念-------时间复杂度和空间复杂度还有抽象数据类型\n\n# 开发者请注意,如果不感兴趣请不要看本篇文章,因为这都是理论性质的东西,只适合那些考试党\n\n## 时间复杂度\n\n时间复杂度,也称渐进时间复杂度,T(n)=O(f(n))\n\n<img src=\"复杂度/image-20251225233723152.png\" alt=\"image-20251225233723152\" style=\"zoom: 50%;\" />\n\n随着问题规模n的增大,算法执行时间和增长率和f(n)增长率成正比\n\n说人话就是:\n\n> 时间复杂度 = 干活要花多少“时间”\n\n举个例子\n\n劳埃德给阿尼亚买了很多花生零食并嘱咐阿尼亚一次只能吃一袋,但是阿尼亚会选择吃完后继续偷吃,可不可以吃完一袋花生取决于阿尼亚酱的咀嚼速度,假如阿尼亚每次吃一个花生的速度和吞一整袋花生的速度一样,则称之为时间复杂度低,但是如果阿尼亚嘴里每增加一个花生,导致咀嚼的速度下降,结果直到黄昏回家被发现了也没吃完,这就是时间复杂度高\n\n**低复杂度 O(1)：**\n\"无论劳埃德买1袋还是10袋花生，阿尼亚狂风吸入，所以黄昏回家前一定不被发现\"\n\n**高复杂度 O(n²)：**\n\"阿尼亚嘴里每多塞一颗1颗，咀嚼速度就慢一半，结果吃到第10颗时，单颗就要嚼好几分钟, 完了 ,那个间谍老爹回家了,来不及藏花生包装袋了 !!!\"\n\n​\t<img src=\"复杂度/89666b4afecbfd3fc9b8c70dfcdcc1f1.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n\n\n我们可以用一个图来描述\n\n​\t<img src=\"复杂度/image-20251225105702011.png\" alt=\"image-20251225105702011\" style=\"zoom: 50%;\" />\n\n当然我们也可以用一些题目来解释,这样更直观\n\n```c\n//计算频率\n//for(int i=1;i<=n;i++){//频率为n+1\n//\tfor(int j=1;j<=n;j++){//频率为n*(n+1)\n//\t\tc[i][j]=0;//频率为n*n\n//\t\tfor(int k=1;k<=n;k++){//频率为n*n*(n+1)\n//\t\t\tc[i][j]=c[i][j]+a[i][k]+b[k][j];//频率为n*n*n\n//\t\t}\n//\t}\n//}\n//f(n)=n+1+n*(n+1)+n*n+n*n*(n+1)+n*n*n\n//即f(n)=2*n*n*n+3*n*n+2n+1  则T(n)=O(n[3])\n```\n\n以下公式用a()括起来的表示排序数字,用n[]括起来的表示次幂\n若f(n)=a(m)n[m]+a(m-1)n[m-1]+....+a(1)n+a(0)  是一个m次多项式\n则T(n)=O(n[m])在计算算法时间复杂度时,可以忽略所有低次幂和最高次幂的系数\n这样可以简化算法分析也体现出增长率的含义\n\n<img src=\"复杂度/image-20251225233758454.png\" alt=\"image-20251225233758454\" style=\"zoom:80%;\" />\n\n根据时间复杂度可以分为如下几种(虽然没什么鸟用)\n\n- 最好时间复杂度:算法在最好情况下的时间复杂度\n- 最坏时间复杂度:算法在最坏情况下的时间复杂度\n- 平均时间复杂度:算法在所有可能的情况下,按照输入实例乙等概率出现时,算法计量的加权平均值对算法时间复杂度的度量,通常只讨论算法在最坏情况下的时间复杂度,即分析在最坏情况下算法执行时间的上界\n\n\n\n实际上如果算法执行时间,不随问题n的增长而增长,那么算法当中的语句频率就是某个常数,比如 1\n\n```c\n//例如:\n//x++;\n//s=0;\n//f(n)=1+1=2\n//T(n)=O(1)\n\n//例如:\n//for(int i=0;i<10000;i++){\n//\tx++;\n//\ts=0;\n//}\n//T(n)=O(1)\n```\n\n如果随着问题n的增长而增长的话就是n次幂或者n的对数阶层什么的\n\n```c\n//例如:\n//for(int i=0;i<n;i++){\n//\tx++;\n//\ts=0;\n//}\n//f(n)=(n+1)+n+n=3n+1\n//T(n)=O(n)\n\n//例如:\n//x=0;\n//y=0;\n//for(int k=0;k<=n;k++){\n//\tx++;\n//}\n//for(int i=1;i<=n;i++){\n//\tfor(int j=1;j<=n;j++){\n//\t\ty++;\n//\t}\n//}\n//f(n)=1+1+(n+1)+n+(n+1)+n(n+1)+n*n=2*n*n+4n+4\n//T(n)=O(n[2])\n\n\n//例如:\n//x=1;   //1\n//for(int i=1;i<=n;i++){\t//n\n//\t\n//\tfor(int j=1;j<=i;j++){\t// n(n+1)/2\n//\t\t\n//\t\tfor(int k=0;k<=j;k++){\t//[n(n+1)(n+2)]/6\n//\t\t\tx++;\n//\t\t}\n//\t}\n//}\n//T(n)=O(n[3])\n\n\n//例如:\n//for(int i=1;i<=n;i=i*2){\n//\tx++;\n//\ts=0;\n//}\n//x循环次数为2[t-1]\n//2[t-1]>n\n//log(2)2[t-1]>log(2)n\n//t-1>log(2)n\n//t>log(2)n+1\n//T(n)=log(2)n+1=O(log(2)n)\n```\n\n​\t<img src=\"复杂度/计算时间复杂度-01-17666330738123.jpg\" alt=\"计算时间复杂度-01\" style=\"zoom:33%;\" />\n\n这里还有有一些没什么实际用途的题目\n\n```c\n//例如:设n是描述问题规模的非负整数,下面程序片段的时间复杂度是__A__。\n//x=2;\n//while(x<n/2)\n//\t\tx=2*x;\n//\n//A.O(log(2)n)   B.O(n)   C.O(nlog(2)n)\t  D.O(n[2])\n//x的循环次数为2[t+1]\n//2[t+1]=n/2\n//2[t+2]=n\n//log(2)2[t+2]=log(2)n\n//t+2=log(2)n\n//T(n)=log(2)n-2=O(log(2)n)\n```\n\n​\t\n\n\n\n​\t<img src=\"复杂度/计算时间复杂度-02.jpg\" alt=\"计算时间复杂度-02\" style=\"zoom:33%;\" />\n\n```c\n//例如:下列函数的时间复杂度是\n//int fun(int n){\n//\tint i=0,sum=0;\n//\twhile(sum<n){\n//\t\tsum += ++i;\n//\t\treturn i;\n//\t}\n//}\n//A.O(logn)   B.O(n[1/2])   C.O(n)   D.O(nlogn)\n//\n//t(t+1)/2=n\n//t(t+1)=2n\n//t[2]+t=2n\n//t[2]=2n\n//t=(2n)[1/2]\n//T(n)=O(n[1/2])=O(n[1/2])\n```\n\n​\t<img src=\"复杂度/计算时间复杂度-03.jpg\" alt=\"计算时间复杂度-03\" style=\"zoom:33%;\" />\n\n```c\n//例如:设n是描述问题规模的非负整数,下列程序的时间复杂度是__B__\n//x=0;\n//while(n>=(x+1)(x+1))\n//\t\tx=x+1;\n//A.O(logn)   B.O(n[1/2])   C.O(n)   D.O(n[2])\n//n<(x+1)[2]\n//n[1/2]<x+1\n//n[1/2]-1<x\n//T(n)=O(n[1/2])=O(n[1/2])\n```\n\n <img src=\"复杂度/计算时间复杂度-04.jpg\" alt=\"计算时间复杂度-04\" style=\"zoom:33%;\" />\n\n```c\n//例如:下列程序的时间复杂度是__B__\n//int sum=0;\n//for(int i=1;i<n;i*=2){\n//\tfor(int j=1;j<i;j++){\n//\t\tsum++;\n//\t}\n//}\n//A.O(logn)   B.O(n)   C.O(nlogn)   D.O(n[2])\n//外层循环\n//2[t-1]=n\n//log(2)2[t-1]=log(2)n\n//t-1=log(2)n\n//t=log(2)n+1\n//内层循环\n//1+2+4+....+2[t-1]\n//=1+2+4+....+2[log(2[n+1-1])]\n//=1+2+4+....+2[log(2[n])]\n//=1*(1-2[log(2[n])])/(1-2)\n//=n-1\n//T(n)=n-1=O(n)\n```\n\n\n\n## 空间复杂度\n\n空间复杂度主要用来描述某个算法对应的程序想在计算机上执行,除了用来存储代码和输入数据的内存空间外,还需要额外的空间\n\n说白了就是  空间复杂度 就是占多少“地方 / 内存” \n\n翻译成  人话就是:\n\n> 空间复杂度 = 为了做这件事，你额外用了多少“盒子 / 本子 / 内存”\n\n公式就是\n\n​\t<img src=\"复杂度/image-20251225233822668.png\" alt=\"image-20251225233822668\" style=\"zoom:80%;\" />\n\n\n## 抽象数据类型ADT(Abstract Data Type)\n\n定义如下:\n\n> ADT是一种编程概念,用于定义数据的类型及其操作,而不涉及具体实现细节。\n> 它提供了一种将数据的逻辑表示与物理实现分离的方法,从而使程序更具可维护性和可扩展性\n> 在C语言中,ADT通常通过结构体和函数的结合来实现。结构体用于定义数据的类型，而函数用于操作这些数据。\n> 通过这种方式，程序员可以隐藏数据的内部结构，仅暴露出操作数据的接口。\n\n如果在Unity中用过接口的小伙伴一定老熟悉这玩意了-----即抽象\n\n例如把要实现个功能封装到类中,外界只需要使用这个命名空间里的类的的方法即可\n\n虽然很多人表示抽象会降低代码的质量,但是在很多框架里抽象是离不开的\n\n这里我们举一个例子------比如设计一个计算复数的功能并封装到函数里\n\n <img src=\"复杂度/ADT.jpg\" alt=\"ADT\" style=\"zoom:50%;\" />\n\n不过这个本质上只是一种设计概念,开发中用的比较多,我们这里只是讲数据结构就不说了","tags":["Data Structure"],"categories":["数据结构"]},{"title":"数据结构第一天----学习数据结构前置内容","url":"/2025/12/25/数据结构相关/01-数据表结构前置知识/数据结构前置知识/","content":"\n# 大家好呀,最近学校要考数据结构,虽然我们在日常游戏开发或者其他软件开发中几乎用不到太多数据结构的知识用到也是多叉树 , A*  , 深度优先,  广度优先什么的(但是这些东西很多人已经为我们提前做过准备好了),不过技多不压身如是说也     ; =_= ;\n\n\n\n## 这里也是我一直在看的B站的一个老师的视频,也就是说,这些文章其实是我的笔记  <font color='Gold'>狗头</font>\n\n## 数据结构和算法的定义\n\n定义如下:\n\n<font color='Red'>数据结构</font>是一种存储,组织数据的方式,旨在便于访问和修改.\n没有一种单一的数据结构对所有用途均有效,所以需要知道几种 数据结构优势和局限\n\n<font color='Red'>算法</font>是一个有穷规则的集合,它用规则规定了解某一特定类型问题的运算序列,\n或者规定了任务执行或问题求解的一系列步骤 \n\n数据结构和算法属于相互依存的关系,数据结构是算法的**基础**，算法是数据结构的**应用**\n\n我们就回顾一下C语言学过的知识吧,但是以后不一定会只用C语言实现,还会用到其他语言\n\n## 函数\n\n```c\n//函数\n//可以实现某个具体功能的代码块\n//增加代码的复用性\n//降低编程难度\n//函数不被调用是不会执行的\n//对内隐藏细节,对外暴露接口\n\n//<返回值类型|void>函数名([参数列表]){\n//\t//函数体\n//\t[return 返回值] \n//}\n```\n\n这个不多说了,想必大家炉火纯青,什么有参函数无参函数,嗯,全都是最基本的东西\n\n## C语言中的字符串\n\n字符串基础知识点\n\n> 一,字符串末尾有反斜杠0即 '\\0',即在C语言中用字符型数组来表示字符串 \n> 二,如果直接对字符型数组赋值字符串是不能的,字符串是不能直接赋值的,需要用<font color='Turquoise'>strcpy</font> 函数来实现,同时加上<font color='Turquoise'>#include<stdlib.h></font>头文件\n\n```c\n#include <stdio.h>\n#include <string.h>  // 需要包含此头文件使用strcpy等函数\n#include <stdlib.h>  // 需要包含此头文件使用malloc\n\nint main() {\n\t// 方法1：初始化时直接赋值（最简单安全）\n\tchar str1[] = \"Hello World\";\n\tprintf(\"方法1: %s\\n\", str1);\n\t\n\t// 方法2：使用strcpy函数（常用方法）\n\tchar str2[20];  // 确保数组足够大\n\tstrcpy(str2, \"C Programming\");\n\tprintf(\"方法2: %s\\n\", str2);\n\t\n\t// 方法3：使用strncpy函数（更安全，防止溢出）\n\tchar str3[10];\n\tstrncpy(str3, \"Safe Copy\", sizeof(str3) - 1);\n\tstr3[sizeof(str3) - 1] = '\\0';  // 确保字符串结束\n\tprintf(\"方法3: %s\\n\", str3);\n\t\n\t// 方法4：字符指针指向字符串常量\n\tchar *str4 = \"Pointer String\";\n\tprintf(\"方法4: %s\\n\", str4);\n\t// 注意：str4指向的是常量，不能修改：str4[0] = 'A'; // 错误！\n\t\n\t// 方法5：逐个字符赋值\n\tchar str5[6];\n\tstr5[0] = 'H';\n\tstr5[1] = 'i';\n\tstr5[2] = '\\0';  // 千万别忘记字符串结尾符\n\tprintf(\"方法5: %s\\n\", str5);\n\t\n\t// 方法6：动态分配内存后赋值\n\tchar *str6 = malloc(20 * sizeof(char));\n\tif (str6 != NULL) {\n\t\tstrcpy(str6, \"Dynamic Memory\");\n\t\tprintf(\"方法6: %s\\n\", str6);\n\t\tfree(str6);  // 使用完必须释放内存\n\t}\n\t\n\treturn 0;\n}\n```\n\n## 虚拟内存地址\n\n内存条,显卡,各种适配卡都有其各自的存储地址空间\n操作系统将这些设备的存储地址空间抽象成一个巨大的一维数组空间 \n对于内存的每一个字节会分配一个32位或64位的编号,这个编号称为内存地址 \n\n这里先用一些代码来直观表述,不过我们不需要理解目前这些代码的意思,等以后学到栈的时候你可以再看看这些东西这样更好理解\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    // 虚拟内存四大区域演示\n    \n    // 1. 栈区（Stack）- 局部变量\n    char stack_str[] = \"Stack Memory\";  // 内容可修改\n    char stack_buffer[20];\n    \n    // 2. 堆区（Heap）- 动态分配\n    char *heap_str = malloc(20 * sizeof(char));\n    strcpy(heap_str, \"Heap Memory\");  // 内容可修改\n    \n    // 3. 数据段（Data Segment）- 已初始化全局变量\n    static char data_str[] = \"Data Segment\";\n    \n    // 4. 代码段（Text Segment）- 字符串常量（只读）\n    char *const_str = \"Read-Only Constant\";  // 指向代码段\n    \n    // ========= 打印地址信息 =========\n    printf(\"=== 虚拟内存地址分布 ===\\n\");\n    \n    // 栈区地址（向下增长）\n    printf(\"栈区地址:\\n\");\n    printf(\"  stack_str:    %p (内容: %s)\\n\", (void*)stack_str, stack_str);\n    printf(\"  stack_buffer: %p\\n\\n\", (void*)stack_buffer);\n    \n    // 堆区地址（向上增长）\n    printf(\"堆区地址:\\n\");\n    printf(\"  heap_str:     %p (内容: %s)\\n\\n\", (void*)heap_str, heap_str);\n    \n    // 数据段地址\n    printf(\"数据段地址:\\n\");\n    printf(\"  data_str:     %p (内容: %s)\\n\\n\", (void*)data_str, data_str);\n    \n    // 代码段地址（字符串常量）\n    printf(\"代码段地址(只读):\\n\");\n    printf(\"  const_str:    %p (内容: %s)\\n\", (void*)const_str, const_str);\n    printf(\"  字符串常量:   %p (内容: %s)\\n\\n\", (void*)\"Literal String\", \"Literal String\");\n    \n    // ========= 地址操作演示 =========\n    printf(\"=== 指针操作演示 ===\\n\");\n    printf(\"stack_str[0]的地址: %p，值: %c\\n\", (void*)&stack_str[0], stack_str[0]);\n    printf(\"heap_str指针的地址: %p，值: %p\\n\", (void*)&heap_str, (void*)heap_str);\n    \n    // 验证可修改性\n    stack_str[0] = 'S';  // ✅ 允许修改\n    heap_str[0] = 'H';   // ✅ 允许修改\n    // const_str[0] = 'R'; // ❌ 会Segmentation Fault（段错误）\n    \n    printf(\"\\n修改后:\\n\");\n    printf(\"  stack_str: %s\\n\", stack_str);\n    printf(\"  heap_str:  %s\\n\", heap_str);\n    \n    free(heap_str);  // 释放堆内存\n    return 0;\n}\n```\n\n​\t<img src=\"数据结构前置知识/计算机体系结构.jpg\" alt=\"计算机体系结构\" style=\"zoom:33%;\" />\n\n​\t<img src=\"数据结构前置知识/计算机体系结构简化.jpg\" alt=\"计算机体系结构简化\" style=\"zoom:33%;\" />\n\n## 数组\n\n```c\n////相同数据类型的集合\n////数组的长度一旦定义就不能改变\n////数组中的每一个元素可以用 下标表示位置,如果一个为数组中有n个元素\n////那么下标的取值范围是0~(n-1) \n//\n//\n////使用取地址符\"&\"来获取数组的地址时,返回的是数组第0个元素的内存地址 \n//\n//#include <stdio.h>\n//\n//int main()\n//{\n//\tint a[]={16,47,89,42,38};\n//\tprintf(\"%p\\n\",&a);\n//\tprintf(\"%p\\n\",&a[0]);\n//\n//}\n```\n\n数组我们也不说了,这个也是我们所熟知的离不开的东西\n\n不过提起数组还有一个概念我们也是经常使用到的-------那就是<font color='Red'>数组长度</font>\n\n这就离不开一个关键字 <font color='Turquoise'> sizeof</font>\n\n这个大致看看就行了,我们主要需要的是c语言的数组的长度求法\n\n```c\n#include<stdio.h>\nint main()\n{\n//\tint a[]={16,47,89,42,38};\n//\tprintf(\"%zu\\n\",sizeof(a));\n//\tprintf(\"%zu\\n\",sizeof(a[0]));\n//\tint len=sizeof(a)/sizeof(a[0]);\n//\tprintf(\"数组长度为%d\\n\",len);\n\n\tint a[]={16,47,89,42,38};\n\tfor(int i=0;i<sizeof(a)/sizeof(a[0]);i++){\n\t\t//TODO\n\t\tprintf(\"%d\\n\",a[i]);\n\t} \n}\n```\n\n## 指针\n\n这个在C语言中非常重要其实\n\n指针是用来存放内存地址的变量 ,这里我们就先了解最基本的就行\n\n### 指针基本符号运用\n\n这里先了解指针的一些基本符号比如“ <font color='Turquoise'>*</font> ”  和 “ <font color='Turquoise'>&</font> ”\n\n```c\n//int a;    声明一个整型变量\n//int *p;\t声明一个指针变量,该指针指向一个int类型值的内存地址\n\n//星号*两边的空格无关紧要,下面的声明是等价的\n//int* p;\n//int *p;\n//int * p;\n//int*p;\n\n#include <stdio.h>\nint main(){\n\tint a=5;\n\tint *p=&a;\n\tprintf(\"a值为%d,地址为%p\\n\",a,&a);\n\tprintf(\"p值为%p,地址为%p\",p,&p);\n\t\n//\tint a=5;\n//\tint *p=&a;\n//\tprintf(\"%d\\n\",*p);\n//\t*p=100;\n//\tprintf(\"%d\\n\",a);\n\t\n\treturn 0;\n}\n\n//间接应用操作符 \" * \" 返回指针变量的指向地址的值\n//通常把这个操作叫做\"解引用指针\"\n//英文叫做dereferencing a pointer\n```\n\n### 指针与函数\n\n同样的,指针在函数里使用也是及其广泛的,这里我们就以最经典的swap 交换函数为例\n\n```c\n#include<stdio.h>\n//void swap(int a,int b){\n//\tint temp;\n//\ttemp=a;\n//\ta=b;\n//\tb=temp;\n//\tprintf(\"交换后%d %d\",a,b);\n//}\n\nvoid swap(int *a,int *b){\n\tint temp;\n\ttemp=*a;\n\t*a=*b;\n\t*b=temp;\n\tprintf(\"交换后%d %d\",*a,*b);\n\t\n}\nint main(){\n\tint m;\n\tint n;\n\tprintf(\"m值为:\");\n\tscanf(\"%d\",&m);\n\tprintf(\"\\nn值为:\");\n\tscanf(\"%d\",&n);\n//\tswap(m,n);\n\tswap(&m,&n);\n\tprintf(\"\\n交换前%d %d\",m,n);\n\treturn 0;\n}\n```\n\n### 指针与数组\n\n同样的指针在数组里运用也是非常多的\n\n```c\n//在C语言中,指针和数组的关系十分密切\n//通过数组下标能完成的操作都可以通过指针完成\n//一般来说,用指针编写的程序比用数组下标编写的程序执行速度快\n#include <stdio.h>\nint main(){\n\tint a[]={15,22,67,43,87};\n\tint *p;\n\tp=a;\n//\tprintf(\"%p\\n\",a);\n//\tprintf(\"%p\\n\",p);\n//\tprintf(\"%d\\n\",*p);\n\tint len=sizeof(a)/sizeof(a[0]);\n\tfor(int i=0;i<len;i++){\n\t\tprintf(\"%d\\n\",a[i]);\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tprintf(\"%d\\n\",*(p+i));\n\t}\n}\n```\n\n## 结构体\n\n如果你学过Java  JavaScript  和C#的话,会发现结构体和  面向对象中的类  是不是很像呢\n\n因此在c中,结构体和typedef使用也是及其广泛的,假如你使用c语言加其他拓展库制作游戏的话,这个绝对是离不开的\n\n```c\n//结构体是一个或多个变量的集合,这些变量可以是不同的类型\n//声明语法\n\n\n//struct 结构体名\t\t\t//例如\n//{\t\t\t\t\t\t\t//struct point\n//\t数据类型 变量名;\t\t//{\t\t\t\t\t\t\n//\t数据类型 变量名;\t\t//\tint x;\n//\t......\t\t\t\t\t//\tint y;\n//}\t\t\t\t\t\t\t//}\n\n//结构体的初始化与调用\n//struct 结构体名 变量名;\n//例如:struct point p;\n\n//变量名.结构体内部变量名=值;\n//例如:\tp.x=10;\n//\t\tp.y=15;\n\n//#include <stdio.h>\n//\n//struct point{\n//\tint x;\n//\tint y;\n//};\n//\n//\n//int main(){\n//\tstruct point p;\n//\tp.x=5;\n//\tp.y=15;\n//\tprintf(\"%d\\n\",p.x);\n//\tprintf(\"%d\\n\",p.y);\n//\treturn 0;\n//}\n\n#include<stdio.h>\n\nstruct point{\n\tint x;\n\tint y;\n};\nstruct point creatPoint(int x,int y){\n\tstruct point temp;\n\ttemp.x=x;\n\ttemp.y=y;\n\treturn temp;\n}\nint main(){\n\tstruct point p;\n\tp=creatPoint(5,10);\n\tprintf(\"%d\\n\",p.x);\n\tprintf(\"%d\\n\",p.y);\n\treturn 0;\n}\n```\n\n同样的结构体也可以和指针一起使用\n\n```c\n//在一些场景中,如果传递给函数的结构体很大,使用指针方式的效率通常更高\n//pp指向一个point结构体\n\n//struct point *pp;\n\n//为pp所指向的结构体中的属性赋值\n//(*pp).x=10;\n//(*pp).y=5;\n\n//为了使用方便,C语言提供了另外一种简写方式\n//pp->x=10;\n//pp->y=5;\n\n#include <stdio.h>\nstruct point{\n\tint x;\n\tint y;\n};\nint main(){\n\tstruct point p;\n\tp.x=5;\n\tp.y=10;\n\t\n\tstruct point *pp;\n\tpp=&p;\n\t\n\t(*pp).x=10;\n\t(*pp).y=5;\n\t\n\tprintf(\"x=%d,y=%d\\n\",p.x,p.y);\n\tprintf(\"x=%d,y=%d\\n\",pp->x,pp->y);\n\treturn 0;\n}\n```\n\n对了,提起结构体struct就不得不得不提另一个关键字 -------<font color='Turquoise'>typedef</font>\n\n这个主要和struct一起使用(毕竟每次使用struct都要写一个struct关键字,非常麻烦,所以我们可以直接用typedef定义的<font color='Turquoise'>别名</font>尽量来模仿面向对象语言里的类的属性调用的写法)\n\n```c\n//typedef 数据类型 别名\n//例如 typedef int zx\n\n//#include <stdio.h>\n\n//typedef int myTest1;\n//typedef char myType2;\n//\n//int main(){\n//\tmyTest1 a=5;\n//\tmyType2 b='o';\n//\tprintf(\"%d\\n\",a);\n//\tprintf(\"%c\\n\",b);\n//\treturn 0;\n//}\n\n//每次声明结构体变量都要写struct关键字很麻烦,而且逻辑上也很难受\n//typeof可以解决这个问题\n\n\n//#include<stdio.h>\n//struct point{\n//\tint x;\n//\tint y;\n//};\n//\n//int main(){\n//\tstruct point p;\n//\tp.x=5;\n//\tp.y=10;\n//\tprintf(\"%d\\n\",p.x);\n//\tprintf(\"%d\\n\",p.y);\n//\treturn 0;\n//}\n\n\n//typedef struct 结构体名{\n//\t数据类型 变量名;\n//\t数据类型 变量名;\n//}别名;\n\n//当然结构体的名字可以忽略如下\n//typedef struct{\n//\t数据类型 变量名;\n//\t数据类型 变量名;\n//}别名;\n\n\n#include<stdio.h>\ntypedef struct{\n\tint x;\n\tint y;\n}po;\n\nint main(){\n\tpo p;\n\tp.x=5;\n\tp.y=10;\n\tprintf(\"%d\\n\",p.x);\n\tprintf(\"%d\\n\",p.y);\n\treturn 0;\n}\n```\n\n## 内存\n\nC程序编译后会以三种形式使用内存\n\n### 静态/全局内存\n\n> 静态声明的变量和全局变量使用这部分内存,这些变量在程序开始运行时分配,直到程序终才消失\n\n### 自动内存(栈内存)\n\n> 函数内部声明的变量使用这部分内存,在函数被调用时才创建\n\n### 动态内存(堆内存)\n\n> 根据需求编写代码动态分配内存可以编写代码释放,内存中的内容直到释放才消失\n\n```c\n //动态内存分配\n //在C语言中,动态分配内存的基本步骤:\n //1,使用malloc(memory allocate)函数分配内存\n //  void*malloc(size_t)\n //  如果成功,会返回从堆内存上分配的内存指针\n //  如果失败,会返回空指针\n //2,使用分配的内存\n //3,使用free函数释放内存\n```\n\n这里就用具体的代码来看看如何使用malloc函数吧\n\n```c\n//指针和字符串\n//#include<stdio.h>\n//#include<stdlib.h>\n//#include<string.h>\n//int main(){\n////\tint *p;\n////\tp=(int*)malloc(sizeof(int));\n////\t*p=15;\n////\tprintf(\"%d\\n\",*p);\n////\tfree(p);\n////\treturn 0;\n//\t\n//\tchar *s;\n//\ts=(char*)malloc(10);\n//\tstrcpy(s,\"Hello\");\n//\tprintf(\"%s\\n\",s);\n//\treturn 0;\n//}  \n\n\n//指针与数组\n//#include<stdio.h>\n//#include<stdlib.h>\n//int main(){\n//\tint *arr=(int*)malloc(5*sizeof(int));\n//\tfor(int i=0;i<5;i++){\n//\t\tarr[i]=0;\n//\t}\n//\tfor(int i=0;i<5;i++){\n//\t\tprintf(\"%d\\n\",arr[i]);\n//\t}\n//\treturn 0;\n//}\n\n#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n\tint x;\n\tint y;\n}po;\n\nint main(){\n\tpo *p;\n\tp=(po*)malloc(sizeof(po));\n\tp->x=5;\n\tp->y=10;\n\tprintf(\"%d\\n\",p->x);\n\tprintf(\"%d\\n\",p->y);\n}\n```\n\n\n\n## 文件的存储与读取\n\n这个由于是我们在学数据结构所以不提了,包括C语言数据类型什么的  switch case什么的  循环什么的   if else什么的  宏定义什么的也不需要多说了,因为我不仅仅只用c语言来写数据结构\n\n以后会把这些挖的坑填上,OK,随便扯了一些主要的基本回顾知识   see  ya ~ ~ ~\n\n​\t<img src=\"数据结构前置知识/f19c93c1cba523c7c5ddb3f67b512a2d355275186.jpg\" alt=\"f19c93c1cba523c7c5ddb3f67b512a2d355275186\" style=\"zoom:33%;\" />\n","tags":["Data Structure"],"categories":["数据结构"]},{"title":"love2d学习第三天--学习lua循环和if else语句","url":"/2025/12/24/游戏引擎相关/Love2d引擎/第三天/","content":"\n# ok,我们上一篇中已经了解一大堆玩意了,不过还是冰山一角,那么今天学学循环和if else语句吧\n\n如果你学过其他语言,绝对 对循环有回家一样的亲切感,同样的,什么for循环,while循环,do …while循环在lua中也是一样的\n\n而且if else你绝对老熟悉了\n\n前面我们挖了一个坑(就是数组的遍历部分),接下来可以讲讲了\n\n没学过的小伙伴可以看一下定义:\n\n循环是程序中用于**重复执行**某段代码（循环体）的控制结构，它包含一个**条件判断**和要重复执行的**循环体**，直到条件不再满足时终止。\n\n一组被重复执行的语句称之为**循环体**\n\n我们可以画一个图\n\n​\t<img src=\"第三天/image-20251224112935808.png\" alt=\"image-20251224112935808\" style=\"zoom:33%;\" />\n\n## while循环\n\n格式:\n\n```lua\nwhile 判断条件 do\n   循环体\n   改变条件\nend\n\n--或者\nwhile (判断条件) do\n   循环体\n   改变条件\nend\n\n--或者\nwhile 判断条件\ndo\n   循环体\n   改变条件\nend\n\n--或者\nwhile (判断条件) \ndo\n   循环体\n   改变条件\nend\n```\n\n你可以把do…end想像为其他语言中的花括号{ },而判断条件里的括号可写可不写  这一点和python和gdscript很像\n\n这里我用C#里的你可以对比一下\n\n```c#\n //while 循环执行 \nwhile (a < 20) \n{\n   Console.WriteLine(\"a 的值： {0}\", a);\n   a++;\n}\n```\n\n while 循环语句在判断条件为 true 时会重复执行循环体语句\n\n```lua\nlocal cookies = 20 -- 罐子里的饼干数量\n\nwhile (cookies > 0) do\n    print(\"爱丽丝拿了一块饼干 🍪\")\n    cookies = cookies - 1\n    print(\"罐子里还剩\"..cookies..\"块\")\nend\n\nprint(\"罐子空了，爱丽丝溜了！\")\n```\n\n​\t<img src=\"第三天/image-20251224114117462.png\" alt=\"image-20251224114117462\" style=\"zoom:33%;\" />\n\n对了,while还可以制造无限循环\n\n```lua\nwhile( true )\ndo\n   print(\"爱丽丝一直偷吃饼干\")\nend\n```\n\n​\t<img src=\"第三天/image-20251224185015296.png\" alt=\"image-20251224185015296\" style=\"zoom:33%;\" />\n\n什么,你说while无限循环除了让电脑死机还有什么用,请看Unity的Update和FixedUpdate方法的本质:\n\n​\t<img src=\"第三天/image-20251224192211585.png\" alt=\"image-20251224192211585\" style=\"zoom:33%;\" />\n\n​\t<img src=\"第三天/image-20251224192529730.png\" alt=\"image-20251224192529730\" style=\"zoom:33%;\" />\n\n可以看到,这两个unity脚本离不开的核心函数都是无限调用,估计  love2d 中也有类似的函数\n\n## for 循环\n\n for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制,刚才的while循环的循环次数是不受控制的,只有不满足条件时才会跳出循环\n\n对了,lua里面没有a++,++a,a--,--a这种写法,  或者a+=1 a-=1这种写法,  只能写成a=a+1  或者a=a-1\n\n格式:\n\n```lua\nfor 局部变量名=循环起始值,循环结束值,循环步长 do  \n    循环体 \nend  \n```\n\n同样可以参考一下C#的\n\n```c#\nfor (int a = 10; a < 20; a++)\n{\n    Console.WriteLine(\"a 的值： {0}\",a);\n}\n```\n\n我们用代码来讲更好理解一些\n\n```lua\nlocal cookies = 20\n\n--条件为 i = 1, cookies ,循环步长不写的话默认为1约等于其他语言里的 i++\n--lua默认循环条件里的变量为local局部变量,仅循环内部可用\nfor i = 1, cookies do\n    print(\"爱丽丝第\" .. i .. \"次拿饼干 🍪\")\n    cookies = cookies - 1\nend\n\n\nif cookies ~= 0 then\n    print(\"罐子里还有\" .. cookies .. \"个饼干,爱丽丝还能继续吃!!!\")\nelse\n    print(\"罐子空了,爱丽丝溜了,小桃小绿回来后很生气!!!\")\nend\n```\n\n​\t<img src=\"第三天/image-20251224200846230.png\" alt=\"image-20251224200846230\" style=\"zoom:33%;\" />\n\n我们可以改一下条件\n\n```lua\nlocal cookies = 20\n--条件为 i = 6, cookies\nfor i = 6, cookies do\n    print(\"爱丽丝第\" .. i .. \"次拿饼干 🍪\")\n    cookies = cookies - 1\nend\n\n\nif cookies ~= 0 then\n    print(\"罐子里还有\" .. cookies .. \"个饼干,爱丽丝还能继续吃!!!\")\nelse\n    print(\"罐子空了,爱丽丝溜了,小桃小绿回来后很生气!!!\")\nend\n```\n\n​\t<img src=\"第三天/image-20251224201338756.png\" alt=\"image-20251224201338756\" style=\"zoom:33%;\" />\n\n我们还可以验证一下循环步长的作用,这个不写的话默认为  <font color='Red'>1</font>\n\n```lua\nlocal cookies = 20\n--条件我们设置为i = 1, cookies, 2  循环步长为 2\nfor i = 1, cookies, 2 do\n    print(\"爱丽丝第\" .. i .. \"次拿饼干 🍪\")\n    cookies = cookies - 1\nend\n\n\nif cookies ~= 0 then\n    print(\"罐子里还有\" .. cookies .. \"个饼干,爱丽丝还能继续吃!!!\")\nelse\n    print(\"罐子空了,爱丽丝溜了,小桃小绿回来后很生气!!!\")\nend\n```\n\n​\t<img src=\"第三天/image-20251224202536414.png\" alt=\"image-20251224202536414\" style=\"zoom:33%;\" />\n\n​\t还可以将饼干减少的逻辑封装到函数里\n\n```lua\nlocal cookies = 20\n\nfunction EatCookies(number)\n    number = number - 1\n    return number\nend\n\nfor i = 1, cookies do\n    print(\"爱丽丝第\" .. i .. \"次拿饼干 🍪\")\n    cookies = EatCookies(cookies)\nend\n\nif cookies ~= 0 then\n    print(\"罐子里还有\" .. cookies .. \"个饼干,爱丽丝还能继续吃!!!\")\nelse\n    print(\"罐子空了,爱丽丝溜了,小桃小绿回来后很生气!!!\")\nend\n```\n\n​\t<img src=\"第三天/image-20251224204337238.png\" alt=\"image-20251224204337238\" style=\"zoom:33%;\" />\n\n好了,接下来把之前挖的坑填上———表的遍历学过其他语言的数组的小伙伴通常会用for循环来遍历数组,我们lua也是一般使用for循环      \n\n### 这里的lua的遍历分为三种:\n\n#### ipairs遍历\n\n**第一种:** ``ipairs` —— 顺序数组遍历`\n\n格式(缩写版,推荐):\n\n```lua\nlocal 表名 = {....}\n\nfor i, v in ipairs(表名) do\n    print(i, v)\nend\n```\n\n完整版\n\n```lua\nlocal 表名 = {....}\n\nfor index, value in ipairs(表名) do\n    print(index, value)\nend\n```\n\n\n\n这种遍历属于有序遍历,即从前到后, i  的值默认为1 不可更改\n\n而且遍历的时候如果遇到 nil(即遇到空值断层) 后会停止遍历,而且遍历时遇到键值对会自动跳过\n\n**`i` 和 `v` 是循环过程中“每一轮自动赋值的两个局部变量”**\n\n- `i` = **当前元素的索引（key）**\n- `v` = **当前元素的值（value）**\n\n```lua\nlocal cookies = { \"奶龙\", \"贝利亚\", \"丰川祥子\", \"千早爱音\", \"橘雪莉\" }\n\nprint(\"唐朝最唐生物排名:\")\n\nfor i, v in ipairs(cookies) do\n    print(i, v)\nend\n\nfor i, v in ipairs(cookies) do\n    print(i .. v)\nend\n```\n\n​\t<img src=\"第三天/image-20251224234616575.png\" alt=\"image-20251224234616575\" style=\"zoom: 25%;\" />\n\n#### pairs遍历\n\n**第二种:** ``pairs` —— 通用遍历`\n\n这个格式和 ipairs一样:\n\n```lua\nlocal 表名 = {....}\n\nfor i, v in pairs(表名) do\n    print(i, v)\nend\n```\n\n完整版\n\n```lua\nlocal 表名 = {....}\n\nfor index, value in ipairs(表名) do\n    print(index, value)\nend\n```\n\n这种可以遍历 **table 中所有键值对**（无论是数组还是字典）,但是遍历的顺序是无序的,而且不同于ipairs的是,pairs遇到nil时不会停止,而是直接跳过索引对应的空值\n\n​\t<img src=\"第三天/image-20251229201435729.png\" alt=\"image-20251229201435729\" style=\"zoom: 33%;\" />\n\n可以看到这是没有顺序的遍历\n\n#### for循环遍历\n\n这个其实也可以采用原生的for循环遍历,不过这个for循环只支持数组,不支持字典\n\n和其他语言中用for遍历数组的方式是差不多的\n\n格式:\n\n```lua\nlocal 表名 = {....}\n\nfor i=1, #表名 do\n    print(i, 表名[i])\nend\n```\n\n其实就是for循环,这里就用一个例子来解释吧,我们可以变相来遍历字典实现顺序遍历\n\n```lua\nlocal cookies = {\n    order = {\n        \"tang_01\",\n        \"tang_02\",\n        \"tang_03\",\n        \"tang_04\",\n        \"tang_05\",\n    },\n    data = {\n        tang_01 = \"奶龙\",\n        tang_02 = \"贝利亚\",\n        tang_03 = \"丰川祥子\",\n        tang_04 = \"千早爱音\",\n        tang_05 = \"橘雪莉\"\n    }\n}\n\nfor i = 1, #cookies.order do\n    local key = cookies.order[i]\n    print(i, cookies.data[key])\nend\n```\n\n​\t<img src=\"第三天/image-20251229202822255.png\" alt=\"image-20251229202822255\" style=\"zoom:33%;\" />\n\n## repeat ... until 循环\n\n这个非常有意思\n\n学过其他语言比如C C++ C#这些绝对知道  do ... while循环\n\n但是我们可以看一下 do ... while循环的特性\n\n```c#\ndo {\n    // 先执行\n    // 代码语句\n} while (condition);   \n// 条件condition为 true 时循环继续\n// do while是先执行后判断条件,所以至少执行一次代码语句\n```\n\n 但是看看我们的Lua就是相反的\n\n```lua\nrepeat\n    -- 先执行\n    --代码语句\nuntil condition        \n--  条件condition为 true 时循环结束\n--  repeat until也是先执行后判断条件,所以至少执行一次代码语句\n```\n\n我们可以看看代码\n\n```lua\nlocal cookies = 10\n\nrepeat\n    print(\"饼干还剩:\" .. cookies .. \"个\")\n\n    cookies = cookies - 1\n\n    if cookies == 0 then\n        print(\"爱丽丝吃完了所有的饼干!\")\n    end\nuntil (cookies <= 0)\n```\n\n​\t<img src=\"第三天/image-20251229230525588.png\" alt=\"image-20251229230525588\" style=\"zoom:33%;\" />\n\n我们修改一下条件语句\n\n```lua\nlocal cookies = 10\n\nrepeat\n    cookies = cookies - 1\n    print(\"饼干还剩:\" .. cookies .. \"个\")\n\n    if cookies == 0 then\n        print(\"爱丽丝吃完了所有的饼干!\")\n    end\nuntil (cookies <= 0)\n```\n\n​\t<img src=\"第三天/image-20251229230749486.png\" alt=\"image-20251229230749486\" style=\"zoom:33%;\" />\n\n哦,对了,和其他语言一样,循环是可以嵌套的,这里我用一些比较经典的算法讲一下\n\n比如冒泡排序\n\n```lua\n\n```\n\n","tags":["love2d","lua"],"categories":["游戏开发"]},{"title":"FontColorChange脚本软件的使用方法的详细说明","url":"/2025/12/15/AutoHotkey相关/脚本使用方法/","content":"\n# 大家好呀!\n\nTypora是我最喜欢使用的写作软件,在我使用Markdown文档写游戏开发笔记的时候,遇到一个问题那就是,很多时候我想给字体变一个好看的颜色\n\n我还得在markdown里面一点一点的敲代码比如\n\n<font color='Red'>\n\n我是一个苹果我是红色的\n\n</font>\n\n非常难受,而且我是一个懒懒虫,不想动手指,所以做了这个软件\n\n# 使用方法一(推荐,最简单)\n\n我的软件都包含在这个 [<font color='Turquoise'>FontColorChange5.zip(点击下载)</font>](https://github.com/huyangpahuo/Game-UnityProject/releases/download/AutohotkeyScript/FontColorChange5.zip)   zip包中了,解压挑选一个你们国家语言的exe版本下载即可,比如简体中文版本FontColorChange5(SimplifiedChinese).exe\n\n这个是我的仓库地址[<font color='Turquoise'>点击跳转github仓库</font>](https://github.com/huyangpahuo/Game-UnityProject/releases/tag/AutohotkeyScript)\n\n下载点击exe后再进入Typora软件输入快捷键 Ctrl + Alt +C  可以打开操作界面\n\n# 使用方法二(不推荐,但原理一样)\n\n所以我听说存在这样一种东西:那就是Autohotkey,一个可以写自动化脚本的软件\n\n[<font color='LightSkyBlue'>点击下载Autohotkey</font>](https://www.autohotkey.com/)\n\n<img src=\"脚本使用方法/image-20251213210042947.png\" alt=\"image-20251213210042947\" style=\"zoom:67%;\" />\n\n## 你们只需要下载那个Autohotkey V2  版本就可以了,那个Autohotkey V1版本有非常多的Bug千万不要用(比如让你的电脑键盘不起作用和让你的电脑死机)\n\n然后使用方法是下载我给你们的脚本(前提是你已经下载了Autohotkey V2)\n\n然后第一步点击其中一个\n\n<img src=\"脚本使用方法/image-20251213210558067.png\" alt=\"image-20251213210558067\" style=\"zoom: 50%;\" />\n\n此时在电脑右下角出现这个东西,绿色的这个,表示脚本已经成功启动啦!\n\n<img src=\"脚本使用方法/image-20251213210818091.png\" alt=\"image-20251213210818091\" style=\"zoom:50%;\" />\n\n## 然后打开你的Typora(这个脚本只可以在Typora中运行)     在上面随便写一句话并用鼠标左键选中 \n\n<img src=\"脚本使用方法/image-20251213211341596.png\" alt=\"image-20251213211341596\" style=\"zoom:50%;\" />\n\n##   按下快捷键Ctrl + Alt + C         如果不小心关掉了窗口还可以用这个快捷键呼唤出来\n\n## 就会弹出一个窗口,然后你可以从中选择颜色哦\n\n比如我选择      “红色”\n\n<img src=\"脚本使用方法/image-20251213211535910.png\" alt=\"image-20251213211535910\" style=\"zoom:50%;\" />\n\n\n\n## 我的脚本分为这几代———如下所示\n\n### \t\t第一代:    FontColorChange1.ahk(或exe)\n\n​\t\t这个非常的简陋,只有单纯的文字,适合喜欢简约风格者\n\n​\t\t<img src=\"脚本使用方法/image-20251213211623719.png\" alt=\"image-20251213211623719\" style=\"zoom:50%;\" />\n\n### \t\t第二代:\tFontColorChange2.ahk(或exe)\n\n​\t\t这个添加了简单的颜色和增加了9种颜色,适合喜欢多种颜色者\n\n​\t\t\t<img src=\"脚本使用方法/image-20251213211825880.png\" alt=\"image-20251213211825880\" style=\"zoom: 33%;\" />\n\n### \t\t第三代:\tFontColorChange3.ahk(或exe)\n\n​\t\t这个为了让颜色更加直观,每一个选项都添加了颜色,适合所有人\n\n​\t\t<img src=\"脚本使用方法/image-20251213212156576.png\" alt=\"image-20251213212156576\" style=\"zoom:50%;\" />\n\n### \t\t\t第四代:   FontColorChange4.ahk(或exe)\n\n​\t\t\t增加自定义颜色的功能,你可以填写你想要的颜色的RBG值或者HEX值来选择颜色\n\n​\t<img src=\"脚本使用方法/image-20251214124212236.png\" alt=\"image-20251214124212236\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"脚本使用方法/image-20251214124522725.png\" alt=\"image-20251214124522725\" style=\"zoom:50%;\" />\n\n### \t\t\t第五代:\tFontColorChange5.ahk(或exe)\n\n​\t目前为止功能相对完善的一个版本,强烈推荐使用,毕竟修复了前几个版本的一些已知的可更改问题,用起来更加方便的哦,布局更改之后我是觉得挺好看的哈哈哈\n\n​\t<img src=\"脚本使用方法/image-20251215215058956.png\" alt=\"image-20251215215058956\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"脚本使用方法/image-20251215215127635.png\" alt=\"image-20251215215127635\" style=\"zoom:50%;\" />\n\n​\t<img src=\"脚本使用方法/image-20251215215153058.png\" alt=\"image-20251215215153058\" style=\"zoom:50%;\" />\n\n这是第五代脚本的源代码\n\n```\n#Requires AutoHotkey v2.0\n#SingleInstance Force\nSendMode \"Input\"\n\n; =========================\n; 全局变量\n; =========================\nglobal ColorGui := 0\nglobal CustomGui := 0\nglobal InfoGui   := 0\nglobal CustomHex := \"FF0000\"\n\n\n; =========================\n; 仅在 Typora 生效\n; =========================\n#HotIf WinActive(\"ahk_exe Typora.exe\")\n^!c::ShowColorGui()\n#HotIf\n\n\n; =========================\n; 预设颜色点击\n; =========================\nApplyColorFromText(ctrl, *)\n{\n    WinActivate \"ahk_exe Typora.exe\"\n    Sleep 40\n    AddFontColor(ctrl.Tag)\n}\n\n\n; =========================\n; 主颜色窗口\n; =========================\nShowColorGui()\n{\n    global ColorGui\n\n    if IsObject(ColorGui)\n    {\n        ColorGui.Show()\n        return\n    }\n\n    ; 创建窗口\n    ColorGui := Gui(\"+AlwaysOnTop +Resize\", \"字体颜色\")\n    ColorGui.SetFont(\"s9\")\n\n    ; ===== 顶部按钮 =====\n    ; 按钮宽 120，中间间距 20\n    infoBtn   := ColorGui.AddButton(\"xm w120\", \"使用说明(必看)\")\n    customBtn := ColorGui.AddButton(\"x+20 yp w120\", \"自定义颜色\")\n\n    infoBtn.OnEvent(\"Click\", (*) => ShowInfoGui())\n    customBtn.OnEvent(\"Click\", (*) => ShowCustomColorGui())\n\n    ; ===== 颜色定义 =====\n    colors := [\n        [\"DarkOrange\",\"焦橙色\"], [\"Red\",\"红色\"], [\"LightSkyBlue\",\"天蓝\"],\n        [\"Turquoise\",\"绿松石\"], [\"MediumVioletRed\",\"紫红\"], [\"Teal\",\"蓝绿色\"],\n        [\"Gold\",\"金黄色\"], [\"DimGray\",\"灰黑色\"], [\"DeepPink\",\"亮粉色\"],\n        [\"DodgerBlue\",\"亮蓝\"], [\"LimeGreen\",\"鲜绿\"], [\"OrangeRed\",\"橙红\"],\n        [\"SlateBlue\",\"岩蓝\"], [\"Chocolate\",\"巧克力\"], [\"Crimson\",\"深红\"],\n        [\"SeaGreen\",\"海绿\"], [\"SteelBlue\",\"钢蓝\"], [\"Black\",\"纯黑\"]\n    ]\n\n    ColorHex := Map(\n        \"DarkOrange\",\"FF8C00\",\"Red\",\"FF0000\",\"LightSkyBlue\",\"87CEFA\",\n        \"Turquoise\",\"40E0D0\",\"MediumVioletRed\",\"C71585\",\"Teal\",\"008080\",\n        \"Gold\",\"FFD700\",\"DimGray\",\"696969\",\"DeepPink\",\"FF1493\",\n        \"DodgerBlue\",\"1E90FF\",\"LimeGreen\",\"32CD32\",\"OrangeRed\",\"FF4500\",\n        \"SlateBlue\",\"6A5ACD\",\"Chocolate\",\"D2691E\",\"Crimson\",\"DC143C\",\n        \"SeaGreen\",\"2E8B57\",\"SteelBlue\",\"4682B4\",\"Black\",\"000000\"\n    )\n\n    ; ===== 布局参数 =====\n    colW := 120   ; 色块宽度（与顶部按钮一致）\n    rowH := 28    ; 色块高度\n    gapY := 6     ; 上下间距\n    startY := 45  ; 第一行颜色的起始Y坐标（稍微拉开一点点与按钮的距离，更好看）\n    \n    ; 这里的 gapX 必须等于顶部两个按钮的间距 (20)\n    ; 计算右列的 X 偏移量：左边距(xm) + 按钮宽(120) + 间距(20) = 140\n    \n    Loop colors.Length\n    {\n        c := colors[A_Index][1]\n        n := colors[A_Index][2]\n\n        ; 计算行列 (0为左列, 1为右列)\n        col := (A_Index <= 9) ? 0 : 1\n        row := Mod(A_Index - 1, 9)\n\n        ; >>> 核心修改：X坐标对齐逻辑 <<<\n        ; 如果是左列(0)，位置就是 xm\n        ; 如果是右列(1)，位置就是 xm+140 (即 xm + 宽度120 + 间距20)\n        xPosStr := (col == 0) ? \"xm\" : \"xm+140\"\n        \n        ; 计算 Y 坐标\n        yPos := startY + row * (rowH + gapY)\n\n        ; 添加色块\n        ; 0x200 保证垂直居中\n        t := ColorGui.AddText(\n            xPosStr \" y\" yPos \" w\" colW \" h\" rowH \n            \" 0x200 Center Border Background\" ColorHex[c], \n            n\n        )\n\n        t.SetFont(c=\"Black\"||c=\"Crimson\"||c=\"SlateBlue\" ? \"cWhite\":\"cBlack\")\n        t.Tag := c\n        t.OnEvent(\"Click\", ApplyColorFromText)\n    }\n\n    ; 自动调整高度，宽度稍微给点余量避免紧贴边缘，但内容是绝对居中的\n    ColorGui.Show(\"w290 h370\")\n}\n\n\n; =========================\n; 提醒窗口（独立）\n; =========================\nShowInfoGui()\n{\n    global InfoGui\n\n    if IsObject(InfoGui)\n    {\n        InfoGui.Show()\n        return\n    }\n\n    InfoGui := Gui(\"+AlwaysOnTop +Resize\", \"使用说明\")\n    InfoGui.SetFont(\"s9\")\n\n    InfoGui.AddEdit(\n        \"xm ym w400 h260 ReadOnly -VScroll Wrap\",\n        \"① 点击颜色,在 Typora 中为选中文本设置字体颜色`n`n\"\n        \"② 若不小心关闭主窗口,可使用 Ctrl + Alt + C 重新打开`n`n\"\n        \"③ 主窗口与所有小窗口均支持自由拉伸`n`n\"\n        \"④ 由于我的软件目前存在一个已知的暂时无法修复的Bug可能会导致文字消失,可使用 Ctrl + Z 撤回操作,以及如果你们想要将已经修改颜色的文字换一个颜色,对此我无能为力,你可以可使用 Ctrl + Z 撤回颜色或者删掉重新打字并再次选择颜色\"\n    )\n\n    InfoGui.Show(\"w420 h300\")\n}\n\n\n; =========================\n; 自定义颜色窗口\n; =========================\nShowCustomColorGui()\n{\n    global CustomGui, CustomHex, ColorGui\n\n    if IsObject(CustomGui)\n    {\n        CustomGui.Show()\n        return\n    }\n\n    CustomGui := Gui(\"+AlwaysOnTop +Resize\", \"自定义颜色\")\n    CustomGui.SetFont(\"s9\")\n\n    ; ===== HEX =====\n    CustomGui.AddText(\"xm\", \"HEX（不带 #）\")\n    HexEdit := CustomGui.AddEdit(\"xm w260\", CustomHex)\n\n    ; ===== RGB =====\n    CustomGui.AddText(\"xm y+10\", \"RGB\")\n    R := CustomGui.AddEdit(\"xm w80\", \"255\")\n    G := CustomGui.AddEdit(\"x+10 yp w80\", \"0\")\n    B := CustomGui.AddEdit(\"x+10 yp w80\", \"0\")\n\n    ; ===== 预览 =====\n    Preview := CustomGui.AddText(\n        \"xm y+10 w260 h40 0x200 Center Border Background\" CustomHex,\n        \"颜色预览\"\n    )\n\n    R.OnEvent(\"Change\", (*) => UpdateFromRGB(R, G, B, HexEdit, Preview))\n    G.OnEvent(\"Change\", (*) => UpdateFromRGB(R, G, B, HexEdit, Preview))\n    B.OnEvent(\"Change\", (*) => UpdateFromRGB(R, G, B, HexEdit, Preview))\n    HexEdit.OnEvent(\"Change\", (*) => UpdateFromHex(HexEdit, Preview))\n\n    refresh := CustomGui.AddButton(\"xm y+10 w260\", \"刷新预览\")\n    refresh.OnEvent(\"Click\", (*) => RefreshPreview(R, G, B, HexEdit, Preview))\n\n    apply := CustomGui.AddButton(\"xm y+6 w260\", \"使用该颜色\")\n    apply.OnEvent(\"Click\", (*) => ApplyCustomColor())\n\n    back := CustomGui.AddButton(\"xm y+6 w260\", \"返回\")\n    back.OnEvent(\"Click\", (*) => (CustomGui.Hide(), ColorGui.Show()))\n\n    CustomGui.Show(\"w300 h360\")\n}\n\n\n; =========================\n; 颜色逻辑\n; =========================\nUpdateFromRGB(R, G, B, HexEdit, Preview)\n{\n    global CustomHex\n    CustomHex := Format(\"{:02X}{:02X}{:02X}\", Clamp(R.Value), Clamp(G.Value), Clamp(B.Value))\n    HexEdit.Value := CustomHex\n    Preview.Opt(\"Background\" CustomHex)\n}\n\nUpdateFromHex(HexEdit, Preview)\n{\n    global CustomHex\n    if RegExMatch(HexEdit.Value, \"^[0-9A-Fa-f]{6}$\")\n    {\n        CustomHex := HexEdit.Value\n        Preview.Opt(\"Background\" CustomHex)\n    }\n}\n\nApplyCustomColor()\n{\n    global CustomHex\n    WinActivate \"ahk_exe Typora.exe\"\n    Sleep 40\n    AddFontColor(\"#\" CustomHex)\n}\n\nRefreshPreview(R, G, B, HexEdit, Preview)\n{\n    global CustomHex, CustomGui\n\n    if RegExMatch(HexEdit.Value, \"^[0-9A-Fa-f]{6}$\")\n        CustomHex := HexEdit.Value\n    else\n        CustomHex := Format(\"{:02X}{:02X}{:02X}\", Clamp(R.Value), Clamp(G.Value), Clamp(B.Value))\n\n    CustomGui.Hide()\n    Preview.Opt(\"Background\" CustomHex)\n    CustomGui.Show()\n}\n\nClamp(v)\n{\n    if (v = \"\" || !IsNumber(v))\n        return 0\n    v := Integer(v)\n    return v < 0 ? 0 : v > 255 ? 255 : v\n}\n\nAddFontColor(color)\n{\n    ClipSaved := ClipboardAll()\n    A_Clipboard := \"\"\n\n    Send \"^c\"\n    ClipWait 0.5\n\n    if (A_Clipboard != \"\")\n    {\n        A_Clipboard := \"<font color='\" color \"'>\" A_Clipboard \"</font>\"\n        Send \"^v\"\n    }\n    else\n    {\n        A_Clipboard := \"<font color='\" color \"'></font>\"\n        Send \"^v\"\n        Send \"{Left 7}\"\n    }\n\n    Sleep 30\n    A_Clipboard := ClipSaved\n}\n\n; =========================\n; 启动即显示\n; =========================\nShowColorGui()\n```\n\n\n\n## 所有脚本都存在一个明显的问题,那就是需要先启用脚本再鼠标左键选择要变色的文字,否则先选择文字再启用脚本点击颜色选项就会让文字消失或者出现乱码\n\n## 未来我可能会再增加一个类似Photoshop的调色盘的功能,毕竟颜色不应该只局限于这18种,希望你们使用愉快!\n\n\n\n\n\n\n\n\n\n​\t\t\n\n​\t\t","tags":["Autohotkey V2"],"categories":["AutohotkeyScript"]},{"title":"love2d学习第二天--学习lua的基本语法和关键字","url":"/2025/12/14/游戏引擎相关/Love2d引擎/第二天/","content":"\n# 首先在学习Love2d之前我们先熟悉该引擎所依赖的语言—–Lua(这里我们就用lua5.4吧,毕竟功能多)\n\n## 第一个程序:输出Hello Genshin Impact\n\n其实上一篇我们已经输出过这句话了,不过再看一遍吧[<font color='LightSkyBlue'>狗头</font>]  [<font color='Red'>狗头</font>]  [<font color='Gold'>狗头</font>]\n\n```lua\nprint(\"Hello Genshin Impact!\")\n```\n\n这个在其他语言中的表现形式片段展示一下吧(就全扯一遍我见过的吧,反正都是随便写的伪代码片段哈哈哈)\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello Genshin Impact!\");\n    }\n}\n```\n\n```c#\nusing System;\n\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Hello Genshin Impact!\");\n    }\n}\n```\n\n```c++\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello Genshin Impact!\" << std::endl;\n    return 0;\n}\n```\n\n```c\n#include <stdio.h>\n\nint main(void) {\n    printf(\"Hello Genshin Impact!\\n\");\n    return 0;\n}\n```\n\n```javascript\nconsole.log(\"Hello Genshin Impact!\");\n```\n\n```python\nprint(\"Hello Genshin Impact!\")\n```\n\n```GDScript\n#GDScript伪代码\nprint(\"Hello Genshin Impact!\")\n```\n\n```Unity_C#\n//Unity C#伪代码\nusing UnityEngine;\n\npublic class HelloGenshin : MonoBehaviour\n{\n    void Start()\n    {\n        Debug.Log(\"Hello Genshin Impact!\");\n    }\n}\n```\n\n```Godot_C#\n//Godot C#伪代码\nusing Godot;\n\npublic partial class HelloGenshin : Node\n{\n    public override void _Ready()\n    {\n        GD.Print(\"Hello Genshin Impact!\");\n    }\n}\n```\n\n```AutoHotkey\n;AutoHotkey V2伪代码\nPrint(\"Hello Genshin Impact!\")\n```\n\n```kotlin\nfun main() = println(\"Hello Genshin Impact!\")\n```\n\n```typescript\nconsole.log(\"Hello Genshin Impact!\");\n```\n\n```rust\nfn main() { println!(\"Hello Genshin Impact!\"); }\n```\n\n可以看出像lua这种缩进式语言还是及其简洁的,就像python和GDscript一样\n\n不过我就在这一主题中专心于lua这一种语言吧,其实语言没有优劣之分,只是分工不同,就看会不会用哦,不会用就算语言再高级也是没用的,就像送给原始人笔记本电脑一样（ ￣ー￣）\n\nOK,不废话了,先说第一个—–注释\n\n## 注释\n\nlua语言注释的格式是,作用是写点能提醒自己自己写的是什么东西的话(不要相信你自己的记忆力,真的,头一天写睡一觉忘得一干二净很正常  (＞﹏＜)  ),而编译器或引擎会忽略这句话\n\n但是我们一般不会一点一点的敲符号的,在VScode里我们可以选中要注释的文本直接使用快捷键<font color='Turquoise'>Ctrl + /</font>\n\n什么,你说怎么取消注释,其实再按一下<font color='Turquoise'>Ctrl + /</font> 就取消了\n\n同理多行注释是<font color='Turquoise'> shift +alt +a</font>\n\n代码格式化是<font color='Turquoise'> shift +alt +f</font>   或 <font color='Turquoise'>ctrl +K ,ctrl +F</font>，区别是前者是格式化鼠标选择区域的代码,后者是 格式化整个文件的代码\n\n如果用不惯的话可以自定义\n\n​\t<img src=\"第二天/image-20251218213220074.png\" alt=\"image-20251218213220074\" style=\"zoom:33%;\" />\n\n输入<font color='Turquoise'>comment</font>\n\n```\ncomment\n```\n\n​\t<img src=\"第二天/image-20251218213348246.png\" alt=\"image-20251218213348246\" style=\"zoom:33%;\" />\n\n如图,行注释就是单行注释,块注释就是多行注释,这里多行注释我已经调成我喜欢的<font color='Turquoise'>ctrl + shift + /</font>\n\n<font color='Red'>右键</font>中间的<font color='Red'>键绑定</font>部分点击“<font color='Red'>更改键绑定</font>”自己修改即可\n\n​\t<img src=\"第二天/image-20251218220629962.png\" alt=\"image-20251218220629962\" style=\"zoom:33%;\" />\n\n​\t<img src=\"第二天/image-20251218213513573.png\" alt=\"image-20251218213513573\" style=\"zoom: 50%;\" />\n\n代码格式化的我们可以这样调\n\n同理,输入<font color='Turquoise'> format document</font>\n\n```\n format document\n```\n\n​\t<img src=\"第二天/image-20251218214502376.png\" alt=\"image-20251218214502376\" style=\"zoom:33%;\" />\n\n​\t把里面的快捷键自己调成你喜欢的,我因为一大堆插件造成快捷键冲突所以我就不改了\n\n<font color='Turquoise'>单行注释</font>\n\n```lua\n--hello,我是牢大,我爱冰红茶\n```\n\n<font color='Turquoise'>多行注释</font>\n\n格式:在单行注释后面加上[[    注释内容    ]]\n\n```lua\n--[[\n man!\n what can I say\n]]\n```\n\n有些曼波小伙伴可能会这么干,这是达咩的哟,lua不允许嵌套注释\n\n​\t<img src=\"第二天/image-20251218220350743.png\" alt=\"image-20251218220350743\" style=\"zoom:33%;\" />\n\n## 语言风格\n\nlua有点类似于JavaScript,像大多数语言比如C,Java,C#,C++都是强制每句代码后都有一个分号“<font color='Red'> ;</font> ”\n\n但是lua可要可不要,一般不要,比如下面两种写法都对(先保存再运行代码,不然结果还是之前的)\n\n​\t<img src=\"第二天/image-20251218212058977.png\" alt=\"image-20251218212058977\" style=\"zoom:25%;\" />\n\n## 变量\n\n变量命名规则和其他语言基本一致\n\n通常是小写字母加数字或者“_”符号,或者是那种驼峰命名法\n\n比如\n\n```\nplayer\nitem\ntree_01\nenemy_orc\nmyInventory\n```\n\nLua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量\n\n局部变量的作用域为从声明位置开始到所在语句块结束,这个等会儿会在脚本中演示\n\n在 Lua 中：\n\n> **不写 `local` 的变量 = 全局变量**\n>  **写了 `local` 的变量 = 只在当前作用域可见**\n\n## 关键字\n\n这个基本上相比其他语言关键字不是很多,先不讲以后慢慢说\n\n|   and    | break |  do   |  else  |\n| :------: | :---: | :---: | :----: |\n|  elseif  |  end  | false |  for   |\n| function |  if   |  in   | local  |\n|   nil    |  not  |  or   | repeat |\n|  return  | then  | ture  | until  |\n|  while   | goto  |       |        |\n\n\n\n## 数据类型\n\nlua有8种数据类型,如下:\n\n|       数据类型       | 描述                                                         |\n| :------------------: | ------------------------------------------------------------ |\n|       nil(空)        | 类似其他语言的null,也就是表示空值的意思,nil就是<font color='Red'>假</font> |\n|    boolean(布尔)     | 布尔值,只能表示,false和true,false为<font color='Red'>假</font>,true就是<font color='Red'>真</font> |\n|     number(数字)     | 这个可以表示整型和浮点型,浮点的话默认双精度double,只是lua统一为<font color='Red'>number</font>类型 |\n|    string(字符串)    | 字符串类型,可以用双引号<font color='Red'>“ ”</font> 单引号<font color='Red'> ‘ ’ </font> 双长括号<font color='Red'> [[  ]]</font> |\n|    function(函数)    | 函数(或方法),几乎每个语言都会有的东西,用来实现特定的功能     |\n| userdata(自定义类型) | 一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用 |\n|     thread(线程)     | 类似于unity中的协程方法,不过unity是单线程的                                                                                                               在 Lua 里,最主要的线程是协同程序（coroutine),即协程。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。                                                                                           线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 |\n|      table(表)       | 类似于其他语言的数组array,数组的索引可以是数字,字符串,甚至是table本身,这个特点和其他语言一致 |\n\n\n\n### nil(空)\n\nnil 类型表示一种没有任何有效值，例如打印一个没有赋值的变量，便会输出一个 nil 值：\n\n比如我们用<font color='Red'>type</font>输出此时没有赋值的a,那么结果就是  nil\n\n```lua\nprint(type(a))\n```\n\n​\t<img src=\"第二天/image-20251218215324165.png\" alt=\"image-20251218215324165\" style=\"zoom:25%;\" />\n\n<font color='Red'>type</font>类似JavaScript和TypeScript里的typeof,可以输出变量的数据类型\n\n比如\n\n```lua\nprint(type(\"Hello world\"))      -- string\nprint(type(10.4*3))             -- number\nprint(type(print))              -- function\nprint(type(type))               -- function\nprint(type(true))               -- boolean\nprint(type(nil))                -- nil\nprint(type(type(X)))            -- string\n```\n\n​\t<img src=\"第二天/image-20251218215715884.png\" alt=\"image-20251218215715884\" style=\"zoom:33%;\" />\n\n\n\n同样的nil可以用来删除数据,这个先不提,等会讲到table表的时候再讲一下\n\n\n\n### boolean（布尔）\n\nboolean 类型只有两个可选值：true（真） 和 false（假）\n\nLua 把 false 和 nil 看作是 false，其他的（包括数字 0)都为 true\n\n这里涉及了if else语句,先不要管,先写了再说,这个其实表示判断,if  和 then之间的内容代表条件,满足条件执行上一条,不满足就是下一条\n\n```lua\nif false or nil then\n    print(\"至少有一个是true\")\nelse\n    print(\"false和nil都为false\")\nend\n\nif 0 then\n    print(\"0在Lua中被视为true\")\nelse\n    print(\"0在Lua中被视为false\")\nend\n```\n\n​\t<img src=\"第二天/image-20251218221300456.png\" alt=\"image-20251218221300456\" style=\"zoom:33%;\" />\n\n\n\n​\t哦,可能学过其他语言的会困惑第二个输出结果: 0为啥是真,好吧,也算是lua的特性\n\n​\t<img src=\"第二天/image-20251218221855925.png\" alt=\"image-20251218221855925\" style=\"zoom: 33%;\" />\n\n这里再扯一下其他语言中的情况(了解即可)\n\n​\t<img src=\"第二天/image-20251218222007218.png\" alt=\"image-20251218222007218\" style=\"zoom:33%;\" />\n\n​\t<img src=\"第二天/image-20251218222038262.png\" alt=\"image-20251218222038262\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"第二天/image-20251218222128775.png\" alt=\"image-20251218222128775\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"第二天/image-20251218222218181.png\" alt=\"image-20251218222218181\" style=\"zoom:50%;\" />\n\n​\t<img src=\"第二天/image-20251218222407529.png\" alt=\"image-20251218222407529\" style=\"zoom: 50%;\" />\n\n可以看出这些语言除了Java 和C#是强类型语言外,其他的大多数把0当做false\n\n\n\n### number(数字)\n\n```lua\nprint(type(2))\nprint(type(2.2))\nprint(type(0.2))\nprint(type(2e+1))\nprint(type(0.2e-1))\nprint(type(7.8263692594256e-06))\n```\n\n​\t<img src=\"第二天/image-20251218223512982.png\" alt=\"image-20251218223512982\" style=\"zoom:33%;\" />\n\n可以看到,无论是科学计数法还是整数小数都是表示number类型的\n\n这和C#,C,C++等等语言不一样,比如C# 整型是int  单精度浮点float  双精度浮点double\n\n### string(字符串)\n\n对了,lua的字符串拼接方式就是用两个点  ‘ <font color='Turquoise'>..</font> ’,除了C和C++以外其他的语言大多数都可以用“ + ”号来拼接字符串的\n\n```lua\nstring1 = \"基\"\t--写法一\nstring2 = '泥'\t--写法二\nstring3 = [[苔煤]]\t--写法三\nprint(string1 .. string2 .. string3)\n```\n\n​\t<img src=\"第二天/image-20251218225433463.png\" alt=\"image-20251218225433463\" style=\"zoom:25%;\" />\n\n哦,我们需要加一个<font color='Red'>local</font>关键字将其设置为局部变量\n\n这玩意作用就是:**声明一个仅当前范围可见的变量，避免污染外层**,大白话就是用local把变量设为局部私有\n\n​\t<img src=\"第二天/image-20251218233459562.png\" alt=\"image-20251218233459562\" style=\"zoom:33%;\" />\n\n\n\n对了,打印的方式我们也扯一下\n\n第一种:打印一句\n\n```lua\nprint(\"带不带派老铁\")\n```\n\n第二种:打印好几句\n\n```lua\nprint(\"太带派了\", \"雨姐\", \"大东北\", \"是我的家乡\")\n```\n\n第三种:换行打印\n\n```lua\nprint(\"小明剑魔曰:\\n你的评分是\\n3.0\")\n```\n\n第四种:自动字符串化(这个和python很像鹅)\n\n```lua\nlocal diamond = 10\nprint(\"玩家Steve开矿透挖到了:\", diamond..\"组钻石\")\n```\n\n第五种:格式化打印,使用  string.format() 方法\n\n这个需要了解一下这些符号,学过C  或者 C++的小伙伴绝对老熟悉了\n\n- `%s`: 字符串\n- `%d` 或 `%i`: 有符号整数\n- `%f`: 浮点数 (默认精度为 6 位小数)\n- `%c`: ASCII 字符\n- `%x` / `%X`: 十六进制数 (小写/大写)\n- `%%`: 输出一个字面量百分号\n\n```lua\nlocal age = \"未知\"\nlocal name = \"欧润吉\"\nprint(string.format(\"角色名称: %s, 年龄: %s\", name, age))\n```\n\n第六种:更自由的格式化打印(其实是自己设定的规则啦,即正则表达式)———先不了解,目前也用不上,看看就行啦\n\n这个有几种我喜欢用的,因为lua自带的格式化方法具有很多局限性\n\n第一种如下(功能最少,但勉强能用)\n\n```lua\n-- 定义一个自定义格式化函数\nlocal function formatString(fmt, tbl)\n    -- 使用 gsub 替换 %{key} 为对应的值\n    return (fmt:gsub(\"%%{(%w+)}\", function(key)\n        return tostring(tbl[key])\n    end))\nend\n\n-- 使用自定义格式化函数\nlocal data = {\n    name = \"刺客伍六七\",\n    gender = \"男\",\n    weapon = \"魔刀千刃\"\n}\n\nlocal formatted = formatString(\"姓名: %{name}, 性别: %{gender}, 专武: %{weapon}\", data)\nprint(formatted)\n```\n\n​\t<img src=\"第二天/image-20251221233542362.png\" alt=\"image-20251221233542362\" style=\"zoom:33%;\" />\n\n\n\n第二种如下(支持的功能增加一点,但是还是功能局限性)\n\n```lua\nlocal function formatString(fmt, tbl, default)\n    return (fmt:gsub(\"%%{([%w%-_]+)}\", function(key)\n        return tostring(tbl[key] or default)\n    end))\nend\n\nlocal data = {\n    user_name = \"梅花十三\",\n    user_age  = nil,\n    user_city = \"玄武国\"\n}\n\nlocal formatted = formatString(\"Name: %{user_name}, Age: %{user_age}, City: %{user_city}\", data, \"未知\")\nprint(formatted)\n```\n\n <img src=\"第二天/image-20251221234845870.png\" alt=\"image-20251221234845870\" style=\"zoom:33%;\" />\n\n\n\n第三种(专业级别的模版)\n\n```lua\n--------------------------------------------------\n-- 底层逻辑,负责字典格式化输出\n--------------------------------------------------\n\nlocal Template = {}\n\nlocal function getByPath(root, path)\n    local current = root\n    for key in path:gmatch(\"[^%.]+\") do\n        if type(current) ~= \"table\" then\n            return nil\n        end\n        local index = tonumber(key)\n        current = index and current[index] or current[key]\n    end\n    return current\nend\n\nfunction Template.format(text, context, options)\n    context = context or {}\n    options = options or {}\n    local default = options.default or \"\"\n\n    return (text:gsub(\"%%{([^}]+)}\", function(path)\n        local value = getByPath(context, path)\n\n        if value == nil then\n            return tostring(default)\n        end\n\n        if type(value) == \"function\" then\n            local ok, result = pcall(value, context)\n            return ok and tostring(result) or tostring(default)\n        end\n\n        return tostring(value)\n    end))\nend\n\n--------------------------------------------------\n-- 玩家数据\n--------------------------------------------------\n\nlocal data = {\n    weapons = {\n        weapon_01 = {\n            name = \"魔刀千刃\",\n            damage = 15000\n        },\n        weapon_02 = {\n            name = \"激光炮\",\n            damage = 8000\n        }\n    },\n\n    character = {\n        player_01 = {\n            name = \"伍六七\",\n            camp = \"玄武国\",\n            base_power = 100,\n            weapon = \"weapon_01\"\n        },\n\n        player_02 = {\n            name = \"斯特国王子\",\n            camp = \"斯特国\",\n            base_power = 100,\n            weapon = \"weapon_02\"\n        }\n    }\n}\n\n--------------------------------------------------\n-- 角色信息注入\n--------------------------------------------------\n\nlocal function injectActor(actor, ctx)\n    return {\n        --角色名字\n        name = function()\n            return actor.name or \"未知\"\n        end,\n\n        --角色阵营\n        camp = function()\n            return actor.camp or \"未知\"\n        end,\n\n        --角色专武\n        weapon = function()\n            if actor.weapon then\n                local w = ctx.weapons[actor.weapon]\n                return w and w.name or \"未知\"\n            end\n            return \"未知\"\n        end,\n\n        --角色武力\n        power = function()\n            local weapon_damage = 0\n            if actor.weapon then\n                local w = ctx.weapons[actor.weapon]\n                weapon_damage = w and w.damage or 0\n            end\n            return ((actor.base_power or 0) + (weapon_damage or 0)) or \"未知\"\n        end\n    }\nend\n\n--------------------------------------------------\n-- 我方和敌方\n--------------------------------------------------\n\nlocal context_ally = {\n    actor = injectActor(data.character.player_01, data)\n}\n\nlocal context_enemy = {\n    actor = injectActor(data.character.player_02, data)\n}\n\n--------------------------------------------------\n-- 信息打印\n--------------------------------------------------\n\n-- 决战双方揭晓\nprint(Template.format(\n    \"决战双方：%{character.player_01.name} VS %{character.player_02.name}\\n\",\n    data\n))\n\n--双方信息展示\nlocal tpl = \"角色：%{actor.name}\\n阵营：%{actor.camp}\\n武力：%{actor.power}\\n专武：%{actor.weapon}\\n\\n\"\nprint(Template.format(tpl, context_ally))\nprint(Template.format(tpl, context_enemy))\n\n```\n\n​\t<img src=\"第二天/image-20251222203855065.png\" alt=\"image-20251222203855065\" style=\"zoom:33%;\" />\n\n\n\n\n\n咳咳咳,扯太远了\n\n对了,如你所见,刚才这个”     string1 = \"基\"   ”字符串我只取名为变量名string1,没有显示声明这是字符串string类型,而是用local关键字\n\n补充一下(变量的作用域):\n\n- **写在函数/方法/语句块体外** → <font color='Red'>全局（整个文件、整个程序可见）变量</font>\n\n- **写在函数/方法/语句块体内** → <font color='Red'>局部（只在那个函数/块内部可见）变量</font>\n\n  \n\n  最好的例子就是Java和C#里的public和private关键字\n\n  这里我们就用  Unity 游戏引擎里的C#讲解一下吧\n  \n  ```\n  //unity脚本\n  using UnityEngine;\n  \n  public class PlayerLogic : MonoBehaviour\n  {\n     public int hp = 100;        // 外部可访问,公开变量\n     private int speed = 5;      // 仅类内部使用,外部不可调用,private可以省略不写,私有变量\n  \n     void Start()\n      {\n          Debug.Log(hp);\n          Debug.Log(speed);\n      }\n  \n  \t//随便写一个方法\n      public void Move()\n      {\n          Debug.Log(\"Move with speed \" + speed);\n      }\n  }\n  ```\n  \n  如你所见,public 可以让整个项目的所有脚本都可以获取这个变量,private只能让当前脚本使用这个变量\n  \n  \n  \n  我们的lua也是这样的,如果不给变量或者方法加local关键字,则默认就是全局公开的,这一点和unity的C#是相反的,C#不加关键字就是默认是局部私有的\n  \n  \n  \n  \n  \n  对了,.在C,java,C#,C++里都会给变量指定一个数据类型例如整型int  字符串string  浮点型float或double等等\n\n```java\nint apple =2;\nvar banana =4;//仅局部变量可用var\n```\n\n```c#\nint apple=2;\nvar banana =4;//仅局部变量可用var\n```\n\n```c++\nint apple =2;\nauto apple = 2;  //全局局部都可以用auto\n```\n\n```c\nint apple =2;\n```\n\n对于某些则是可以指定也可以不指定,比如python和TypeScript还有godot的GDscript\n\n```python\napple: int = 2 #python可以直接写变量名,没有var或let这种关键字\n```\n\n```typescript\nlet apple: number = 2;\n```\n\n```\n#GDscript\nvar apple: int = 2  \n```\n\n对于lua这种不需要写数据类型的,称之为“<font color='Turquoise'>变量本身无类型，值自带类型</font>”,其中和JavaScript最像,JS也是用let(曾经是var)来充当所有类型的,同样的不可以也没有途径来指定变量类型,全靠编辑器或游戏引擎自己  “猜”  这是什么类型\n\n```javascript\nlet apple = 2;//旧版是var apple =2;\n```\n\n\n\n\n\n对了,由于数据类型之间存在隐式转换,这个在大多数语言之中都存在,就是我们常说的强制转换和隐式转换\n\n这里我们就先举例字符串和数字类型的相加吧\n\n```lua\n--可以看出Lua会自动将字符串转换为数字,这称为隐式转换\n--然后进行加法运算\nprint(\"2\" + 6)\n```\n\n​\t<img src=\"第二天/image-20251220185808133.png\" alt=\"image-20251220185808133\" style=\"zoom: 33%;\" />\n\n同理,也可以字符串和字符串相加,不过在java和C#中字符串相加结果还是字符串\n\n```java\nSystem.out.println(\"123\" + 5);   // 输出 \"1235\"\nSystem.out.println(\"123\" + 5 + 5); // 输出 \"12355\"\nSystem.out.println(5 + 5 + \"123\"); // 输出 \"10123\"（先算 5+5）\n```\n\n```c#\nConsole.WriteLine(\"123\" + 5);   // 输出 \"123\"\nConsole.WriteLine(\"123\" + 5 + 5); // 输出 \"12355\"\nConsole.WriteLine(5 + 5 + \"123\"); // 输出 \"10123\"\n```\n\n但是我们的Lua不是这样的,它只会先将字符串转换为数字,然后在进行数学运算,所以就有了如下结果\n\n```lua\nprint(\"2\" + \"6\") --输出 \"8\"\nprint(\"-2e2\" * \"6\") --输出 \"-1200.0\"\n```\n\n但是我们都知道字符串不只有数字可以构成,还可以由各个国家的文字构成比如中文  英文  日文\n\n所以lua自然无法将文字转换为数字(不过你可能听说过ASCII码表和Unicode字符表,每个文字或符号都有对应的数字编号),但字符串相加减在Lua中不允许的\n\n​\t<img src=\"第二天/image-20251220191224658.png\" alt=\"image-20251220191224658\" style=\"zoom: 25%;\" />\n\n可以看到,报错了\n\n同样的,假如你学过C  java  JavaScript什么的,都知道字符串长度这个概念,即字符串字节长度，学过的小伙伴可以再看一下\n\n其中字节我们需要了解一下\n\n​\t<img src=\"第二天/image-20251220203217551.png\" alt=\"image-20251220203217551\" style=\"zoom:33%;\" />\n\n还有码点和单元的概念\n\n​\t<img src=\"第二天/image-20251220203803350.png\" alt=\"image-20251220203803350\" style=\"zoom:33%;\" />\n\n```C\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    \n    // 情形 1：假设执行字符集是 GBK，源文件也用 GBK 保存\n    // 每个汉字占 2 字节，11 个汉字 -> 22 字节，加结尾 '\\0' -> 23\n    char str_gbk[] = \"芙宁娜喂你吃了一口蛋糕\";\n    printf(\"[GBK] 字符串长度为 = %zu\\n\", sizeof(str_gbk)); // 23\n    printf(\"[GBK] 字符串长度为 = %zu\\n\", strlen(str_gbk)); // 22\n\n    // 情形 2：强制 UTF-8 字面量（u8 前缀），与源文件是否 UTF-8 无关\n    // 每个汉字 3 字节，11 个汉字 -> 33 字节，加结尾 '\\0' -> 34\n    const char *s_utf8 = u8\"芙宁娜喂你吃了一口蛋糕\";\n    printf(\"[UTF-8] 字符串长度为 = %zu\\n\", strlen(s_utf8));                  // 33\n    printf(\"[UTF-8] 字符串长度为 = %zu\\n\", sizeof u8\"芙宁娜喂你吃了一口蛋糕\"); // 34 (含 '\\0')\n\n    return 0;\n}\n```\n\n```c++\n#include <string>\n#include <iostream>\n\nint main() {\n    // 情形 1：假设执行字符集是 GBK，源文件也用 GBK 保存\n    std::string s_gbk = \"芙宁娜喂你吃了一口蛋糕\";\n    std::cout <<\"[GBK] 字符串长度为\"<< s_gbk.size() << \" \\n\";  //22字节\n    \n    // 情形 2：强制 UTF-8 字面量（u8 前缀），与源文件是否 UTF-8 无关\n    std::string s_utf8 = u8\"芙宁娜喂你吃了一口蛋糕\";\n    std::cout <<\"[UTF-8] 字符串长度为\"<< s_utf8.size() << \"\\n\"; // 33字节\n}\n```\n\n```java\n//java伪代码\nString s = \"芙宁娜喂你吃了一口蛋糕\";\nint units = s.length();                          \nSystem.out.println(\"字符串的长度为: \" + units); // 11（UTF-16 代码单元）,每个汉字一个单元,Java源码默认 UTF-8\n```\n\n```c#\n//C#伪代码\nstring s = \"芙宁娜喂你吃了一口蛋糕\";\nint units = s.Length; \nConsole.WriteLine($\"字符串长度为= {units}\"); // 11（UTF-16 代码单元）,每个汉字一个单元,C#源码默认 UTF-8\n```\n\n```javascript\nconst s = \"芙宁娜喂你吃了一口蛋糕\";\nconst len = s.length;\nconsole.log(`字符串长度为 = ${len}`);   // 11（UTF-16 代码单元）,每个汉字一个单元,JS源码默认 UTF-8\n```\n\n```python\ns = \"芙宁娜喂你吃了一口蛋糕\"\nln = len(s)\nprint(f\"字符串长度为 = {ln}\")  # 11 (Unicode 码点),每个汉字是一个码点,python源码默认 UTF-8，len函数返回码点数\n```\n\nok ,现在再来看看我们的lua\n\nlua使用 <font color='Red'>#</font> 来计算字符串的长度，放在字符串前面,或者使用   <font color='Red'>string.len()</font>  来获取字符串的长度\n\n```lua\nlocal le = \"芙宁娜喂你吃了一口蛋糕\"\n\n--注意,Lua 本身把字符串当作原始字节序列，不做任何编码/解码,所以字节取决于你当前文件的保存格式是UTF-8还是GBK\nprint(\"字符串长度\" .. #le) --33字节 (UTF-8字节)  22(GBK字节)\nprint(\"字符串长度\" ..string.len(le))--33字节 (UTF-8字节)  22(GBK字节)\nprint(\"码点数\", utf8.len(le)) -- 11(Unicode 码点)\n```\n\n <img src=\"第二天/image-20251220211553480.png\" alt=\"image-20251220211553480\" style=\"zoom:33%;\" />\n\n​\t<img src=\"第二天/image-20251220214021468.png\" alt=\"image-20251220214021468\" style=\"zoom:33%;\" />\n\n或者这样写,都是可以的\n\n```lua\nlocal len = #\"芙宁娜喂你吃了一口蛋糕\"\nprint(\"字符串长度\" .. len)--33字节\n```\n\n​\t<img src=\"第二天/image-20251220211507010.png\" alt=\"image-20251220211507010\" style=\"zoom:33%;\" />\n\n### table(表)\n\n这个和其他语言的数组非常类似,同样的也和JSON里面的字典非常像\n\n所以同样的也存在<font color='Red'>索引</font>和<font color='Red'>键值对</font>这个概念,数组的索引只能是数字或者是字符串,但是字典的键值对可以是数字、字符串、布尔值、函数，甚至是另一个 table\n\n但是别的语言的索引是从0开始的,数组的第一个元素的位置就是0索引,但是在我们的lua中,不是这样的,而是第一个元素的位置是1索引\n\n这里我们先用for循环遍历一下数组索引，可以看到的确是第一个索引位置是   <font color='Red'>1</font>     \n\n​\t<img src=\"第二天/image-20251221190243229.png\" alt=\"image-20251221190243229\" style=\"zoom:33%;\" />\n\n```lua\nlocal tbl = { \"apple\", \"pear\", \"orange\", \"grape\" }\nfor key, val in pairs(tbl) do\n    print(\"Key\", key)\nend\n```\n\n同样的,数组可以为空,然后为空数组的索引位置赋值,也可以在创建数组时就为数组赋值,这里可以直接对索引位置赋值或者使用插入函数\n\n#### 一:使用<font color='Red'>数组索引</font>或者<font color='Red'>键值对</font>赋值\n\n比如我可以直接在数组中添加元素,或者在指定索引位置添加元素,用索引获取数组元素用   <font color='Red'>数组名[  数字(大于等于1)  ]</font>\n\n但是你可以看到表里的“邦德福杰”和“达米安戴斯蒙”的写法是不是很熟悉(如果你学过字典的写法的话),没错,table还可以用于写字典\n\n字典可以使用点符号“ <font color='Red'>.</font> ”来访问字典中的属性比如   <font color='Red'>spyfamily.x</font>  就是指“邦德福杰”   不过也可以不用这个点,第二种写法如你所见,但是不是很推荐就是了(因为麻烦,还得多打几个符号)\n\n这个字典非常好用的,以后我们给游戏人物写属性时可以使用字典,不过你也看到了,数组和字典可以混用(不过不推荐这么干 ヾ(▼へ▼) NO!)\n\n```lua\nlocal spyfamily = { \"阿尼亚福杰\", \"劳埃德福杰\", \"约尔福杰\", x = \"邦德福杰\", y = \"达米安戴斯蒙\" } -- 1-based 索引\nspyfamily[4] = \"贝姬布莱克贝\"\nspyfamily[\"z\"] = \"尤里布莱尔\"\n\nprint(spyfamily[1], spyfamily[2], spyfamily[3], spyfamily[4])\nprint(spyfamily.x, spyfamily[\"y\"], spyfamily[\"z\"])\n```\n\n​\t<img src=\"第二天/image-20251221192607903.png\" alt=\"image-20251221192607903\" style=\"zoom:33%;\" />\n\n至于数组的遍历先不了解,因为涉及for循环,到时候讲到for循环时候再说更好理解,我们暂时还是用print一个一个的打印\n\n前面我们提到过  nil具有删除效果 我们来看一下吧\n\n```lua\nlocal spyfamily = { Anya = \"阿尼亚福杰\", Loid = \"劳埃德福杰\", Yor = \"约尔福杰\", Bond = \"邦德福杰\", Damian = \"达米安戴斯蒙\" } \nspyfamily.Becky = \"贝姬布莱克贝\"\nspyfamily.Fiona = \"菲奥娜弗洛斯特\"\nspyfamily.Yuri = \"尤里布莱尔\"\n\nprint(\"删除前:\")\n\n--遍历表\nfor k, v in pairs(spyfamily) do\n    print(k, v)\nend\n\nprint(\"删除后:\")\n\n--比如我们要删除劳埃德和邦德\nspyfamily.Loid = nil\nspyfamily.Bond = nil\n\n--遍历表\nfor k, v in pairs(spyfamily) do\n    print(k, v)\nend\n```\n\n​\t<img src=\"第二天/image-20251221200825641.png\" alt=\"image-20251221200825641\" style=\"zoom:33%;\" />\n\n可以看到  劳埃德和邦德没有了\n\n有些小伙伴可能会突发奇想——诶,假如我把table写成字典格式那还能不能使用索引访问呢\n\n如图所示,不可以,只能用字典的两种访问形式(即点语法和键值对)\n\n而且在 Lua 中，`table` 的 **<font color='Red'>数字索引</font>** 和 **<font color='Red'>键值对</font>** 是分开的。当表中只有字典的键值对时，**数字索引部分是空的**。\n\n```lua\nlocal spyfamily = { Anya = \"阿尼亚福杰\", Loid = \"劳埃德福杰\", Yor = \"约尔福杰\", Bond = \"邦德福杰\", Damian = \"达米安戴斯蒙\" } \nspyfamily.Becky = \"贝姬布莱克贝\"\nspyfamily.Fiona = \"菲奥娜弗洛斯特\"\nspyfamily.Yuri = \"尤里布莱尔\"\n\n--正常打印\nprint(spyfamily.Anya, spyfamily.Loid, spyfamily.Yor, spyfamily.Bond)\n--结果打印 nil\nprint(spyfamily[1], spyfamily[2], spyfamily[3], spyfamily[4])\n--正常打印\nprint(spyfamily[\"Anya\"], spyfamily[\"Loid\"], spyfamily[\"Yor\"], spyfamily[\"Bond\"])\n\n```\n\n​\t<img src=\"第二天/image-20251221201716415.png\" alt=\"image-20251221201716415\" style=\"zoom:33%;\" />\n\n想必你也看到了,table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil\n\n\n\n#### 二:使用<font color='Red'>lua内置函数</font>赋值\n\n函数这个后面会说，这里我们先介绍一下table相关的一些函数\n\n```lua\n-- 创建一个空的 table\nlocal tbl1 = {}\n-- 向表中添加元素\ntable.insert(tbl1, \"胡桃\")\ntable.insert(tbl1, \"茜特菈莉\")\ntable.insert(tbl1, \"纳西妲\")\ntable.insert(tbl1, \"芙宁娜\")\nprint(\"tbl1 的内容：\" .. table.concat(tbl1, \", \"))\n\n\n-- 直接初始表\nlocal tbl2 = { \"胡桃\", \"茜特菈莉\", \"纳西妲\", \"芙宁娜\" }\n\nprint(\"tbl2 的内容：\" .. table.concat(tbl2, \", \"))\n```\n\n​\t<img src=\"第二天/image-20251221190833186.png\" alt=\"image-20251221190833186\" style=\"zoom:33%;\" />\n\n\n\n|                    函数                     |           作用           |\n| :-----------------------------------------: | :----------------------: |\n| <font color='Turquoise'>table.insert</font> |      向表中插入元素      |\n| <font color='Turquoise'>table.remove</font> |      从表中删除元素      |\n| <font color='Turquoise'>table.concat</font> | 将表中的元素连接成字符串 |\n|  <font color='Turquoise'>table.sort</font>  |   对表中的元素进行排序   |\n|  <font color='Turquoise'>table.pack</font>  |   将多个值打包成一个表   |\n| <font color='Turquoise'>table.unpack</font> |  将表中的值解包成多个值  |\n\n第一个:   table.insert\n\n- **语法**：`table.insert(表名, 插入位置, 插入值)`\n- 其中插入位置可写可不写,不写的话默认插入到表的末尾\n\n```lua\nlocal player = { \"豌豆射手\", \"寒冰射手\", \"土豆地雷\" }\n\ntable.insert(player, \"火焰射手\")\ntable.insert(player, 2, \"向日葵\")\n\nprint(table.concat(player, \", \"))\n```\n\n​\t<img src=\"第二天/image-20251221215101801.png\" alt=\"image-20251221215101801\" style=\"zoom:33%;\" />\n\n第二个:   table.remove\n\n- **语法**：`table.insert(表名, 删除位置)`\n- 其中删除位置可写可不写,不写的话默认删除表的末尾元素\n\n```lua\nlocal player = { \"豌豆射手\", \"寒冰射手\", \"土豆地雷\", \"火焰射手\" }\n\ntable.remove(player)\ntable.remove(player, 2)\n\nprint(table.concat(player, \", \"))\n```\n\n​\t<img src=\"第二天/image-20251221215823550.png\" alt=\"image-20251221215823550\" style=\"zoom:33%;\" />\n\n第三个:   table.concat\n\n- **语法**：`table.concat(表名, 连接符, 开始索引, 结束索引)`\n- 其中连接符默认为空字符串,连接符一般是逗号或者空格\n- 开始索引和结束索引表示遍历的范围,不写的话默认是遍历整个表\n\n```lua\nlocal player = { \"豌豆射手\", \"寒冰射手\", \"土豆地雷\", \"火焰射手\" }\n\nprint(table.concat(player))\nprint(table.concat(player, \", \"))\nprint(table.concat(player, \",\", 2, 3))\n```\n\n​\t<img src=\"第二天/image-20251221221157964.png\" alt=\"image-20251221221157964\" style=\"zoom:33%;\" />\n\n第四个:   table.sort\n\n- **语法**：`table.sort(表名, 排序函数)`\n- 比较函数，默认按升序排序\n\n```lua\nlocal number = { 1, 1, 4, 5, 1, 4 }\n\n-- 默认排序（升序）\ntable.sort(number)\nprint(table.concat(number, \", \")) \n\n-- 自定义排序（降序）\ntable.sort(number, function(a, b) return a > b end)\nprint(table.concat(number, \", \")) \n```\n\n​\t<img src=\"第二天/image-20251222222825992.png\" alt=\"image-20251222222825992\" style=\"zoom:33%;\" />\n\n第五个和第六个:   table.pack    table.unpack\n\n- **语法**：`table.pack(....)`\n- **语法**：`table.unpack(压缩的包名,开始索引,结束索引)`\n- **注意啦:**这两个<font color='Red'>只处理数组</font>,不处理字典的键值对\n\n```lua\n--也就是用pack把多个值压缩成一个表\nlocal packed = table.pack(\"点赞\", \"关注\", \"收藏\")\nprint(table.concat(packed, \", \")) -- 输出: 点赞, 关注, 收藏\n\n--然后我们可以用unpack把表中的值再解压出来\n--默认全部解压\nlocal like, follow, favorite = table.unpack(packed)\nprint(like, follow, favorite) -- 输出: 点赞 关注 收藏\n\n--也可以指定解压的范围\nlocal like2, follow2 = table.unpack(packed, 1, 2)\nprint(like2, follow2) -- 输出: 点赞 关注\n\n--由于压缩后本质上是表，所以我们还可以访问表的属性,比如索引对应的值\nprint(packed[1]) -- 输出: 点赞\n```\n\n​\t<img src=\"第二天/image-20251221224942807.png\" alt=\"image-20251221224942807\" style=\"zoom:33%;\" />\n\n对了,还有一些可以补充的\n\n比如\"#\"操作符不仅可以用于获取字符串的长度,还可以用于获取表的长度\n\n```lua\n--也就是用pack把多个值压缩成一个表\nlocal packed = table.pack(\"点赞\", \"关注\", \"收藏\")\nprint(table.concat(packed, \", \")) -- 输出: 点赞, 关注, 收藏\n\n--注意,这个\".n\"是table.pack特有的属性,表示表中元素的数量\nprint(\"总元素数量:\", packed.n) -- 输出: 总元素数量: 3\n\n--刚才说了,这个压缩包本质上还是一个表,所以你也可以用\"#\"操作符来获取元素数量\nprint(\"总元素数量:\", #packed) -- 输出: 总元素数量: 3\n```\n\n​\t<img src=\"第二天/image-20251221225822879.png\" alt=\"image-20251221225822879\" style=\"zoom:33%;\" />\n\n### function（函数）\n\n学过JavaScript的小伙伴绝对老熟悉了,因为JavaScript的函数返回值类型也是用function来代替,而在其他语言中函数前面基本上就是函数的返回值类型比如 int 或void等等,对于没学过JS的小伙伴也可以看看这两个语言有多相似\n\n但所有主流语言的函数基本上逻辑差不多,lua自然也有有参函数,无参函数或匿名函数等等区别\n\n#### 一,无参函数\n\n- **语法**：`function 函数名()...end`或`函数名 = function()...end`\n- 注意:在其他语言中是用{ }花括号来规定函数的作用域的,但是lua这种缩进式语言需要 <font color='Red'>end</font> 这种关键字来指定函数结束位置\n- local关键字可写可不写,要写都写,要不写都不写这样比较好看一些\n- 匿名函数在lua中也十分常用的,匿名函数可以不写函数名直接使用整个函数即可,一般可以在return返回值用匿名函数来节省代码长度\n\n```lua\nlocal function HK()\n    print(\"低调的黑客\")\nend\n\n--等价于(匿名函数)\nlocal DK = function()\n    print(\"低客的黑调\")\nend\n\n\n--对于无参函数直接写函数名即可调用\nHK()\nDK()\n```\n\n​\t<img src=\"第二天/image-20251222220743297.png\" alt=\"image-20251222220743297\" style=\"zoom:33%;\" />\n\n你可以对比一下JS语言,是不是豁然开朗了\n\n```javascript\nfunction HK() {\n    console.log(\"低调的黑客\");\n}\n// 等价于(匿名函数)\nlet DK = function () {\n    console.log(\"低客的黑调\");\n}\n\nHK();\nDK();\n```\n\n#### 二,有参无返回值函数\n\n- **语法**：`function 函数名(参数A,参数B...)...end`或`函数名 = function(参数A,参数B...)...end`\n- **函数调用**: `函数名(参数A,参数B...)`\n\n```lua\nlocal function HK(a, b)\n    print(a .. \"不是低调的\" .. b)\nend\n\n--等价于(匿名函数)\nlocal DK = function(a, b)\n    print(a .. \"是低客的\" .. b)\nend\n\n\n--对于有参函数需要写参数值,但需要和定义的位置对应\nHK(\"嘉豪\", \"黑客\")\nDK(\"艾鲁迪克\", \"黑调\")\n```\n\n​\t<img src=\"第二天/image-20251222222254607.png\" alt=\"image-20251222222254607\" style=\"zoom:33%;\" />\n\n#### 三,有参有返回值函数\n\n这个分为单个返回值和多个返回值\n\n第一:单个返回值\n\n- **语法**：`function 函数名(参数A,参数B...)...return 返回值 end`或`函数名 = function(参数A,参数B...)...return 返回值 end`\n- **函数调用**: `变量名 = 函数名(参数A,参数B...)`   注意,调用形式相对自由,我只说这一种最简格式\n- 关键字注意: return 关键字是函数的返回值的类型 不过lua函数返回值相当宽松,不会像其他语言那样函数的类型和返回值类型之间锁死,返回值类型非常广泛甚至可以是另一个函数或匿名函数\n\n```lua\nlocal function HK(a, b)\n    local friendshipsPlainJane = a .. \"不是低调的\" .. b\n    return friendshipsPlainJane\nend\n\n--等价于(匿名函数)\nlocal DK = function(a, b)\n    local friendshipsPlainJane = a .. \"是低客的\" .. b\n    return friendshipsPlainJane\nend\n\n\n--对于有参函数需要写参数值,但需要和定义的位置对应\nlocal hacker = HK(\"嘉豪\", \"黑客\")\nlocal dicker = DK(\"艾鲁迪克\", \"黑调\")\nprint(hacker)\nprint(dicker)\n```\n\n​\t<img src=\"第二天/image-20251223113241497.png\" alt=\"image-20251223113241497\" style=\"zoom:33%;\" />\n\n第二:多个返回值\n\n- **语法**：`function 函数名(参数A,参数B...)...return 返回值1,返回值2... end`或`函数名 = function(参数A,参数B...)...return 返回值1,返回值2... end`\n- **函数调用**: `变量名A,变量名B... = 函数名(参数A,参数B...)`   注意,调用形式相对自由,我只说这一种最简格式\n\n```lua\nlocal function HD(a, b)\n    local friendshipsPlainJane_01 = a .. \"不是低调的\" .. b\n    local friendshipsPlainJane_02 = b .. \"是低调的\" .. a\n    return friendshipsPlainJane_01, friendshipsPlainJane_02\nend\n\n--对于有参函数需要写参数值,但需要和定义的位置对应\nlocal hacker, dicker = HD(\"黑客\", \"艾鲁迪克\")\nprint(hacker)\nprint(dicker)\n```\n\n​\t<img src=\"第二天/image-20251223115913725.png\" alt=\"image-20251223115913725\" style=\"zoom:33%;\" />\n\n哦,对了,提起多个变量接收返回值的就得提一下lua变量的某些性质了——比如变量和值的个数不一致的情况\n\n第一种:\n\n变量个数 > 值的个数             按变量个数补足nil\n\n```lua\nlocal a = function(name)\n    return name\nend\n\nlocal b = function(name)\n    return name\nend\n\nlocal friendshipsPlainJane_01 = function(x, y)\n    return a(x) .. \"不是低调的\" .. b(y)\nend\n\nlocal friendshipsPlainJane_02 = function(x, y)\n    return b(x) .. \"是低调的\" .. a(y)\nend\n\nlocal hacker, dicker, fxxker = friendshipsPlainJane_01(\"嘉豪\", \"黑客\"), friendshipsPlainJane_02(\"艾鲁迪克\", \"迪克\")\n\nprint(hacker)\nprint(dicker)\nprint(fxxker)\n```\n\n <img src=\"第二天/image-20251224103930019.png\" alt=\"image-20251224103930019\" style=\"zoom:33%;\" />\n\n第二种:\n\n变量个数 < 值的个数             多余的值会被忽略\n\n​\t<img src=\"第二天/image-20251224102019857.png\" alt=\"image-20251224102019857\" style=\"zoom:33%;\" />\n\n\n\n\n\n### thread(线程)\n\n线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n\n知道即可,目前没必要了解这个,等讲到协程时再说更好理解\n\n### userdata（自定义类型）\n\n一些小伙伴呢可能听说过甚至使用过  Raylib库 做过游戏,而userdata作用也是一样的,这么讲你应该可以瞬间理解吧\n\n**userdata 就是 Lua 与 C/C++ 之间的“透明快递箱”**——脚本层面只负责传递，真正的内容、行为、生命周期全由 C或者C++ 定义，通过元表让 Lua 看起来像普通对象\n\n说人话就是C或C++写外部库,lua用userdata类型调用这个库\n\n目前的话用不上,了解即可\n","tags":["love2d","lua"],"categories":["游戏开发"]},{"title":"love2d学习第一天--配置love2d环境和lua的环境","url":"/2025/12/13/游戏引擎相关/Love2d引擎/第一天/","content":"\n# 配置love2d环境和lua的环境\n\n## 这个教程大家不要把我当做专业的lua大佬,这其实是我个人的学习笔记,我只是习惯以给别人讲述的方式学习新知识,毕竟我也是第一次学lua,望周知~(￣0￣)/ \n\n## 1——love2d引擎下载\n\n首先我们进入love2d的官方网站下载love2d引擎\n\n[<font color='Red'>点击此处下载love2d引擎</font>](https://www.love2d.org/)\n\n<img src=\"第一天/image-20251213180610057.png\" alt=\"image-20251213180610057\" style=\"zoom: 33%;\" />\n\n选择你对应的电脑配置进行下载即可\n\n下载完成之后你会发现,这个引擎不像Unity,UnrealEngine和Godot那样拥有复杂的界面,而是一个这个样子,什么都没有,也就是说这就是一个框架\n\n<img src=\"第一天/Snipaste_2025-12-13_18-55-32.jpg\" alt=\"Snipaste_2025-12-13_18-55-32\" style=\"zoom: 33%;\" />\n\n在<font color='Red'>设置</font>里找到<font color='Red'>系统</font>><font color='Red'>系统信息</font>><font color='LightSkyBlue'>高级系统设置</font>  \n\n<img src=\"第一天/image-20251213190502566.png\" alt=\"image-20251213190502566\" style=\"zoom: 33%;\" />\n\n\n\n点击进入会弹出一个窗口\n\n​\t<img src=\"第一天/image-20251214225419298.png\" alt=\"image-20251214225419298\" style=\"zoom:50%;\" />\n\n点击<font color='LightSkyBlue'>环境变量</font>\n\n​\t<img src=\"第一天/image-20251214225648823.png\" alt=\"image-20251214225648823\" style=\"zoom: 33%;\" />\n\n首先点击<font color='Turquoise'>  Path </font> >  <font color='Turquoise'>编辑</font>\n\n​\t<img src=\"第一天/image-20251214225830224.png\" alt=\"image-20251214225830224\" style=\"zoom:33%;\" />\n\n\n\n因为Windows频繁更新可能会找不到在哪改系统路径 我们可以直接\n\n<font color='Red'>win + R</font>  在窗口输入  **`sysdm.cpl`**后点击  上方的  <font color='Red'>高级</font>   >   <font color='Red'>环境变量</font>  就能打开\n\n```\nsysdm.cpl\n```\n\n​\t<img src=\"第一天/image-20251225212854518.png\" alt=\"image-20251225212854518\" style=\"zoom:50%;\" />\n\n\n\n然后点击新建   将你电脑上刚刚下载的Love2d引擎的位置 粘贴进去\n\n比如我放在了D:\\Love2D\\LOVE\\位置     记住路径末尾的   “  <font color='Red'> \\  </font> ”   符号也要加上\n\n然后点击<font color='Red'>确定</font>保存设置\n\n​\t<img src=\"第一天/image-20251214230058175.png\" alt=\"image-20251214230058175\" style=\"zoom:33%;\" />\n\n然后我们输入  <font color='Red'>Win  +  R </font>  后在窗口中输入<font color='Red'>cmd</font>\n\n​\t<img src=\"第一天/image-20251214230421277.png\" alt=\"image-20251214230421277\" style=\"zoom:33%;\" />\n\n如图所示,我们在控制台输入<font color='Red'>love</font>小写字母并回车,就会启动love2d引擎,代表此时路径配置正确,否则会显示love不存在\n\n​\t<img src=\"第一天/image-20251214230744158.png\" alt=\"image-20251214230744158\" style=\"zoom:33%;\" />\n\n## 2—–VScode编辑器配置\n\n虽然写代码可以使用不同的工具,甚至可以用记事本,不过我们就不给自己挖坑了,还是用VScode最顺手\n\n没有VScode的可以点击此处下载,怎么配置就不说了,哔哩哔哩和Youtube教程一大把\n\n​\t<img src=\"第一天/image-20251214231435460.png\" alt=\"image-20251214231435460\" style=\"zoom:50%;\" />\n\n[<font color='LightSkyBlue'>点击前往官网下载VScode</font>](https://code.visualstudio.com/)\n\n由于VScode具有高度的可拓展性,所以我们可以装很多插件\n\n我们需要点击这个方块一样的玩意\n\n​\t<img src=\"第一天/image-20251214231828518.png\" alt=\"image-20251214231828518\" style=\"zoom:33%;\" />\n\n一般它会给你推荐一些比较火的插件,额,你可以看着下载,哔哩哔哩上有很多人会给你推荐一些比较好的插件\n\n因为我比较喜欢二次元壁纸所以我推荐你下载这个插件(因为直接无脑使用就可以了,有的时候VScode自动更新需要手动重新加载一下这个插件)\n\n### 插件名:<font color='Turquoise'>background-cover</font>\n\n​\t<img src=\"第一天/image-20251214232229803.png\" alt=\"image-20251214232229803\" style=\"zoom:33%;\" />\n\n还有这个汉化包\n\n### 插件名:<font color='Turquoise'>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</font>\n\n​\t<img src=\"第一天/image-20251214232503463.png\" alt=\"image-20251214232503463\" style=\"zoom:33%;\" />\n\n还有主题拓展包(可以让UI变得好看)\n\n### 插件名:\t<font color='Turquoise'>vscode-icons</font>\n\n​\t<img src=\"第一天/image-20251215110514223.png\" alt=\"image-20251215110514223\" style=\"zoom:33%;\" />\n\n然后就是和Love2d和lua有关的插件了\n\n下面我会一一介绍的(当然不用也可以,插件只是辅助啦)\n\n### 第一个:<font color='Turquoise'>Code Runner</font>(必备)\n\n其实就是在VScode中运行各种语言的代码,你可以右键选择run code运行脚本\n\n​\t<img src=\"第一天/image-20251214232629063.png\" alt=\"image-20251214232629063\" style=\"zoom: 25%;\" />\n\n​\t<img src=\"第一天/image-20251216133559087.png\" alt=\"image-20251216133559087\" style=\"zoom:33%;\" />\n\n### 第二个:<font color='Turquoise'>GitHub Copilot Chat</font>\n\n这个必须得有,AI辅助写代码的东西,就是代码自动补全,毕竟我们也不是进击的码农对吧(当然是游戏开发者啦)\n\n​\t<img src=\"第一天/image-20251214232945728.png\" alt=\"image-20251214232945728\" style=\"zoom: 25%;\" />\n\n### 第三个: <font color='Turquoise'>Love2d Made Easy</font>\n\n这个呢可以快速的在VScode中启动Love2d引擎的,下载后右上角就会出现一个小爱心图标\n\n​\t<img src=\"第一天/image-20251214233227579.png\" alt=\"image-20251214233227579\" style=\"zoom:25%;\" /><img src=\"第一天/image-20251214233306850.png\" alt=\"image-20251214233306850\" style=\"zoom: 50%;\" />\n\n我来演示一遍\n\n首先新建一个<font color='Red'>main.lua</font>脚本（必须是这个名字,否则无法启动)输入以下代码,再点击右上角的小爱心,稍等片刻Love2d引擎就会启动并弹出结果—-即在引擎画面上显示一个白色长方体\n\n```lua\nfunction love.draw()\n    love.graphics.rectangle(\"fill\", 10, 100, 120, 80)\nend\n```\n\n​\t<img src=\"第一天/image-20251214233727780.png\" alt=\"image-20251214233727780\" style=\"zoom:33%;\" />\n\n### 第四个:  <font color='Turquoise'>love-launcher</font>\n\n这个也是和上面那个一样的,只不过是通过快捷键启动\n\n​\t<img src=\"第一天/image-20251215110126431.png\" alt=\"image-20251215110126431\" style=\"zoom:33%;\" />\n\n不过需要提醒的是如果你要使用这几个插件需要修改一些东西,不是直接下载就完事的\n\n首先在设置里输入\n\n```\nlove\n```\n\n​\t<img src=\"第一天/image-20251216212651653.png\" alt=\"image-20251216212651653\" style=\"zoom:25%;\" />\n\n找到下方我括起来的几个,在我圈起来的地方粘贴进去 love2d引擎的文件路径,否则的话插件无法使用的\n\n​\t<img src=\"第一天/image-20251216212317024.png\" alt=\"image-20251216212317024\" style=\"zoom: 25%;\" />\n\n​\t<img src=\"第一天/image-20251216212743222.png\" alt=\"image-20251216212743222\" style=\"zoom:33%;\" />\n\n​\t<img src=\"第一天/image-20251216212821315.png\" alt=\"image-20251216212821315\" style=\"zoom:33%;\" />\n\n### 第五个: <font color='Turquoise'>Love2d Snippets</font>\n\n其实是一个辅助性love2d语法插件\n\n​\t<img src=\"第一天/image-20251215110310937.png\" alt=\"image-20251215110310937\" style=\"zoom:33%;\" />\n\n### 第六个: <font color='Turquoise'>Love2D Support</font>\n\n和上面这个一样,就是功能更智能全面\n\n​\t<img src=\"第一天/image-20251215110341614.png\" alt=\"image-20251215110341614\" style=\"zoom:33%;\" />\n\n### 第七个:<font color='Turquoise'> Lua</font>\n\n这两个下载哪一个都可以,反正也不冲突,主要是对lua语言的支持\n\n​\t<img src=\"第一天/image-20251215111320305.png\" alt=\"image-20251215111320305\" style=\"zoom: 25%;\" /><img src=\"第一天/image-20251215111344311.png\" alt=\"image-20251215111344311\" style=\"zoom: 25%;\" />\n\n### 第八个: <font color='Turquoise'>Lua Debug</font>\n\n负责Lua的Debug输出,如果已下载上面的俩,可以下载一个这个\n\n​\t<img src=\"第一天/image-20251215111505386.png\" alt=\"image-20251215111505386\" style=\"zoom: 25%;\" />\n\n## 3—–Lua的下载\n\n这个呢分为两个版本Lua5.1和Lua 5.4\n\n其中5.1配置最简单,但是功能没有5.4多,但是正常使用没有问题\n\n### 第一个版本(lua 5.1)(对于不喜欢折腾的小伙伴推荐)\n\n[<font color='Red'>点击此处跳转到github仓库</font>](https://github.com/rjpcomputing/luaforwindows/releases/tag/v5.1.5-52)\n\n​\t<img src=\"第一天/image-20251215111940556.png\" alt=\"image-20251215111940556\" style=\"zoom:33%;\" />\n\n这个非常简单,甚至不需要配置path什么的,下载之后VScode会默认使用这个版本,十分方便\n\n下载完成后可以在cmd窗口检测一下下载成功没有\n\n输入 <font color='Red'> Lua</font>  ,可以看到Lua 5.1装好啦!\n\n```\nlua\n```\n\n​\t<img src=\"第一天/image-20251215115147067.png\" alt=\"image-20251215115147067\" style=\"zoom: 50%;\" />\n\n咱们测试一下可不可以用\n\n直接输入\n\n```lua\nprint(\"Hello GenshinImpact\")\n```\n\n可以看到确实打印出来了  <font color='LightSkyBlue'>Hello GenshinImpact</font>\n\n​\t<img src=\"第一天/image-20251215115527233.png\" alt=\"image-20251215115527233\" style=\"zoom: 50%;\" />\n\n而且这个软件它会自带一个编译器,就是界面有点拉胯,就像上个世纪的老古董windowsXP的软件操作界面一样\n\n​\t<img src=\"第一天/image-20251215112518663.png\" alt=\"image-20251215112518663\" style=\"zoom:33%;\" />\n\n哦,对了,提起界面拉胯的但还是比较强大的Lua编译器就不得不提这个ZeroBrane Studio了\n\n这个编译器使用Lua写的,对Lua的支持性挺好的,喜欢的话[<font color='Red'>点击此处下载ZeroBrane Studio</font>](https://studio.zerobrane.com/)\n\n​\t<img src=\"第一天/image-20251215112850210.png\" alt=\"image-20251215112850210\" style=\"zoom: 33%;\" />\n\n​\t<img src=\"第一天/image-20251215112633465.png\" alt=\"image-20251215112633465\" style=\"zoom:25%;\" />\n\n然后回到VScode\n\n找到左下角的这个齿轮形状的找到设置\n\n点击进去之后,在上方输入  “<font color='Red'>executorMap</font>”\n\n```\nexecutorMap\n```\n\n点击这个 我框选出来的第一个下方的 <font color='LightSkyBlue'>在setting.json中编辑</font>\n\n​\t<img src=\"第一天/image-20251215113508716.png\" alt=\"image-20251215113508716\" style=\"zoom:33%;\" />\n\n可以看到刚才我们给插件配置的Love2d路径已经自动包含进去了,不需要手动修改了\n\n​\t<img src=\"第一天/image-20251215113929293.png\" alt=\"image-20251215113929293\" style=\"zoom:33%;\" />\n\n好的,我们再来看看lua配置在哪个地方的,这个也是为了方便我们后续的Lua5.4的配置\n\n同样的我们打开这个我框选出来的第三个的<font color='LightSkyBlue'>在setting.json中编辑</font>\n\n​\t<img src=\"第一天/image-20251215114254782.png\" alt=\"image-20251215114254782\" style=\"zoom:33%;\" />\n\n默认的话我记得没错的话下面这张图片我圈出来的这里默认写的是下面这句,表示默认使用Lua 5.1\n\n```json\n“Lua”: “Lua” ,\n```\n\n​\t<img src=\"第一天/image-20251215114341175.png\" alt=\"image-20251215114341175\" style=\"zoom:25%;\" />\n\n但是能看到我修改成了另一个lua的路径,没错就是我们接下来要讲的 Lua 5.4的配置\n\n不过为了讲解我先改回来默认配置吧\n\n​\t<img src=\"第一天/image-20251216135059105.png\" alt=\"image-20251216135059105\" style=\"zoom:25%;\" />\n\n​\t我们测试一下,可以看到确实是用默认的lua 5.1输出的\n\n​\t<img src=\"第一天/image-20251216134937758.png\" alt=\"image-20251216134937758\" style=\"zoom:25%;\" />\n\n\n\n注意:某些小伙伴可能电脑输出中文是乱码,这是由于我们的电脑默认GBK格式,但VScode文件格式是UTF-8,\n\n#### 终端输出的中文乱码问题解决方案一(强烈推荐):\n\n\n\n首先打开<font color='Red'>设置</font>\n\n​\t<img src=\"第一天/image-20251220120028971.png\" alt=\"image-20251220120028971\" style=\"zoom:33%;\" />\n\n点击右上角的这个“<font color='Red'>打开设置(JSON)</font>”,长得像小文件页一样的东西\n\n​\t<img src=\"第一天/image-20251220122633214.png\" alt=\"image-20251220122633214\" style=\"zoom:33%;\" />\n\n然后在这个 Json文件里代码的最底下添加下方添加这几句话后保存重启VScode\n\n注意,之前  Json文件的最后一句话需要添加一个逗号“   <font color='Red'>,</font>  ”,否则会报错\n\n​\t<img src=\"第一天/image-20251220123050907.png\" alt=\"image-20251220123050907\" style=\"zoom:25%;\" />\n\n​\t<img src=\"第一天/image-20251220122906373.png\" alt=\"image-20251220122906373\" style=\"zoom: 25%;\" />\n\n```json\n\"terminal.integrated.profiles.windows\": {\n    \"PowerShell\": {\n      \"source\": \"PowerShell\",\n      \"args\": [\n        \"-NoLogo\",\n        \"-NoExit\",\n        \"-Command\",\n        \"[Console]::OutputEncoding=[System.Text.Encoding]::UTF8; $OutputEncoding=[System.Text.Encoding]::UTF8; chcp 65001 > $null\"\n      ]\n    }\n  },\n  \"terminal.integrated.defaultProfile.windows\": \"PowerShell\",\n  \"terminal.integrated.fontFamily\": \"Consolas, 'Microsoft YaHei', 'Noto Sans CJK SC'\",\n  \"terminal.integrated.env.windows\": {\n    \"LANG\": \"zh_CN.UTF-8\",\n    \"LC_ALL\": \"zh_CN.UTF-8\"\n  }\n```\n\n \"terminal.integrated.fontFamily\": \"Consolas, 'Microsoft YaHei', 'Noto Sans CJK SC'\",这里我比较喜欢微软雅黑和Consolas字体\n\n你们要是喜欢别的字体可以调成别的字体,前提是你的电脑存在这个字体\n\n#### 终端输出的中文乱码问题解决方案二(十分不推荐,会让你电脑上的某些软件直接打不开或打开后全是乱码):\n\n我们改一下我们的系统\n\n首先找到<font color='Turquoise'>系统</font>><font color='Turquoise'>时间和语言</font>\n\n​\t<img src=\"第一天/image-20251218211424367.png\" alt=\"image-20251218211424367\" style=\"zoom: 25%;\" />\n\n点击<font color='Red'>语言和地区</font>\n\n​\t<img src=\"第一天/image-20251218211554958.png\" alt=\"image-20251218211554958\" style=\"zoom:25%;\" />\n\n​\t点击<font color='Red'>管理语言设置</font>><font color='Red'>更改系统区域设置</font>\n\n​\t<img src=\"第一天/image-20251218211719500.png\" alt=\"image-20251218211719500\" style=\"zoom:33%;\" />\n\n<font color='Red'>勾上</font>这个,点击<font color='Red'>确定</font>后<font color='Red'>重启电脑</font>,就OK了\n\n​\t<img src=\"第一天/image-20251218211835813.png\" alt=\"image-20251218211835813\" style=\"zoom:33%;\" />\n\n​\t然后我再次改为我配置好的lua 5.4的路径(记住,每一次修改都要保存并重启VScode哦)\n\n​\t可以发现结果一样,但使用的lua版本却是不一样的\n\n​\t<img src=\"第一天/image-20251216134623937.png\" alt=\"image-20251216134623937\" style=\"zoom: 25%;\" />\n\n### 第二个版本(lua 5.4)\n\n这个就需要去lua的官网下载了,目前貌似是官方断更了(但听说在准备5.5版本),lua停留在了5.4版本\n\n[<font color='Turquoise'>点击这里进入lua官网</font>](https://www.lua.org/download.html)\n\n​\t<img src=\"第一天/image-20251216140207072.png\" alt=\"image-20251216140207072\" style=\"zoom:33%;\" />\n\n进入这个界面,先不要急着点击这个上面的东西,我们要点击的是这个下面的**<font color='Turquoise'>LuaBinaries</font>**这个才是我们真正要用的\n\n​\t<img src=\"第一天/image-20251216140504816.png\" alt=\"image-20251216140504816\" style=\"zoom: 25%;\" />\n\n点击之后就会跳转到这个界面,点击左边的<font color='Turquoise'>Download</font>\n\n​\t<img src=\"第一天/image-20251216143138712.png\" alt=\"image-20251216143138712\" style=\"zoom:33%;\" />\n\n往下翻,找到最上面的那个,比如你的电脑是windows的就下载这个我圈起来的就行了\n\n​\t<img src=\"第一天/image-20251216143238792.png\" alt=\"image-20251216143238792\" style=\"zoom: 33%;\" />\n\n​\t<img src=\"第一天/image-20251216143433394.png\" alt=\"image-20251216143433394\" style=\"zoom:33%;\" />\n\n点击,有一个人机验证(话说你都可以看到我部署在github的这篇文章了,cloudflare的人机验证应该可以过吧),过了之后稍等片刻就会自动下载了,sourceforge服务器是在国外的可能反应慢\n\n​\t<img src=\"第一天/image-20251216143538424.png\" alt=\"image-20251216143538424\" style=\"zoom:33%;\" />\n\n好的,可以看到我解压到这个文件夹了,这个路径和之前在json里的一致\n\n好的,接下来的操作和Love2d的<font color='Red'>path路径配置</font>一模一样\n\n但是我为了和之前的lua5.1区分开了这样写了(当然你要是嫌麻烦可以直接把刚才下的lua5.4的文件夹路径粘进去,没有任何影响的)\n\nemmm,为防止你敲错路径,还是推荐你这样复制路径\n\n<font color='Red'>右键</font>点击上方搜索栏,点击<font color='Red'>复制地址</font>\n\n​\t<img src=\"第一天/image-20251216145048208.png\" alt=\"image-20251216145048208\" style=\"zoom:50%;\" />\n\n我的写法就是在环境变量里写\n\n```\n%LUA_HOME%\\\n```\n\n​\t<img src=\"第一天/image-20251216144018274.png\" alt=\"image-20251216144018274\" style=\"zoom: 33%;\" />\n\n然后在系统变量里新建一个\n\n \n\n```\nLUA_HOME\n```\n\n​\t<img src=\"第一天/image-20251216144846574.png\" alt=\"image-20251216144846574\" style=\"zoom:33%;\" />\n\n完成,记得点击确定保存!!!\n\n​\t<img src=\"第一天/image-20251216144210694.png\" alt=\"image-20251216144210694\" style=\"zoom:33%;\" />\n\n好了,我们再次回到VScode,想必你已经知道要干嘛了\n\n我们需要的是这个lua54.exe的路径,右键选择<font color='Red'>复制文件路径</font>即可,注意路径的<font color='Red'>斜杠是两个</font>哦,需要手动添加的\n\n​\t<img src=\"第一天/image-20251216145743176.png\" alt=\"image-20251216145743176\" style=\"zoom: 50%;\" />\n\n​\t<img src=\"第一天/image-20251215114341175.png\" alt=\"image-20251215114341175\" style=\"zoom:25%;\" />\n\n好的,我们看看这个能不能用\n\n首先<font color='Red'>win +R</font>打开cmd输入<font color='Red'>lua54</font>  (是的,不是 “\tlua \t”  ,   而是要加一个\t“  54  ”)\n\n```\nlua54\n```\n\n​\t<img src=\"第一天/image-20251216150142806.png\" alt=\"image-20251216150142806\" style=\"zoom:50%;\" />\n\n输入,可以发现可以用\n\n```lua\nprint(\"Hello GenshinImpact\")\n```\n\n​\t<img src=\"第一天/image-20251216150424248.png\" alt=\"image-20251216150424248\" style=\"zoom:50%;\" />\n\n还有甚至这两个可以视作独立的两个东西\n\n​\t<img src=\"第一天/image-20251216150909078.png\" alt=\"image-20251216150909078\" style=\"zoom:50%;\" />\n\n好的,我们回到VScode看看这个能不能用\n\n​\t<img src=\"第一天/image-20251216151417633.png\" alt=\"image-20251216151417633\" style=\"zoom: 33%;\" />\n\n看到这里,恭喜你,成功了哦  Ciallo～(∠・ω< )⌒☆\n\n哦,对了,VScode默认的注释的颜色是灰色的很难看\n\n我们还可以在这里修改一下\n\n​\t<img src=\"第一天/image-20251227162217627.png\" alt=\"image-20251227162217627\" style=\"zoom:33%;\" />\n\n然后就是这里\n\n​\t<img src=\"第一天/image-20251227162316558.png\" alt=\"image-20251227162316558\" style=\"zoom:33%;\" />\n\n然后就是和之前差不多,最后一句话的逗号不要忘了\n\n加上这几句后保存重启VScode\n\n```json\n\"editor.tokenColorCustomizations\": {\n    \"comments\": \"#40E0D0\"\n}\n```\n\n其中这个16进制是颜色值,我比较喜欢绿宝石色,你们可以替换为自己喜欢的\n\n​\t<img src=\"第一天/image-20251227162619613.png\" alt=\"image-20251227162619613\" style=\"zoom:50%;\" />\n\n​\t<img src=\"第一天/image-20251227162407207.png\" alt=\"image-20251227162407207\" style=\"zoom:33%;\" />\n\n# 剩下的以后再慢慢学吧,  がんばれ!\n","tags":["love2d","lua"],"categories":["游戏开发"]},{"title":"如何在VScode中配置C#环境","url":"/2025/12/13/计算机语言相关/Csharp语言/使用VSCode写Csharp的配置方法/","content":"\n# 之前写C#一直用的是Visual  Studio  和 Rider  但是随着我的破电脑越来越卡也快带不动这两个一启动就吃满电脑内存的公子哥了,所以还是用我们的VScode娘吧    @_@\n\n## 首先去官网下载    dotnet  SDK  10\n\n[<font color='Turquoise'>点击此处前往官网下载</font>](https://dotnet.microsoft.com/zh-cn/download)\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225221844942.png\" alt=\"image-20251225221844942\" style=\"zoom: 25%;\" />\n\n选择你电脑的操作系统对应的版本下载即可\n\n完成后就可以 键盘输入 <font color='Red'> win  +  R</font>  进入  <font color='Red'>cmd </font> 窗口\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222110903.png\" alt=\"image-20251225222110903\" style=\"zoom:33%;\" />\n\n在控制台输入\n\n```\ndotnet --info\n```\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222233255.png\" alt=\"image-20251225222233255\" style=\"zoom:33%;\" />\n\n可以看到我电脑上有好多版本,包括最新的 dotnet  10\n\n然后回到VScode   \n\n## 给VScode安装插件\n\n这里我就不一一介绍了,全都下载下来就对了(某些插件可能已经过期下架了,但一般这些比较火的不会只要有人维护)\n\n### 插件名: <font color='Turquoise'> .NET Install Tool</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222548271.png\" alt=\"image-20251225222548271\" style=\"zoom:33%;\" />\n\n### 插件名: <font color='Turquoise'>C#</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222702273.png\" alt=\"image-20251225222702273\" style=\"zoom:33%;\" />\n\n### 插件名:  <font color='Turquoise'>C# Dev Kit</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222744158.png\" alt=\"image-20251225222744158\" style=\"zoom:33%;\" /> \n\n### 插件名:  <font color='Turquoise'>C# Extensions</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222832804.png\" alt=\"image-20251225222832804\" style=\"zoom:33%;\" />\n\n### 插件名:  <font color='Turquoise'>C# Snippets</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225222922227.png\" alt=\"image-20251225222922227\" style=\"zoom:33%;\" />\n\n### 插件名:  <font color='Turquoise'>C# XML Documentation Comments</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225223047351.png\" alt=\"image-20251225223047351\" style=\"zoom:33%;\" />\n\n### 插件名:  <font color='Turquoise'>GitHub Copilot Chat</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225223236076.png\" alt=\"image-20251225223236076\" style=\"zoom:33%;\" />\n\n### 插件名:\t<font color='Turquoise'>Code Runner</font>\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251227161831377.png\" alt=\"image-20251227161831377\" style=\"zoom:33%;\" />\n\n\n\n## 配置C#环境\n\n首先新建一个空文件夹并拖进VScode(你不会这个都不会吧???)\n\n然后按照如图所示找到这个  “<font color='Turquoise'>新建终端</font>”\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225223614589.png\" alt=\"image-20251225223614589\" style=\"zoom:33%;\" />\n\n然后在控制台输入如下语句\n\n```\ndotnet new console -n HelloWorld\n```\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225223940739.png\" alt=\"image-20251225223940739\" style=\"zoom:33%;\" />\n\n但是如果你看过别的教程里的 就会知道 需要有 bin文件夹才行\n\n所以我们再次进入刚才的新创建的文件夹的路径\n\n```\ncd HelloWorld\n```\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225224211649.png\" alt=\"image-20251225224211649\" style=\"zoom:33%;\" />\n\n如图所示,我们已经进入这个文件夹\n\n输入如下代码\n\n```\ndotnet run\n```\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225224318898.png\" alt=\"image-20251225224318898\" style=\"zoom:33%;\" />\n\n可以看到左上角出现了bin文件夹   控制台也输出了  默认的语句  “ <font color='Turquoise'>Hello, World!</font> ”\n\n有些小伙伴可能听说了其他人的旧版本的代码运行方式,我确实也亲手试了一遍\n\n老版本是首先在VScode里输入   <font color='Turquoise'>ctrl  +shift +p</font>  后\n\n在输入栏里再输入\n\n```\n.NET: Generate Assets for Build and Debug\n```\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225224946185.png\" alt=\"image-20251225224946185\" style=\"zoom:33%;\" />\n\n可以看到\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225225212934.png\" alt=\"image-20251225225212934\" style=\"zoom:33%;\" />\n\n我们因为是新版本,所以选择“  <font color='Turquoise'> 是</font>  ”\n\n然后怎么用咧?\n\n首先我们进入默认的  <font color='Turquoise'>Program.cs</font> 文件\n\n假如我们直接点击右上角的小箭头(Run code,即运行代码)就会报错\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225225745394.png\" alt=\"image-20251225225745394\" style=\"zoom:33%;\" />\n\n需要点击这个(run project associated with this file   ,即运行所有与这个cs文件相关联的文件)\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225225905472.png\" alt=\"image-20251225225905472\" style=\"zoom:33%;\" />\n\n然后出现这个\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225230122246.png\" alt=\"image-20251225230122246\" style=\"zoom:33%;\" />\n\n最后就是结果\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225230150634.png\" alt=\"image-20251225230150634\" style=\"zoom:33%;\" />\n\n这里看你的需求\n\n选择直接运行还是调试后运行\n\n第一种: 直接输入  <font color='Turquoise'>F5</font>  键 运行并调试  或者选择刚才的   <font color='Turquoise'>Debug   project associated with this file</font> (与此文件关联的调试项目)\n\n\n\n <img src=\"使用VSCode写Csharp的配置方法/image-20251225230258055.png\" alt=\"image-20251225230258055\" style=\"zoom:33%;\" />\n\n​\t\n\n第二种:直接输入 <font color='Turquoise'>Ctrl  + F5</font>  直接运行  或者 选择刚才的  <font color='Turquoise'>Run project associated with this file </font>(运行与此文件关联的项目)\n\n和刚才一样\n\n​\t<img src=\"使用VSCode写Csharp的配置方法/image-20251225230600684.png\" alt=\"image-20251225230600684\" style=\"zoom:33%;\" />\n\n对于那些控制台有中文乱码的可以看看我的另一篇Blog\n\n[<font color='Turquoise'>点击查看我的另一篇文章“ love2d学习第一天--配置love2d环境和lua的环境 ”</font>](https://funingna-wakawaka.github.io/2025/12/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%9B%B8%E5%85%B3/Love2d%E5%BC%95%E6%93%8E/%E7%AC%AC%E4%B8%80%E5%A4%A9/)\n\n\n\n## 以后我再补充一下怎么在Unity ,Godot 里用VScode里写脚本吧","tags":["VScode","C#"],"categories":["计算机语言"]},{"title":"我的世界动画使用blender-mcprep插件无法打开jmc2obj软件问题解决方案","url":"/2025/12/03/我的世界相关/我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/","content":"\n# 我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案\n\n## Ciallo～(∠・ω< )⌒★   MC未来的动画制作者们\n\n估计在你们选择使用blender制作MC动画时,免不了要使用mcprep插件,如图\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/d4f8ad0471a4441f84548eceb322b134.jpeg\" alt=\"d4f8ad0471a4441f84548eceb322b134\" style=\"zoom:25%;\" />\n\n插件怎么导入想必你们都会,这个插件支持快速打开jmc2obj和mineways这两个可以将我的世界的地图以obj格式导入到blender中的工具\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/0a1d03374d06414d99c0d5c9740a75f3.jpeg\" alt=\"0a1d03374d06414d99c0d5c9740a75f3\" style=\"zoom:25%;\" />\n\n快速打开方式就是只需要在blender中按   <font color='Turquoise'>N键</font>  点击  \"<font color='Turquoise'>MCprep</font>\"  插件,然后在 \"<font color='Turquoise'>MCprep工具</font>\"  一栏中点击   \"<font color='Turquoise'>高级</font>\"  右边的 <font color='Turquoise'>齿轮形状的图标</font>,就会弹出 \"<font color='Turquoise'>偏好设置</font>\"  窗口并自动定位到   \"<font color='Turquoise'>插件</font>\" 位置,此时只需要在这两个位置制定jmc2obj和mineways这两个工具的路径\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/e8f4459c48dd411f92baabc7e3bf2d17.png\" alt=\"e8f4459c48dd411f92baabc7e3bf2d17\"  />\n\n其中mineways只需要导入exe文件的路径即可,最好不要有中文,这个还是很简单的\n\n打开的话点击这个地方<font color='Turquoise'>Open Mineways </font> 就可以了,打开jmc2obj也是同理,自己试试就知道了\n\n当然,你也可以选择直接在blender外打开exe 或者jar文件来运行软件,就是多了去找这两个文件的操作十分不爽\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/0eca3a8d0e1c4cd9a35c11779821297e.png\" alt=\"img\"  /><img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/653db70041d0477ab6e9469d3a66cef4.png\" alt=\"653db70041d0477ab6e9469d3a66cef4\" style=\"zoom: 67%;\" />\n\n但是对于jmc2obj，这是一个jar 文件,双击的话或者在blender里\" Open jmc2obj \"大概率是打不开的,一般是需要java来打开的\n\n(我就默认你们是我的世界java版本的玩家了  (,,・ω・,,)     )\n\n比如有些制作者是打不开的,包括我(´ﾟдﾟ`)\n\n## 首先看看你们电脑上有没有java\n\n这个时候首先看看你们电脑上有没有<font color='Red'>java</font>,  win+R在小窗口输入\"<font color='Red'>cmd</font>\"小写字母\n\n```\ncmd\n```\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/e3b21f2c4d84485ba97e63b8ca33fa6d.jpeg\" alt=\"e3b21f2c4d84485ba97e63b8ca33fa6d\" style=\"zoom: 50%;\" />\n\n\n\n呼出界面后输入\"<font color='Red'>where java</font>\",中间有一个空格不要忘了\n\n```\nwhere java\n```\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/7ea6413e217d466a8498a4cdbde7d322.jpeg\" alt=\"7ea6413e217d466a8498a4cdbde7d322\" style=\"zoom:33%;\" />\n\n如图所示,可以看到我的电脑有两个java,这里我用的是放到<font color='Red'>D盘里的java</font>\n\n好的,接下来给java配置到电脑的<font color='Red'>PATH</font>路径\n\n## 给java配置到电脑的PATH路径\n\n首先找到电脑\"<font color='Red'>设置</font>\"，里的\"<font color='Red'>系统</font>\"  我这个是<font color='Red'>windows 11</font> ,不知道其他版本系统怎么设置\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/c1c02604da294a029b83abaefad0d651.jpeg\" alt=\"c1c02604da294a029b83abaefad0d651\" style=\"zoom:33%;\" />\n\n找到最底下的\" <font color='Red'>系统信息 </font>\"\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/b10d807a003a4bb9a615ef69e9a12940.jpeg\" alt=\"b10d807a003a4bb9a615ef69e9a12940\" style=\"zoom:33%;\" />\n\n点击进去后如图\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/1086f6ad4edd446d9e589550ff3f7508.jpeg\" alt=\"1086f6ad4edd446d9e589550ff3f7508\" style=\"zoom:25%;\" />\n\n这里有三个很显眼的<font color='LightSkyBlue'>蓝色</font>字体,选择右边的\"<font color='LightSkyBlue'>高级系统设置</font>\"\n\n就会弹出这个界面\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/e70a3c71863343048f7ff992567255e4.jpeg\" alt=\"e70a3c71863343048f7ff992567255e4\" style=\"zoom:33%;\" />\n\n点击底下的\"<font color='Red'>环境变量</font>\"\n\n又有一个窗口出现\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/9f2d010b1d9340b89dcd71b18b427b73.jpeg\" alt=\"9f2d010b1d9340b89dcd71b18b427b73\" style=\"zoom:33%;\" />\n\n这里不要选错地方了,在下方的\"<font color='Red'>系统变量</font> \"里翻啊翻啊翻找到<font color='Red'> path</font> 并点击 <font color='Red'>编辑</font> \n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/5d19b3e04b78430b8e105a27f0eeff01.png\" alt=\"5d19b3e04b78430b8e105a27f0eeff01\" style=\"zoom:33%;\" />\n\n很好,现在你们是不是还记得刚才第一步的操作----<font color='Red'>找到java的路径</font>\n\n复制下来等会有用\n\n编辑界面如下\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/b964c044a4e84648b228d203210aef92.jpeg\" alt=\"b964c044a4e84648b228d203210aef92\" style=\"zoom:33%;\" />\n\n点击右边的\"<font color='Red'>新建</font>\",此时会自动跳转的最后一行,把刚才复制的路径粘贴上去,注意<font color='Red'>删掉</font>路径后面的<font color='Red'>java.exe </font>\n\n然后点击<font color='Red'>上移</font>,尽量将路径移动到最上面\n\n你可以看看我的写法,路径里有没有中文都可以\n\n点击\"<font color='Red'>确定</font>\"\n\n然后我们回到这个界面\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/9b6b9c0f0450474ebfa63bce9fa61ed5.jpeg\" alt=\"9b6b9c0f0450474ebfa63bce9fa61ed5\" style=\"zoom:33%;\" />\n\n再次点击这个系统变量下面的\"  <font color='Red'>新建</font>  \",不是刚才的那个哟\n\n这样写\n\n上面名字随便写,这里我就写成\"<font color='Red'>JAVA_HOME</font>\"\n\n下面就是电脑下的<font color='Red'>jdk文件</font>的路径,jdk版本我的比较新是23的\n\n完成后<font color='Red'>确定</font>即可\n\n注意:不是java.exe路径!!!  是它的上上一级路径 ∑(￣□￣;)\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/7879b1973be14750beb7958b59ed838d.jpeg\" alt=\"7879b1973be14750beb7958b59ed838d\" style=\"zoom:33%;\" />\n\n到这里我们就添加完毕了 注意注意!!!\n\n检查刚才的英文大小写,检查空格,检查有没有多打字!!!!!\n\n没问题的话,恭喜\n\n我们进入下一步\n\n## 如何打开jMc2Obj-###.jar文件\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/c3ef44b16dc04f5f9a7c917b5a667e6e.png\" alt=\"c3ef44b16dc04f5f9a7c917b5a667e6e\" style=\"zoom: 50%;\" />\n\n首先<font color='Red'>win+R</font>输入<font color='Red'>regedit</font>进入<font color='Red'>注册表编辑器</font>\n\n```\nregedit\n```\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/264dd202ef594ac499d7853dce78629f.png\" alt=\"264dd202ef594ac499d7853dce78629f\" style=\"zoom: 33%;\" />\n\n看到了吗,一直往下翻翻翻翻\n\n找到这个<font color='Red'>jarfile</font>,然后一层一层的打开直到出现右边的东西\n\n右键<font color='Red'>有俩字默认</font>的这个东西\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/f33eb291e55144499991ba976a7755b2.png\" alt=\"f33eb291e55144499991ba976a7755b2\" style=\"zoom:33%;\" />\n\n\n\n点击<font color='Red'>修改</font>\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/95696d65d0bd4569a1e7cc094ea88eb6.png\" alt=\"95696d65d0bd4569a1e7cc094ea88eb6\" style=\"zoom:50%;\" />\n\n将里面的路径<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/c83749e97f494a8c85dc984039527ee4.png\" alt=\"c83749e97f494a8c85dc984039527ee4\" style=\"zoom:50%;\" />\n\n替换为你们的<font color='Red'>java路径</font>,这里我已经换好了,注意这后面的<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/b9ba322ce28146fc8544eacc8fc5af46.png\" alt=\"b9ba322ce28146fc8544eacc8fc5af46\" style=\"zoom:50%;\" />不要动\n\n点击确定即可,注意空格键的存在和引号是<font color='Red'>英文</font>的\n\n你们看看电脑里<font color='Red'> jMc2Obj-###.jar</font>(我下载的是127最新版本,你们的自己看看) 文件放到哪个文件夹\n\n然后右击jar文件用<font color='Red'>java</font>打开\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/7598f2601672436fb01e3ab93ea6db82.png\" alt=\"7598f2601672436fb01e3ab93ea6db82\" style=\"zoom: 25%;\" />\n\n或者点击<font color='Red'>属性</font>,在打开方式里更改用<font color='Red'>java</font>打开,这个是为了方便一些上一步打开方式选错的制作者\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/45ecd3d530214201b0f3ab41cb0bfb21.png\" alt=\"45ecd3d530214201b0f3ab41cb0bfb21\" style=\"zoom:33%;\" />\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/853962d5dba94ab7a6c41d7a2b46e32f.jpeg\" alt=\"853962d5dba94ab7a6c41d7a2b46e32f\" style=\"zoom:33%;\" />\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/87b67b5bf932410aa519965d8fad64bb.png\" alt=\"87b67b5bf932410aa519965d8fad64bb\" style=\"zoom:50%;\" />\n\n然后发现如果还是打不开的话,我们进一步操作\n\n首先检查jar文件的完整性,毕竟jMc2Obj原作者是发布到github上的\n\n国内可能由于网路问题下载文件不完全\n\n先在jar文件所在的文件夹空白处右键点击在\"<font color='Red'>在终端中打开</font>\",打开我们的<font color='Red'>powershell</font>\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/ddd7141277a1414fbd33c0936a094564.png\" alt=\"ddd7141277a1414fbd33c0936a094564\" style=\"zoom:33%;\" />\n\n先输入\" <font color='Red'>  dir  </font>\"回车\n\n```\ndir\n```\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/916df44a71474524ac71229a05f8d66d.jpeg\" alt=\"916df44a71474524ac71229a05f8d66d\" style=\"zoom:33%;\" />\n\n出现这几行字尤其是中间的一行就行了\n\n<font color='Teal'>-a----         2025/10/2     16:11        9897475 jMc2Obj-127.jar</font>\n\n其他两个目前你们是没有的,等会再说\n\n然后再输入以下命令检查是否存在<font color='Red'>jMc2Obj-###.jar文件</font>,###是你们的版本号\n\n刚才的这一行字应该会提示你们具体的版本号,我的是127版本\n\n```\njava -jar jMc2Obj-127.jar\n```\n\n如果出现以下结果就是正确的\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/477cc0874aa84e7a8c069734cd16025f.jpeg\" alt=\"477cc0874aa84e7a8c069734cd16025f\" style=\"zoom:33%;\" />\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/98d53fdafd094206a89ad3dabf6514de.jpeg\" alt=\"98d53fdafd094206a89ad3dabf6514de\" style=\"zoom:33%;\" />\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/a71036e47d204628b17b9ccb84f26b30.jpeg\" alt=\"a71036e47d204628b17b9ccb84f26b30\" style=\"zoom:33%;\" />\n\n这代表启动<font color='Teal'>jMc2Obj</font>成功而且你们百分之一百会遇到这个错误\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/a42b2f481dcf4658a4c6d44cc6d5c788.jpeg\" alt=\"a42b2f481dcf4658a4c6d44cc6d5c788\" style=\"zoom:25%;\" />\n\n这是因为无法检测java的版本更新导致的,因为java的主人SUN公司已经死掉了,所以这个软件无法再从sun公司的官网下载更新了,所以是一个正常现象,但是每次启动都会出现这个东西\n\nvery very sick  ( º﹃º )\n\n不过我们的<font color='Teal'>jMc2Obj</font>\n\n已经打开了如图,出现一个大界面和一个小窗口即<font color='Red'>console控制台</font>\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/a213ef0d588946d693e456985fccf6f1.jpeg\" alt=\"a213ef0d588946d693e456985fccf6f1\" style=\"zoom:25%;\" />\n\n然后我们就可以在这里导入MC  的<font color='Red'>saves </font>文件里的存档世界文件\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/a6a017e1ed5344f8a17a24eca7350942.jpeg\" alt=\"a6a017e1ed5344f8a17a24eca7350942\" style=\"zoom:33%;\" />\n\n点击\"<font color='Red'>加载世界</font>\"\n\n当当!!!!!\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/1b7613aec91141528bcb7371cb9d42a6.jpeg\" alt=\"1b7613aec91141528bcb7371cb9d42a6\" style=\"zoom:25%;\" />\n\n至于怎么用网上一堆教程,大家自己可以去学习一下\n\n## 更加便携的打开jMc2Obj的操作方式\n\n想必你们也发现了,每次启动这个软件都要输入这个破命令 ┐(´д`)┌\n\n而且这个java更新不了的错误每次都出现\n\nMC动画师不是程序员,所以我们需要一劳永逸的方法\n\n首先我们创建一个<font color='LightSkyBlue'>txt文件</font>,这个大家都会吧\n\n然后在<font color='LightSkyBlue'>记事本</font>中写下\n\n```\n@echo off\ntitle jMc2Obj NowYouCanStart\njava -Djmc.checkupdate=false -jar \"%~dp0jMc2Obj-127.jar\" 2>nul\n\n\n```\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/e1f6b4f25d73476e9ad031edacc3584e.jpeg\" alt=\"e1f6b4f25d73476e9ad031edacc3584e\" style=\"zoom:25%;\" />\n\n这里我用java -Djmc.checkupdate=false -jar \"%~dp0jMc2Obj-127.jar\" 2>nul\n\n禁止了powershell里的报错出现,但是我禁止不了那个小小的console控制台里的报错,\n\n因为那个是软件自带的,我也尝试了下载github上的源码来修改,结果越改越错,算了,还是放哪儿吧\n\n( ´ﾟДﾟ`)\n\n大家写完了后<font color='LightSkyBlue'>修改txt文件</font>的格式为<font color='LightSkyBlue'>bat格式</font>(改文件格式大家应该都会吧),名字自己随便取\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/449fbdeab88a4f48bb87b35373b7dbe5.jpeg\" alt=\"449fbdeab88a4f48bb87b35373b7dbe5\" style=\"zoom:50%;\" />\n\n可以发现文件样子变了,而且还出现了一个<font color='LightSkyBlue'>conf  </font>  文件夹\n\n没错,这个就是刚才成功运行<font color='Teal'>jMc2Obj</font>  后自己产生的,不用管它\n\n好了,此时点击这个bat文件,然后你可以发现jMc2Obj 居然启动了,就像<font color='LightSkyBlue'>exe文件</font>一样\n\n出现这个<font color='Red'>叉掉</font>就行,不用管它,因为还是那个java更新问题\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/249dd92aedbf427fa010849a10e96a2a.png\" alt=\"249dd92aedbf427fa010849a10e96a2a\" style=\"zoom:80%;\" />\n\n但是怎么在blender中打开呢,答案是mineways怎么添加和打开的,jMc2Obj 就怎么打开\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/ed36aaa6846e4bbeade486542fa10652.png\" alt=\"ed36aaa6846e4bbeade486542fa10652\" style=\"zoom:33%;\" />\n\n看到没有,就是把这个start.bat文件当做exe文件来使用\n\n<img src=\"我的世界动画使用blender mcprep插件无法打开jmc2obj软件问题解决方案/0a5df6d92b804eda834e76409d0462eb.png\" alt=\"0a5df6d92b804eda834e76409d0462eb\" style=\"zoom:50%;\" />\n\n点击\" <font color='Turquoise'>Open jmc2obj</font> \"就大功告成了!!!! ( ◜◡‾)\n\n感谢你们的阅读,如果对你们有帮助的话,可否点赞收藏加关注呢\n\n对了,我B站 名字也叫  ***\\*<font color='Red'>胡杨怕火</font>\\**** \n\n<font color='Turquoise'>最近在制作Unity教程,希望大家感兴趣的支持一下</font>\n","tags":["Minecraft","Blender"],"categories":["我的世界","Blender"]},{"title":"03-游戏设计思路","url":"/2025/12/02/日记相关/KoyouAsh开发日记/03-游戏设计思路/","content":"\n# 游戏初步设计\n\n## 开幕(先反思一下)\n\n这里需要使用一个视角的转换\n\n前面也说过了,但是我在思考怎么让游戏的风格一致,虽然第一阶段游戏可以跑就可以了,原本想用galgame的那种叙事方法不过感觉都烂大街了没什么好玩的而且我希望剧情过度比较自然 而不是让玩家点一下按钮就放一个对话,况且AI都可以画galgame的背景图,感觉这种思想要转变,不要在画质和画面上下功夫\n\n原本我想做那种3D和2D结合的场景,现在看来有可能会破坏游戏的画质一致性,而且3D我的破电脑带不动\n\n所以不知道怎么办才好,终于还是陷入了想法不够能力不足的境地了\n\n所以一开始我还是使用galgame的表现方式来描绘开场动画,毕竟我不擅长画画,也不擅长动画\n\n开场还是那个开场,就是剧情比较重要\n\n我花了太多时间在UI界面了,画起来真的很难受,自己也不会写shader,而且不想在人物身上浪费太多时间,一个破小人都能画一上午而且还是像素,难受,本来想用nano banana和豆包偷懒,结果生成的图缩小乍一看还像回事,一放大就疯狂露馅,人物有各种细节上的问题,光修一张图达到人绘制的像素图的水平就浪费了我两个小时,比我自己原创都累,算了吧\n\n不对,应该是我不会用,我看人家的都挺好的","tags":["KoyouAsh","Unity"],"categories":["游戏开发"]},{"title":"02-EarthHitting","url":"/2025/12/01/日记相关/KoyouAsh开发日记/02-EarthHitting/","content":"\n# 关于Earthhitting的调整\n\n感觉用陨石撞地球的很幼稚,怎么说呢,幼稚归幼稚,实现的难度其实挺大的,比如陨石的下降砸到地球的哪个位置,从哪个角度比较合适,以及砸下去后陨石的动画什么的全都是问题,对于我这个新手来说难度极大,虽然用AI实现了陨石的位置可以像太空的的陨石雨一样在游戏界面上到处乱跑,但是做不到我想要的效果\n\n原本的想法是-----陨石可以互相碰撞,然后融合成其他种类的陨石,比如假如把陨石分为1,2,3,4,5,6,7,8,9,10\n\n这十个等级,然后陨石相撞会互相融合,这里原本是想模仿网上的那种shader小球融合的效果,但是太难了,教程要么是过时了,重新复现那种效果非常困难,而且不想把时间浪费在游戏引擎的学习上,只希望快速的实现游戏的制作\n\n第二就是就算我跟着教程做一遍游戏的小球融合的效果,这个我也是很难做到我希望的那种效果,毕竟我想要的那种\n\n1+1=2,1+2=3,1+3=4,2+3=5.........等等\n\n这个逻辑其实还是挺复杂的,虽然考虑融合时的动画效果,但是不用猜也知道这是一件极其困难的操作,超出了我的能力\n\n后来又想过让两个球体碰撞之后直接转化为对应的球体,不过测试之后观感极其差劲,还是自己能力不够啊\n\n有点吃了技术债了,虽然让AI可以写出一个差不多我想要的效果,但是吧,他写的脚本我改不了一点,太高大上而且极其抽象,最多也就是改改public公开的属性值,虽然可以用但是感觉日后可能会吃亏\n\n代码原本我也是想整理用qFramework框架,不过还是太过于抽象,而且由于是第一次使用框架这种东西,更重要的是,这个框架自创了一大堆api 记不住也看不懂,原本只需要用unity内置的api就可以做到的事这个框架搞得极其复杂,十分不理解,不过可能是我太菜的缘故\n\n我新的游戏设计思路是\n\n","tags":["KoyouAsh","Unity"],"categories":["游戏开发"]},{"title":"01-背景故事","url":"/2025/12/01/日记相关/KoyouAsh开发日记/01-背景故事/","content":"\n# KoyouAsh背景思路(初步)\n\n## 一 ,开场\n\n首先需要和大多数游戏有一点区别和共同的联系\n\n这里不考虑galgame,竞技类游戏比如王者荣耀,战地,三角洲行动,PUBG,CSGO等等,因为一个受众相对固定,另一种纯粹的是社交类型的\n\n比如绝大多数剧情游戏是主角在一个地方醒来,比如  只狼  ,  狼在一个地牢里醒来,然后根据留下的线索去寻找主人真子\n\n或者典型的原神,主角在蒙德城附近像失忆了一样然后被派蒙指引,很多游戏或者影视剧都喜欢用这个套路\n\n或者是像看门狗艾登皮尔斯,首先用一段动画交代了主角自己的侄女遇害,明确的告诉玩家\"我要去复仇\"\n\n或者巫师三用一个杰洛特梦见的过去往事来巧妙的起到\"交代背景+玩家指引\"这两个作用\n\n而但对于纯玩法的游戏,不需要有那么复杂的开场或者根本不需要,比如我的世界,泰拉瑞亚,玩家只需要在\"这个世界\"凭空出现即可\n\n卡牌类,射击类,玩家的玩法十分固定,基本是策略性和单纯杀杀杀,主要是让玩家玩起来比较爽\n\n\n\n所以我的思路是首先可以弄一个主角刚睡醒睁眼的画面,这个可以分为两个人称方式\n\n1.第二人称---你\n\n<img src=\"01-背景故事/01.jpg\" alt=\"01\"  />\n\n2,第一人称---我\n\n<img src=\"01-背景故事/03.jpg\" alt=\"03\" style=\"zoom: 50%;\" />\n\n目前考虑的是第一人称,比如刚睁眼映入眼帘的是一个老人在给他的孙女讲故事的画面\n\n<img src=\"01-背景故事/02.jpg\" alt=\"02\"  />\n\n有点类似于电影黑豹的开场,应该父亲用给儿子讲故事的方式讲述了非洲瓦坎达的由来和紫色心形草与瓦坎达国王的联系\n\n或者电影沙丘中用女主珍妮的口吻讲述沙丘的地理情况,以及弗雷曼人和哈克南家族的矛盾\n\n或者生化危机中开头交代了保护伞公司和T病毒的由来,肖申克救赎开头交代肖申克含冤入狱,第九区开头交代外星人飞船悬停在\n\n地球上空从而导致与人类的矛盾,超级陆战队则用滨田宏和混混赌博展现小宏的天赋异禀\n\n总之,开头的作用就是-------交代故事背景,展现人物特征和性格\n\n\n\n所以,我可以用老人比如主角的爷爷给自妹妹讲故事,开始游戏的UI界面为主角半睁开的眼睛的视角,看到灯下或者炉火旁有一个老人和小女孩,此时可以用鲜明的颜色对比来将玩家的注意力集中在这两个人身上,此时眼中的场景为小女孩求着老人给自己讲故事,然后主角此时又犯困了,视角开始错乱模糊,并随之闭眼,此时老人也开始讲了,并随着主角的视角的旋转扭曲并进入开场动画--------故事内容是  本游戏的主要事物比如胡杨林  Koyo forest的由来\n\n简述:很久很久以前,不知道什么时候这片山谷出现了一片蓝色的土壤,而这个土壤有催生出了一个新的物种-Koyo,这个树拥有一个奇特的特征,那就是会自燃,春天夏天和普通的树无异,但是到了秋天就会落下叶子,叶子会发生自燃,重新化为蓝色的灰\n\n<img src=\"01-背景故事/04.jpg\" alt=\"04\" style=\"zoom: 33%;\" /><img src=\"01-背景故事/05.jpg\" alt=\"img\" style=\"zoom:33%;\" />\n\n但是有一天,这片土地上的这种树被人们发现了,于是一些人选择在这片奇特的树林中定居,这种树木只有在这个山谷中才能生长,相反,其他的植物物种很难适应这里的环境,比如水果蔬菜什么的只能生长在人工移植的土壤里才可以 ,因此在这里生活的人只能依赖进口这些日用品和食物(有点类似于日本),但是这里条件虽然比较苛刻,但是同时也带来了高回报,独特的树木和独特的矿产资源发展了当地的旅游业,因为常常有外界的人偷偷砍树挖矿(然后就像石油之于美军),吸引了一个公司的注意力,该公司表面上与山谷里的人合作,聘请了武装人员并将山谷周围土地收购并添加上了铁丝网和防护墙,将山谷资源化为私有,\n\n\n\n总之就是脑洞大开的瞎编\n\n## 二,小游戏(Earth Hitting)\n\n玩家需要在游戏开始的时候做出选择自己的性别是 男或女,男的话妹妹会称呼自己为\"哥哥或者老哥\",女的话妹妹会称呼自己为\"姐姐或老姐\"\n\n主角代表的男女的名字有差异\n\n动画结束后,妹妹凑到主角面前,发现主角已经醒了\n\n此时就会要求主角和自己玩电子游戏,说是游戏其实是骗骗主角的钱,赌博的意思\n\n主角和妹妹会在一开始拥有爷爷给的200块钱零花钱,初始玩家100块\n\n但是妹妹想要更多钱,所以要求玩家通过玩游戏来决一胜负,输一次20\n\n注意这个游戏只有在玩家与妹妹第一次玩游戏时涉及金钱,以后不算\n\n首先主角和妹妹玩小游戏,游戏分为三个\n\n第一个小游戏是陨石撞击地球\n\n小游戏是在一个电视中游玩的,其中电视中有三个游戏选项默认为第一个游戏Earth Hitting\n\n此时应该有一个逻辑判断\n\n因为选择游戏有一个设定:首先点击该游戏并弹出一个界面\"确认玩该游戏吗    玩------不玩\"\n\n其中所有对话只会执行一次不重复\n\n如果玩家选择第一个游戏,妹妹会嘲弄玩家技术菜声称要打爆玩家,游戏为三局两胜制,输了就会被无情嘲弄并损失20个货币\n\n赢得话妹妹很不高兴的给自己20块\n\n如果玩家选择 第一个游戏并取消,妹妹会表示遗憾说本来想和玩家玩第一个的,要不我们就玩这个(第二个游戏)吧,同样的奖惩机制\n\n如果第二个游戏仍然取消的话,妹妹会说\"那我们玩这个吧(第三个游戏)\"\n\n同理第三个游戏的奖惩机制和1,2一样\n\n如果玩家连续选择三个游戏并取消或者直接按X按钮关掉这个选择界面,妹妹会很生气质问玩家到底玩不玩,此时玩家可以表示自己\"玩或者不玩\",\n\n玩的话此时让玩家重新选择游戏,不玩的话妹妹好感度下降,以后看到玩家都很少主动和玩家玩游戏,而且玩家主动提出玩游戏时妹妹会\n\n不愿意,日后只有主动通过送东西才能回好感值\n\n如果玩家全部胜利,妹妹会难过,此时你可以选择归还妹妹30元或者全部,如果全部失败,妹妹先是非常高兴,但是还是会归还给玩家钱,表示只是想和玩家更专注的玩游戏\n\n以后再继续编吧\n","tags":["KoyouAsh","Unity"],"categories":["游戏开发"]},{"title":"00-灵感来源","url":"/2025/10/31/日记相关/KoyouAsh开发日记/00-灵感来源/","content":"\nHuyangPahuo\n胡杨怕火\n\n用拼音的话老外看不懂,\n但必须保证英语文化和日语文化的人看懂\n所以采用 \n\n以下是AI给我的解释:\n\n\n在日语中，“koyou”最常见的写法是 「紅葉」，它有个主要的读音和含义：\n\n读作 「Kōyō」 (こうよう) - 最普遍、最诗意的理解\n\n含义：指秋天树叶变红或变黄的现象，即“秋天的红叶”或“枫叶”。它不仅仅指叶子本身，更是指整个秋色斑斓的景色。\n\n给人的感觉：\n\n美丽与短暂：红叶被誉为日本秋季最美的风景，但它转瞬即逝，象征着事物美丽而短暂的本质（类似于“物哀”美学）。\n\n成熟与沉静：秋天是收获的季节，红叶代表着成熟、沉静和内敛的美。\n\n风雅与诗意：红叶是日本和歌、俳句和艺术中非常经典的题材，充满了古典、风雅的气息。\n\n转变与轮回：叶子从绿色变为红色或黄色，象征着变化、生命的周期和新的开始。\n\n\n然而koyou是叶子不是树,所以可以偷换概念,\n变成koyou,发音和こうよう类似,但不是红叶的意思,但可以由红叶联想到会长红色叶子的树,比如\"胡杨\"\n而huyang用koyou发音比较合适,还能联想到红叶\n\n但ash表示  燃烧残留的灰烬，如火山灰、烟灰。\n          火化后的骨灰，通常用复数形式“ashes”。\n          梣属乔木及其木材，如白蜡树。\n\n感觉挺好听的,所以暂时英文名字为\n\nKoyou Ash\n\n中文叫\"红叶烬\"\n我的名字为\"胡杨怕火\",koyou念起来挺像  ''胡杨'' 的","tags":["KoyouAsh","Unity"],"categories":["游戏开发"]}]