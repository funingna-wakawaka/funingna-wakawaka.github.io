<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#1a1a1a"><meta name="msapplication-navbutton-color" content="#1a1a1a"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>huyangpahuo</title><script>(function() {
  // 【修改点 1】头部脚本：如果本地存储为空(从未设置过)，默认开启暗色(true)
  var savedDarkMode = localStorage.getItem('darkMode');
  var shouldBeDark = savedDarkMode === null ? true : savedDarkMode === 'true';
  
  if (shouldBeDark) {
    document.documentElement.classList.add('dark-mode');
  }
})();
</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=Playfair+Display:wght@400;500;600;700&amp;family=Fira+Code:wght@400;500&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/tags.css">

<link rel="stylesheet" href="/css/categories.css">

<link rel="stylesheet" href="/css/categories-accordion.css">

<link rel="stylesheet" href="/css/highlight.css">

<link rel="stylesheet" href="/css/toc.css">

<link rel="stylesheet" href="/css/image-zoom.css">

<link rel="stylesheet" href="/css/share.css">

<link rel="stylesheet" href="/css/mobile-nav.css">

<link rel="stylesheet" href="/css/search.css">

<link rel="stylesheet" href="/css/scrollbar.css">

<link rel="stylesheet" href="/css/timeline.css">

<link rel="stylesheet" href="/css/animations.css">

<link rel="stylesheet" href="/css/ai-theme.css">

<link rel="stylesheet" href="/css/loading-animation.css">

<link rel="stylesheet" href="/css/article-modal.css">
<!-- 条件加载关于页面样式--><style>:root {
  --primary-color: #1a1a1a;
  --secondary-color: #666666;
  --accent-color: #ff6b6b;
  --background-color: #ffffff;
  --text-color: #333333;
  --overlay-color: rgba(0, 0, 0, 0.7);
  --tag-background-color: #ffffff;
  --card-background-color: #ffffff;
}
</style><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="app"><header class="header navbar-bubble"><nav class="nav"><div class="nav-container"><div class="nav-logo"><a href="/"><span class="nav-title">huyangpahuo</span></a></div><div class="nav-menu"><a class="nav-item" href="/">首页</a><a class="nav-item" href="/about/">关于</a><a class="nav-item" href="/archives/">归档</a><a class="nav-item" href="/categories/">分类</a><a class="nav-item" href="/tags/">标签</a><a class="nav-item" href="/link/">友链</a><a class="nav-item" href="#lang-switch">Language</a><div class="nav-item has-submenu"><span class="nav-link">浏览器插件推荐</span><div class="submenu"><a class="submenu-item" target="_blank" rel="noopener" href="https://darkreader.org/">DarkReader(可以强制网页黑色主题)</a><a class="submenu-item" target="_blank" rel="noopener" href="https://www.code-box.fun/">CodeBox(可以下载平台文章)</a><a class="submenu-item" target="_blank" rel="noopener" href="https://immersivetranslate.cn/">ImmersiveTranslate(可以翻译网页外语)</a><a class="submenu-item" target="_blank" rel="noopener" href="https://www.aixdownloader.com/zh">AixDownloader(可以批量下载图片)</a></div></div><div class="nav-item has-submenu"><span class="nav-link">更多</span><div class="submenu"><a class="submenu-item" target="_blank" rel="noopener" href="https://huyangpahuo.github.io/">我的另一个网站</a><a class="submenu-item" target="_blank" rel="noopener" href="https://huyangpahuo.vercel.app/">我的另二个网站(狗头)</a><a class="submenu-item" target="_blank" rel="noopener" href="https://github.com/funingna-wakawaka">我的Github小号</a><a class="submenu-item" target="_blank" rel="noopener" href="https://gitee.com/huyangpahuo">我的Gitee</a><a class="submenu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/yjj009049?type=blog">我的CDSN</a></div></div><!-- 搜索按钮--><div class="search-toggle"><i class="fas fa-search"></i></div></div><div class="nav-toggle"><span></span><span></span><span></span></div></div></nav></header><div class="search-overlay"><div class="search-container"><div class="search-form"><input class="search-input" type="text" placeholder="搜索文章..."/><div class="search-close">×</div></div><div class="search-results"></div></div></div><main class="main"><div class="post-wrapper"><div class="toc-sidebar"><div class="toc-container"><div class="toc-title">目录</div><div class="toc-content" id="table-of-contents"><!-- Table of contents will be generated by JavaScript--></div></div></div><article class="post-container"><div class="post-header"><div class="post-cover"><img src="/images/9.png" alt="数据结构第四天----单链表的学习"/></div><div class="post-meta"><div class="post-category"><i class="fas fa-folder-open" style="margin-right: 5px"></i><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-date"><i class="far fa-calendar-alt" style="margin-right: 5px"></i><time datetime="2026-01-08T11:25:59.000Z">2026-01-08</time></div><div class="post-author"><i class="fas fa-user" style="margin-right: 5px"></i><span>huyangpahuo</span></div><div class="post-wordcount"><i class="fas fa-file-word" style="margin-right: 5px"></i><span>3.9k</span><span style="margin-left: 3px">字</span></div><div class="post-readtime"><i class="fas fa-clock" style="margin-right: 5px"></i><span>16</span><span style="margin-left: 3px">分钟</span></div></div><h1 class="post-title">数据结构第四天----单链表的学习</h1><div class="post-tags"><a class="tag" href="/tags/Data-Structure/"><i class="fas fa-tag" style="margin-right: 3px"> </i>Data Structure</a></div></div><!-- AI摘要模块容器--><div id="post-ai-container"></div><div class="post-content"><h1 id="好了-学完了顺序表-我们再来看一下链表"><a href="#好了-学完了顺序表-我们再来看一下链表" class="headerlink" title="好了,学完了顺序表,我们再来看一下链表"></a>好了,学完了顺序表,我们再来看一下链表</h1><p>线性表链式存储结构的特点是:</p>
<blockquote>
<p>用一组任意的存储单元存储线性表的数据元素   (这组存储单元可以是连续的，也可以是不连续的)</p>
</blockquote>
<p>说人话就是  链表是一种<strong>不要求内存连续</strong>、通过“<strong>指针&#x2F;引用</strong>”把元素串起来的数据结构。</p>
<p>为了表示每个数据元素a(i)与其直接后续数据元素a(i+1)之间的逻辑关系,  对数据元素a(i)来说除了其本身的信息之外，还需要存储一个指示，其直接后继的信息  (直接后继的存储位置),这两部分信息组成数据元素a(i)的存储映像，称为<font color='Turquoise'>节点(node)</font></p>
<p>节点包括两个域:</p>
<ul>
<li>其中存储数据元素的信息称为<font color='Turquoise'>数据域</font> 即  data</li>
<li>存储直接后继存储位置有域称为<font color='Turquoise'>指针域</font>  即  next</li>
</ul>
<p>指针域中存储的信息称为   <font color='Turquoise'>指针或链</font></p>
<p>n个节点[a(i) i范围为(1&lt;&#x3D;i&lt;&#x3D;n)的存储映像]链接成一个链表即为线性表(a1,a2…an)</p>
<p>相信你可能没有看懂我说的这些东西是啥玩意</p>
<p>这里是一个C语言的代码示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">		ElemType data;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>

<p>我们可以把这个用一个图抽象出来</p>
<p>​	<style>.lufbykgrchul{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260106192044936.png" class="lufbykgrchul" alt="image-20260106192044936"></p>
<p>其实我个人觉得用铁链这样的结构来描述并不是很准确,我反而觉得像火车这样的模型更加生动形象,火车头是头结点,每节车厢都是一个节点,车厢有自己的编号而且里面的乘客就是数据</p>
<p>​	<style>.bnuvkxgiuzxc{zoom:80%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/Fn8lTzER8g.jpg" class="bnuvkxgiuzxc" alt="卡通手绘火车"></p>
<p>我们先来看看单链表吧</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>​	<style>.xpnlwtwohjxo{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260106192446584.png" class="xpnlwtwohjxo" alt="image-20260106192446584"></p>
<p>这里你也可以看出,单链表的结构非常简单,就像小火车一样,这里从图中你可以发现单链表的几个性质</p>
<p><strong>单链表是最基础、最常见的一种链表</strong></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>单链表每个节点<strong>只有一个指针</strong>，只指向「下一个节点」</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head → [A|•] → [B|•] → [C|null]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>head</code>：头节点（链表的入口）</li>
<li>最后一个节点指向 <code>null</code></li>
</ul>
<p>如果你没看懂的话这里我详细解释一下</p>
<p>​	<style>.acnmyhibppjo{zoom: 25%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260106195217062.png" class="acnmyhibppjo" alt="image-20260106195217062"></p>
<p>链由节点构成,data存储数据 next用于连接下一个节点,next为node类型的指针,存储下一个节点的地址</p>
<p>类似于一个半班有40个同学,每个同学的手上都有一张纸,上面写着另一个同学的学号,而同学本身就是一个地址数据,这样这个同学可以用自己的手上的学号找到另一个同学,形成一个链</p>
<p>​	<style>.smzjriegkecl{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107103534965.png" class="smzjriegkecl" alt="image-20260107103534965"></p>
<p>​	同样的是单链表也是这样的</p>
<h2 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h2><p>大家是否还记得在上一篇的顺序表当中我们使用动态分配内存来进行顺序表的初始化,这里我们也可以使用malloc动态分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">		ElemType data;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node*<span class="title function_">initList</span><span class="params">()</span>&#123;</span><br><span class="line">	Node*head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	head-&gt;data=<span class="number">0</span>;</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//将list初始化为一个头节点</span></span><br><span class="line">	Node*<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.jbvrjpynsbyr{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260106194539055.png" class="jbvrjpynsbyr" alt="image-20260106194539055"></p>
<p>其实本质上就是把第一个点设置为头节点,然后将节点里的data数据归零,并且将节点的下一个节点设置为  null</p>
<p>首先用malloc在堆内存中构建了一个节点大小的空间,作为链表头结点 head  即  initlist 函数返回Node类型的指针head</p>
<p>默认给data数据域为0 令next地址为空</p>
<p>​	<style>.qqqixcjwcvgk{zoom: 80%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107111435772.png" class="qqqixcjwcvgk" alt="image-20260107111435772"></p>
<h2 id="单链表的头插法"><a href="#单链表的头插法" class="headerlink" title="单链表的头插法"></a>单链表的头插法</h2><p> 注意:头插法的顺序和排列的顺序是相反的 </p>
<p>刚开始只有一个头节点,如果要插入一个数据就往头节点后面去插 ,把头节点next指向第二个节点的那个地址,如果再要插入一个数据,则仍在头节点之后插入</p>
<p>注意,顺序不能错,错了链表就断了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertHead</span><span class="params">(Node*L,ElemType e)</span>&#123;</span><br><span class="line">	Node*p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=L-&gt;next;</span><br><span class="line">	L-&gt;next=p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	insertHead(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">	insertHead(<span class="built_in">list</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.upkmiyjwprcg{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%A4%B4%E6%8F%92%E6%B3%95-01.jpg" class="upkmiyjwprcg" alt="单链表-头插法-01"></p>
<p>​	<style>.xrfuvyloendr{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%A4%B4%E6%8F%92%E6%B3%95-02.jpg" class="xrfuvyloendr" alt="单链表-头插法-02"></p>
<p>​	<style>.gpciywupuelj{zoom:67%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%A4%B4%E6%8F%92%E6%B3%95-03.jpg" class="gpciywupuelj" alt="单链表-头插法-03"></p>
<p>这里我们画一个图直观表述一下</p>
<p>​	<style>.fponvjmaroht{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107111909640.png" class="fponvjmaroht" alt="image-20260107111909640"></p>
<p>第一步:先在内存空间中创建一个节点,然后把传入的e参数赋值给节点中data的数据,即p-&gt;data&#x3D;e;</p>
<p>让头结点参数L指向的下一个节点的地址赋值给新创建的节点指向的下一个节点的地址 即 p-&gt;next&#x3D;L-&gt;next;</p>
<p>​	<style>.skyhhwtdfgpj{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107112001392.png" class="skyhhwtdfgpj" alt="image-20260107112001392"></p>
<p>第二步: 然后将p的地址赋值为当前头结点指向的下一个地址  即 L-&gt;next&#x3D;p;</p>
<p>​	<style>.igmvnfknekot{zoom: 33%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107112758717.png" class="igmvnfknekot" alt="image-20260107112758717"></p>
<p>​	<style>.tkjbjpbdmucy{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107112831150.png" class="tkjbjpbdmucy" alt="image-20260107112831150"></p>
<p>这个我们可以用更加直观的可视化图看一下</p>
<p>​	<style>.qzwptsdtubeh{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107113505921.png" class="qzwptsdtubeh" alt="image-20260107113505921"></p>
<p>说人话就是先创建一个空节点,塞进去一个数据,再把这个节点和之前和头结点相连的那个节点连起来,再让头结点连接这个节点,这样可以确保链不会断掉</p>
<h2 id="单链表的遍历"><a href="#单链表的遍历" class="headerlink" title="单链表的遍历"></a>单链表的遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listNode</span><span class="params">(Node*L)</span>&#123;</span><br><span class="line">	Node*p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	insertHead(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">	insertHead(<span class="built_in">list</span>,<span class="number">20</span>);</span><br><span class="line">	insertHead(<span class="built_in">list</span>,<span class="number">30</span>);</span><br><span class="line">	</span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.dufqsdidtudn{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107114631726.png" class="dufqsdidtudn" alt="image-20260107114631726"></p>
<p>遍历的原理也十分浅显易懂:</p>
<p>打印头结点的下一个节点的数据,打印完了再换下一个,一直到遇到尾节点全部打印完成为止</p>
<h2 id="单链表的尾插法"><a href="#单链表的尾插法" class="headerlink" title="单链表的尾插法"></a>单链表的尾插法</h2><p>其实相比于头插法这种倒序插入,我更喜欢尾插法这种正序插入的方式</p>
<p>尾插法就是先获取尾节点的地址,然后再去进行尾插法  </p>
<p>即先传进来L链表,链表进来之后赋值给一个p指针  , 如果p的next不为空我们就持续循环p等于p的next  , 相当于一个链一个链的去找,找到最后一个链的时候跳出循环 , 跳出循环的时候 p就是链表的尾节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="comment">//先获取尾节点</span></span><br><span class="line">Node*<span class="title function_">get_tail</span><span class="params">(Node*L)</span>&#123;</span><br><span class="line">	Node *p=L;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再实现尾插</span></span><br><span class="line">Node*<span class="title function_">insertTail</span><span class="params">(Node *tail,ElemType e)</span>&#123;</span><br><span class="line">	Node *p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	tail-&gt;next=p;</span><br><span class="line">	<span class="comment">//让p的下一个节点变成NULL,并返回尾节点的地址</span></span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	</span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.mymshjtjlerf{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%B0%BE%E6%8F%92%E6%B3%95-01.jpg" class="mymshjtjlerf" alt="单链表-尾插法-01"></p>
<p>​	<style>.gkykhefxtjqn{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%B0%BE%E6%8F%92%E6%B3%95-02.jpg" class="gkykhefxtjqn" alt="单链表-尾插法-02"></p>
<p>​	<style>.hmnlytstjrmx{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%B0%BE%E6%8F%92%E6%B3%95-03.jpg" class="hmnlytstjrmx" alt="单链表-尾插法-03"></p>
<p>这里我们可以详细描述一下</p>
<p>第一步:先获取尾节点的地址,思路和遍历差不多</p>
<p>​	<style>.xdxdnuuioewr{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107115906521.png" class="xdxdnuuioewr" alt="image-20260107115906521"></p>
<p>第二步:这个和头插法基本上差不过,只是多一个步骤那就是将插入的节点变成尾节点</p>
<p>​	<style>.zbjbienjeljo{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107122507227.png" class="zbjbienjeljo" alt="image-20260107122507227"></p>
<p>这里可以用一个图来直观描述</p>
<p>​	<style>.fymnqqcssbyv{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107122745285.png" class="fymnqqcssbyv" alt="image-20260107122745285"></p>
<h2 id="单链表在指定位置插入数据"><a href="#单链表在指定位置插入数据" class="headerlink" title="单链表在指定位置插入数据"></a>单链表在指定位置插入数据</h2><p>前面说的头插法和尾插法只是在表头或者表尾插入节点,而这里是在任意位置插入</p>
<p>原理:</p>
<p>将原来的链拆除,生成一个新的节点,让新的节点指向插入之前的位置 , 即先获取要插入的节点的位置, 然后让新节点指向要插入的节点所指向的位置,再让被插入的节点指向新节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定位置插入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertNode</span><span class="params">(Node*L,<span class="type">int</span> pos,ElemType e)</span>&#123;</span><br><span class="line">	<span class="comment">//用来保存插入位置的前驱节点</span></span><br><span class="line">	Node *p=L;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//遍历链表找到插入位置的前驱节点</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;pos<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//要插入的新节点</span></span><br><span class="line">	Node *q=(Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	q-&gt;data=e;</span><br><span class="line">	q-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=q;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//插入前</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	insertNode(<span class="built_in">list</span>,<span class="number">2</span>,<span class="number">15</span>);</span><br><span class="line">	<span class="comment">//插入后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.ynngljrepbca{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260107140622958.png" class="ynngljrepbca" alt="image-20260107140622958"></p>
<p>​	<style>.pdbkjpgfikgm{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.jpg" class="pdbkjpgfikgm" alt="单链表-在指定位置插入数据"></p>
<h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><p>原理: 先找到要删除节点的前置节点,用指针记录要删除的节点,通过修改前置节点的后继结点实现删除,释放删除节点的内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteNode</span><span class="params">(Node *L,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">	<span class="comment">//要删除节点的前驱</span></span><br><span class="line">	Node*p=L;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//遍历链表找到要删除节点的前驱</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;pos<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的位置错误\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//q指向要删除的节点</span></span><br><span class="line">	Node *q=p-&gt;next;</span><br><span class="line">	<span class="comment">//让要删除节点的前驱指向要删除节点的后继</span></span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="comment">//释放要删除节点的内存空间</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//插入前</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	insertNode(<span class="built_in">list</span>,<span class="number">2</span>,<span class="number">15</span>);</span><br><span class="line">	<span class="comment">//插入后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	deleteNode(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//删除后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.eobuwlhjlwhk{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108101907256.png" class="eobuwlhjlwhk" alt="image-20260108101907256"></p>
<p>​	<style>.iopxblxbcivb{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.jpg" class="iopxblxbcivb" alt="单链表-删除节点"></p>
<h2 id="单链表获取链表长度"><a href="#单链表获取链表长度" class="headerlink" title="单链表获取链表长度"></a>单链表获取链表长度</h2><p>声明一个变量用来累加每循环一次累加一次到尾节点为止,返回尾节点的长度</p>
<p>这个代码假如前面的代码大家看懂了应该可以轻轻松松看懂吧,本质和遍历一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listLength</span><span class="params">(Node *L)</span>&#123;</span><br><span class="line">	Node*p=L;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//插入前</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	insertNode(<span class="built_in">list</span>,<span class="number">2</span>,<span class="number">15</span>);</span><br><span class="line">	<span class="comment">//插入后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	deleteNode(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//删除后</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,listLength(<span class="built_in">list</span>));</span><br><span class="line">	<span class="comment">//链表长度</span></span><br><span class="line">	listLength(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.aerbcbfucgta{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108103644323.png" class="aerbcbfucgta" alt="image-20260108103644323"></p>
<h2 id="单链表释放链表"><a href="#单链表释放链表" class="headerlink" title="单链表释放链表"></a>单链表释放链表</h2><p>指针p指向头节点后的第一个节点,判断指针p是否指向空节点,如果指针P不为空,用指针q记录指针p的后继节点,释放指针P指向的节点,指针p和指针q指向同一个节点循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(Node*L)</span>&#123;</span><br><span class="line">	<span class="comment">//L头节点</span></span><br><span class="line">	Node *p=L-&gt;next;</span><br><span class="line">	Node *q;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//插入前</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	insertNode(<span class="built_in">list</span>,<span class="number">2</span>,<span class="number">15</span>);</span><br><span class="line">	<span class="comment">//插入后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	deleteNode(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//删除后</span></span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//链表长度</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,listLength(<span class="built_in">list</span>));</span><br><span class="line">	freeList(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,listLength(<span class="built_in">list</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<style>.hfemuldnudrn{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108103406542.png" class="hfemuldnudrn" alt="image-20260108103406542"></p>
<p>​	<style>.hcfoxisswicn{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108103544150.png" class="hcfoxisswicn" alt="image-20260108103544150"></p>
<p>​	<style>.jefjrzsxuear{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108103603614.png" class="jefjrzsxuear" alt="image-20260108103603614"></p>
<h2 id="好了-最基本的我们说完了——-等一下-你不能走-把这碗鸡汤喝了-狗头狗头狗头"><a href="#好了-最基本的我们说完了——-等一下-你不能走-把这碗鸡汤喝了-狗头狗头狗头" class="headerlink" title="好了,最基本的我们说完了——-等一下,你不能走,把这碗鸡汤喝了  狗头狗头狗头"></a>好了,最基本的我们说完了——-等一下,你不能走,把这碗鸡汤喝了  狗头狗头狗头</h2><h2 id="单链表的双指针"><a href="#单链表的双指针" class="headerlink" title="单链表的双指针"></a>单链表的双指针</h2><p>这个其实用实际的例子来解释更直观一点,不然太抽象了</p>
<h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>​	<style>.fthyziivjasi{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A801-01.jpg" class="fthyziivjasi" alt="单链表应用01-01"></p>
<p>​	<style>.rthspqlrihyd{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A801-02.jpg" class="rthspqlrihyd" alt="单链表应用01-02"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到节点数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findNodeFS</span><span class="params">(Node *L,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	Node *fast=L-&gt;next;</span><br><span class="line">	Node *slow=L-&gt;next;</span><br><span class="line">	<span class="comment">//循环K次每次先走1步,即先走K步</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		fast=fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		fast=fast-&gt;next;</span><br><span class="line">		slow=slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;倒数第%d个节点值为:%d\n&quot;</span>,k,slow-&gt;data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *<span class="built_in">list</span>=initList();</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tail=get_tail(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tail=insertTail(tail,<span class="number">10</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">20</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">30</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">40</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">50</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">60</span>);</span><br><span class="line">	tail=insertTail(tail,<span class="number">70</span>);</span><br><span class="line">	</span><br><span class="line">	listNode(<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">//找到节点值</span></span><br><span class="line">	findNodeFS(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>第一步:我们先假设找到这个4节点(倒数第三个节点),让快慢指针都指向第一个节点即头节点的下一个节点</p>
 <style>.jopapbrjzfmr{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108105305089.png" class="jopapbrjzfmr" alt="image-20260108105305089">

<p>第二步:先让快指针走3步,这里本质上是用慢指针来找到数据的</p>
<p>​	<style>.nwvjzsacpfcx{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108105414949.png" class="nwvjzsacpfcx" alt="image-20260108105414949"></p>
<p>第三步:快指针走完后两个指针再同步走</p>
<p>​	<style>.lqblackbdnlx{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108105624598.png" class="lqblackbdnlx" alt="image-20260108105624598"></p>
<p>第四步:一直到快指针遇到尾节点时慢指针就找到了</p>
<p>​	<style>.opnhbgwrpnvc{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108105701910.png" class="opnhbgwrpnvc" alt="image-20260108105701910"></p>
 <style>.ejrwoxjhmnnr{zoom:33%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/image-20260108105730652.png" class="ejrwoxjhmnnr" alt="image-20260108105730652">

<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>这个例子也是第一眼抽象至极</p>
<p>​	<style>.ousdgkfnksen{zoom: 50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A802-01.jpg" class="ousdgkfnksen" alt="单链表应用02-01"></p>
<p>第一步:我们要先求出两个链表的长度,用于判断两个链表的长度的差距</p>
<p>​	<style>.glblstrhostb{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A802-02.jpg" class="glblstrhostb" alt="单链表应用02-02"></p>
<p>第二步:让快指针指向更长的那个链表并先走两表的差距长度</p>
<p>​	<style>.kqnkeyoncbtz{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A802-03.jpg" class="kqnkeyoncbtz" alt="单链表应用02-03"></p>
<p>第三步:然后两个指针一起动</p>
<p>​	<style>.xxwoovsqaqrk{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A802-04.jpg" class="xxwoovsqaqrk" alt="单链表应用02-04"></p>
<p>第四步:然后就会发现两个指针指向同一个地方</p>
<p>​	<style>.muqtecfidtsg{zoom:50%;}</style><img src="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A802-05.jpg" class="muqtecfidtsg" alt="单链表应用02-05"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化节点(带节点数据域参数)  不同于之前的单链表的初始化,因为我们要传参,而不是空参</span></span><br><span class="line">Node*<span class="title function_">initListWithElem</span><span class="params">(ElemType e)</span>&#123;</span><br><span class="line">	Node *node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	node-&gt;data=e;</span><br><span class="line">	node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找两个节点共同后缀的起始位置</span></span><br><span class="line">Node*<span class="title function_">findIntersectionNode</span><span class="params">(Node *headA,Node*headB)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Node*p=headA;</span><br><span class="line">	<span class="type">int</span> lenA=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> lenB=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历链表A,获取链表A的长度</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		lenA++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历链表B,获取链表B的长度</span></span><br><span class="line">	p=headB;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		lenB++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Node *m;<span class="comment">//快指针</span></span><br><span class="line">	Node *n;<span class="comment">//慢指针</span></span><br><span class="line">	<span class="type">int</span> step;<span class="comment">//两个单词之间手差值,可以用于快指针先走的步数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">		step=lenA-lenB;</span><br><span class="line">		m=headA;</span><br><span class="line">		n=headB;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		step=lenB-lenA;</span><br><span class="line">		m=headB;</span><br><span class="line">		n=headA;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//让快指针先走step步</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">		m=m-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//快慢指针同步走,直到指向同一个节点退出循环</span></span><br><span class="line">	<span class="keyword">while</span>(m!=n)&#123;</span><br><span class="line">		m=m-&gt;next;</span><br><span class="line">		n=n-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Node *listA=initList();</span><br><span class="line">	Node *listB=initList();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//得到当前尾节点</span></span><br><span class="line">	Node *tailA=get_tail(listA);</span><br><span class="line">	Node *tailB=get_tail(listB);</span><br><span class="line">	<span class="comment">//每次在尾节点位置插入数据后更新尾节点的位置</span></span><br><span class="line">	tailA=insertTail(tailA,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">	tailA=insertTail(tailA,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">	tailA=insertTail(tailA,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	tailA=insertTail(tailA,<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	tailB=insertTail(tailB,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">	tailB=insertTail(tailB,<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	这段代码的问题是：</span></span><br><span class="line"><span class="comment">//	每次 insertTail 都会新建一个节点，即使你插入的是相同的字符 &#x27;i&#x27;，它们也是两个不同的节点。</span></span><br><span class="line"><span class="comment">//	所以 tailA 和 tailB 的尾部节点地址不同，没有共享，自然找不到共同后缀。</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	tailA=insertTail(tailA,&#x27;i&#x27;);</span></span><br><span class="line"><span class="comment">//	tailA=insertTail(tailA,&#x27;n&#x27;);</span></span><br><span class="line"><span class="comment">//	tailA=insertTail(tailA,&#x27;g&#x27;);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	tailB=insertTail(tailB,&#x27;i&#x27;);</span></span><br><span class="line"><span class="comment">//	tailB=insertTail(tailB,&#x27;n&#x27;);</span></span><br><span class="line"><span class="comment">//	tailB=insertTail(tailB,&#x27;g&#x27;);</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	这段代码的核心是：</span></span><br><span class="line"><span class="comment">//  nodeI、nodeN、nodeG 是同一份节点对象，被两个链表共享。</span></span><br><span class="line"><span class="comment">//	因此两个链表在尾部确实指向了同一个物理地址，满足了“共享后缀”的要求。</span></span><br><span class="line">	</span><br><span class="line">	Node *nodeI=initListWithElem(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">	tailA=insertTailWithNode(tailA,nodeI);</span><br><span class="line">	tailB=insertTailWithNode(tailB,nodeI);</span><br><span class="line">	</span><br><span class="line">	Node *nodeN=initListWithElem(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">	tailA=insertTailWithNode(tailA,nodeN);</span><br><span class="line">	tailB=insertTailWithNode(tailB,nodeN);</span><br><span class="line">	</span><br><span class="line">	Node *nodeG=initListWithElem(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">	tailA=insertTailWithNode(tailA,nodeG);</span><br><span class="line">	tailB=insertTailWithNode(tailB,nodeG);</span><br><span class="line">	</span><br><span class="line">	listNode(listA);</span><br><span class="line">	listNode(listB);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,findIntersectionNode(listA,listB)-&gt;data);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><!-- 初始化AI摘要--><script>document.addEventListener('DOMContentLoaded', function() {
  if (typeof ChucklePostAI !== 'undefined') {
    // 获取按钮文本，如果未定义则使用默认值
    const buttons = [
      "介绍自己",
      "来点灵感",
      "生成AI简介"
    ];

    new ChucklePostAI({
      el: '#post-ai-container',
      title_el: '.post-title',
      summary_directly: false,
      interface: {
        name: "阿罗娜",
        introduce: "老师好, 我是阿罗娜, 一个基于OpenAI GPT-4o的强大语言模型, 今天有什么可以帮到您? 😊",
        version: "OpenAI GPT-4o",
        button: buttons
      }
    });
  }
});
</script><!-- 传递TOC配置给前端--><script>// 创建全局TOC配置对象
window.tocConfig = {
  empty_toc_behavior: "placeholder"
};
</script><div class="post-navigation"><div class="post-nav prev"><a href="/2026/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/SQL%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%80%E5%A4%A9/"><span class="nav-label">← 上一篇</span><span class="nav-title">数据库第一天---了解数据库和SQL的DDL</span></a></div><div class="post-nav next"><a href="/2026/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/C%E8%AF%AD%E8%A8%80/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="nav-label">下一篇 →</span><span class="nav-title">之前用C语言设计的学生管理系统</span></a></div></div><div class="post-share"><h3 class="share-title">分享这篇文章到</h3><div class="share-buttons"><a class="share-btn twitter" href="https://twitter.com/intent/tweet?text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E5%A4%A9----%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0&amp;url=%2F2026%2F01%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%259B%25B8%25E5%2585%25B3%2F02-%25E8%25A1%25A8%2F%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8%2F" target="_blank" rel="noopener"><span>推特</span></a><a class="share-btn facebook" href="https://www.facebook.com/sharer/sharer.php?u=%2F2026%2F01%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%259B%25B8%25E5%2585%25B3%2F02-%25E8%25A1%25A8%2F%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8%2F" target="_blank" rel="noopener"><span>脸书</span></a><a class="share-btn linkedin" href="https://www.linkedin.com/sharing/share-offsite/?url=%2F2026%2F01%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%259B%25B8%25E5%2585%25B3%2F02-%25E8%25A1%25A8%2F%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8%2F" target="_blank" rel="noopener"><span>领英</span></a><a class="share-btn wechat" href="#" data-wechat="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/"><span>微信</span></a><a class="share-btn qq" href="https://connect.qq.com/widget/shareqq/index.html?url=%2F2026%2F01%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%259B%25B8%25E5%2585%25B3%2F02-%25E8%25A1%25A8%2F%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8%2F&amp;title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E5%A4%A9----%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener"><span>QQ</span></a><a class="share-btn weibo" href="https://service.weibo.com/share/share.php?url=%2F2026%2F01%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%259B%25B8%25E5%2585%25B3%2F02-%25E8%25A1%25A8%2F%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8%2F&amp;title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E5%A4%A9----%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener"><span>微博</span></a><a class="share-btn copy" href="#" data-copy="/2026/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/02-%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8/"><span>点击复制链接</span></a></div></div></article></div><section class="comments-section"><div class="comments-container"><h2 class="comments-title">评论区</h2><div class="comments-content"><div id="twikoo-comments"></div><div id="twikoo"></div><script src="https://unpkg.com/twikoo@1.6.39/dist/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://twikoo-five-ruby.vercel.app',
  el: '#twikoo',
  region: '',
  path: 'window.location.pathname',
  visitor: true,
  onCommentLoaded: function () {
    console.log('Twikoo评论加载成功');
  }
});</script></div></div></section></main><footer class="footer"><div class="footer-bottom"><div class="footer-copyright">© 2025 胡杨怕火. 保留所有权利.</div><!-- Footer centered image with link--><div class="footer-image" style="text-align: center; margin: 15px 0;"><a href="https://bluearchive-cn.com/" target="_blank" rel="noopener noreferrer"><img src="https://github.com/funingna-wakawaka/picx-images-hosting/raw/master/碧蓝档案.3yew7g3xtc.webp" alt="Footer Image" style="max-width: 100%; height: auto;"/></a></div></div></footer></div><!-- 立即应用暗色模式，避免页面闪烁--><script>(function() {
  // 【修改点 2】底部脚本：同样逻辑，默认为 true
  var savedDarkMode = localStorage.getItem('darkMode');
  var shouldBeDark = savedDarkMode === null ? true : savedDarkMode === 'true';

  if (shouldBeDark) {
    document.body.classList.add('dark-mode');
  }

  // 防止页面闪烁，在DOM加载完成前设置一个初始类
  document.documentElement.style.visibility = 'hidden';
  document.addEventListener('DOMContentLoaded', function() {
    document.documentElement.style.visibility = 'visible';
  });
})();
</script>
<script src="/js/main.js"></script>

<script src="/js/tags.js"></script>

<script src="/js/categories-accordion.js"></script>

<script src="/js/highlight.js"></script>

<script src="/js/load-more.js"></script>

<script src="/js/header-scroll.js"></script>

<script src="/js/toc.js"></script>

<script src="/js/image-zoom.js"></script>

<script src="/js/share.js"></script>

<script src="/js/search.js"></script>

<script src="/js/hide-inline-interaction.js"></script>

<script src="/js/hide-toggle-interaction.js"></script>

<script src="/js/dark-mode-sync.js"></script>

<script src="/js/animations.js"></script>

<script src="/js/ai-theme.js"></script>

<script src="/js/loading-animation.js"></script>

<script src="/js/article-modal.js"></script>
<script>window.theme = {
  features: {"dark_mode":true,"smooth_scroll":true,"back_to_top":true,"loading_animation":true},
  code_block: {"height_limit":200,"enable_folding":true,"max_height":"300px","show_lang":true},
  ai_summary: {"enable":true,"api_key":"","summary_directly":false,"ai_name":"阿罗娜","ai_introduce":"老师好, 我是阿罗娜, 一个基于OpenAI GPT-4o的强大语言模型, 今天有什么可以帮到您? 😊","ai_version":"OpenAI GPT-4o","buttons":["介绍自己","来点灵感","生成AI简介"]},
  categories: {"layout":"accordion","accordion_animation":true,"show_empty_categories":true},
  article_list: {"card_size":"normal","view_mode":"modal"}
};
</script><script src="/js/ai.js"></script><script src="/js/postai.js"></script><script src="/js/math-support.js"></script><script src="/js/click-heart.js"></script><script src="/js/falling-leaves.js"></script><script src="/js/lang-switch.js"></script></body></html>